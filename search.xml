<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Spring注解</title>
    <url>/2021/06/28/Spring%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="Spring注解"><a href="#Spring注解" class="headerlink" title="Spring注解"></a>Spring注解</h1><h4 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h4><blockquote>
<p>包含<code>@Configuration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code>，通常放在主类上。</p>
</blockquote>
<h4 id="Controller"><a href="#Controller" class="headerlink" title="@Controller"></a>@Controller</h4><blockquote>
<p>标志是一个控制器类，需要与<code>@RequestMapping</code>配合使用。通常做前后端分离的项目用这个注解比较少，因为后端只返回json数据结构，而不是页面。</p>
</blockquote>
<h4 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h4><blockquote>
<p>该注解是<code>@Controller</code>和<code>@ResponseBody</code>的组合注解</p>
</blockquote>
<table>
<thead>
<tr>
<th>普通风格</th>
<th>Rest风格</th>
</tr>
</thead>
<tbody><tr>
<td>@RequestMapping(value=“”,method = RequestMethod.GET)</td>
<td>@GetMapping(value =“”)</td>
</tr>
<tr>
<td>@RequestMapping(value=“”,method = RequestMethod.POST)</td>
<td>@PostMapping(value =“”)</td>
</tr>
<tr>
<td>@RequestMapping(value=“”,method = RequestMethod.PUT)</td>
<td>@PutMapping(value =“”)</td>
</tr>
<tr>
<td>@RequestMapping(value=“”,method = RequestMethod.DELETE)</td>
<td>@DeleteMapping(value =“”)</td>
</tr>
</tbody></table>
<h4 id="Service"><a href="#Service" class="headerlink" title="@Service"></a>@Service</h4><blockquote>
<p>标注该类是一个接口服务</p>
</blockquote>
<p>####@Autowired</p>
<blockquote>
<p>当我需要从bean工程获取一个<code>ben</code>时，<code>spring</code>就自动为我们装配该标识为<code>@Autowired</code>的元素</p>
</blockquote>
<p>####@Resource</p>
<blockquote>
<p>与<code>Autowired</code>获取相同的效果，不过该注解并不是<code>spring</code>提供的，而是<code>j2ee</code>提供的。两者的差别是<code>Autowired</code>通过类型匹配，而<code>Resource</code>通过名称匹配</p>
</blockquote>
<h4 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h4><blockquote>
<p>配置文件注解</p>
</blockquote>
<h4 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h4><blockquote>
<p>读取<code>yaml</code>文件的注解，并可以设置默认值</p>
</blockquote>
<h4 id="Repository"><a href="#Repository" class="headerlink" title="@Repository"></a>@Repository</h4><blockquote>
<p><code>jpa</code>的<code>dao</code>注解，通过标注了该注解的类可以操作数据库</p>
</blockquote>
<h4 id="RequestMap"><a href="#RequestMap" class="headerlink" title="@RequestMap"></a>@RequestMap</h4><blockquote>
<p>类注解，标明访问该接口的请求地址的开头应该是什么路径</p>
</blockquote>
<h4 id="GetMapping"><a href="#GetMapping" class="headerlink" title="@GetMapping"></a>@GetMapping</h4><blockquote>
<p><code>get</code>请求的缩写，上表格有说明</p>
</blockquote>
<h4 id="PostMapping"><a href="#PostMapping" class="headerlink" title="@PostMapping"></a>@PostMapping</h4><blockquote>
<p><code>post</code>请求的缩写，上表格有说明</p>
</blockquote>
<h4 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a>@PathVariable</h4><blockquote>
<p>路径分隔符变量，用于前端通过地址通配符给后端传递参数</p>
</blockquote>
<h4 id="RequestBody、-RequestParam"><a href="#RequestBody、-RequestParam" class="headerlink" title="@RequestBody、@RequestParam"></a>@RequestBody、@RequestParam</h4><blockquote>
<p>参数注解，通过在参数上标注该注解，前端通过<code>?</code>后面传递参数</p>
</blockquote>
<h4 id="EnableConfigurationProperties"><a href="#EnableConfigurationProperties" class="headerlink" title="@EnableConfigurationProperties"></a>@EnableConfigurationProperties</h4><blockquote>
<p>启用配置文件的注解，读取<code>yaml</code>文件的内容到自定义的<code>bean</code>中</p>
</blockquote>
<h4 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h4><blockquote>
<p>组件注解</p>
</blockquote>
<h4 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h4><blockquote>
<p>与<code>EnableConfigurationProperties</code>搭配使用，标注自定义对象中的字段是从<code>yaml</code>文件中的哪个接口开始匹配</p>
</blockquote>
]]></content>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>git手册</title>
    <url>/2021/06/28/git%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h2 id="git配置"><a href="#git配置" class="headerlink" title="git配置"></a>git配置</h2><h3 id="配置当前项目"><a href="#配置当前项目" class="headerlink" title="配置当前项目"></a>配置当前项目</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config user.name <span class="string">&#x27;你的名字&#x27;</span></span><br><span class="line">git config user.email <span class="string">&#x27;你的邮箱&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="修改全局配置"><a href="#修改全局配置" class="headerlink" title="修改全局配置"></a>修改全局配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git --global config user.name <span class="string">&#x27;你的名字&#x27;</span></span><br><span class="line">git --global config user.email <span class="string">&#x27;你的邮箱&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="检查配置"><a href="#检查配置" class="headerlink" title="检查配置"></a>检查配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打印所有config</span></span><br><span class="line">git config --list</span><br><span class="line"><span class="comment"># 打印指定config</span></span><br><span class="line">git config user.name</span><br></pre></td></tr></table></figure>

<h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><h3 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" alt="image-20201029094138532"></p>
<h3 id="添加工作区文件到暂存区"><a href="#添加工作区文件到暂存区" class="headerlink" title="添加工作区文件到暂存区"></a>添加工作区文件到暂存区</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加单个文件</span></span><br><span class="line">git add 1.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加多个文件</span></span><br><span class="line">git add 2.txt 3.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加整个目录</span></span><br><span class="line">git add ./a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加多个目录</span></span><br><span class="line">git add ./b ./c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加所有文件</span></span><br><span class="line">git add .</span><br></pre></td></tr></table></figure>

<h3 id="创建版本"><a href="#创建版本" class="headerlink" title="创建版本"></a>创建版本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">&#x27;xxx&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上命令会直接添加本次提交的备注，一般用于改动不大的情况。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上命令会调用出默认的编辑器去编辑信息。</p>
</blockquote>
<h4 id="修改默认的编辑器"><a href="#修改默认的编辑器" class="headerlink" title="修改默认的编辑器"></a>修改默认的编辑器</h4><p>以vacode为例（Windows）。首先在命令行输入<code>code</code>，如果能正常出现vscode编辑器，那么直接输入以下命令即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config core.editor notepad</span><br></pre></td></tr></table></figure>

<p>如果不能出现vscode编辑器，那么将VSCode目录下的<code>bin</code>目录添加到环境变量，然后运行上面的命令即可。</p>
<blockquote>
<p>MAC及Linux环境下配置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加 vscode 编辑器 - mac</span></span><br><span class="line"><span class="comment"># 通过 vim 打开环境变量配置文件</span></span><br><span class="line">vim ~/.bash_profile</span><br><span class="line"><span class="comment"># 添加环境变量</span></span><br><span class="line"><span class="built_in">export</span> PATH=/Applications/Visual\ Studio\ Code.app/Contents/Resources/app/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="comment"># 保存退出</span></span><br><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br><span class="line"><span class="comment"># 测试：在终端中直接通过命令 code 调用 vscode</span></span><br><span class="line">git config --global core.editor <span class="string">&quot;code --wait&quot;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>

<h2 id="提交日志"><a href="#提交日志" class="headerlink" title="提交日志"></a>提交日志</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 完整格式</span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line">// 简要格式（单行）</span><br><span class="line">git <span class="built_in">log</span> --oneline</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" alt="image-20201029095951370"></p>
<p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" alt="image-20201029095957852"></p>
<h2 id="乱码"><a href="#乱码" class="headerlink" title="乱码"></a>乱码</h2><h3 id="git-status-显示乱码"><a href="#git-status-显示乱码" class="headerlink" title="git status 显示乱码"></a>git status 显示乱码</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global core.quotepath <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="终端乱码"><a href="#终端乱码" class="headerlink" title="终端乱码"></a>终端乱码</h3><p>菜单 -&gt; 设置 -&gt; 文本 -&gt; 本地 / 编码</p>
<p>或修改配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[gui]  </span><br><span class="line">    encoding = utf-8  </span><br><span class="line">    # 代码库统一使用utf-8  </span><br><span class="line">[i18n]  </span><br><span class="line">    commitencoding = utf-8  </span><br><span class="line">    # log编码</span><br><span class="line">[svn]  </span><br><span class="line">    pathnameencoding = utf-8  </span><br><span class="line">    # 支持中文路径</span><br><span class="line">[core]</span><br><span class="line">    quotepath = false </span><br><span class="line">    # status引用路径不再是八进制（反过来说就是允许显示中文了）</span><br></pre></td></tr></table></figure>

<h2 id="修复提交"><a href="#修复提交" class="headerlink" title="修复提交"></a>修复提交</h2><p>修复（替换上一次）提交，在不增加一个新的提交版本的情况下将新修改的代码追加到前一次的提交中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit --amend -m 提交</span><br></pre></td></tr></table></figure>

<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从 git 仓库与工作区中删除指定文件</span></span><br><span class="line">git rm 文件</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只删除 git 仓库中的文件</span></span><br><span class="line">git rm --cached 文件</span><br></pre></td></tr></table></figure>

<blockquote>
<p>rm 以后，需要 commit 这次操作，否则 rm 将保留在暂存区<code>git commit -m 修正</code></p>
</blockquote>
<h2 id="撤销重置"><a href="#撤销重置" class="headerlink" title="撤销重置"></a>撤销重置</h2><h3 id="从暂存区中撤销到工作区"><a href="#从暂存区中撤销到工作区" class="headerlink" title="从暂存区中撤销到工作区"></a>从暂存区中撤销到工作区</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 从暂存区中撤销一个指定文件</span><br><span class="line">git reset HEAD 文件名称</span><br><span class="line">// 从暂存区中撤销所有文件</span><br><span class="line">git reset HEAD .</span><br></pre></td></tr></table></figure>

<h3 id="该命令既可以用于回退版本"><a href="#该命令既可以用于回退版本" class="headerlink" title="该命令既可以用于回退版本"></a>该命令既可以用于回退版本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 回退到指定的 commitID 版本</span></span><br><span class="line">git reset --hard commitID</span><br></pre></td></tr></table></figure>

<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 比较 工作区和暂存区</span></span><br><span class="line">git diff 文件 </span><br><span class="line"><span class="comment"># 比较 暂存区和仓库</span></span><br><span class="line">git diff --cached [commitId] 文件</span><br><span class="line"><span class="comment"># 比较 工作区和仓库</span></span><br><span class="line">git diff commitId filename</span><br><span class="line"><span class="comment"># 比较 仓库不同版本</span></span><br><span class="line">git diff commitId1 commitId2</span><br></pre></td></tr></table></figure>

<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>我们的开发就像是游戏的任务，默认是在主线（master）上进行开发的。许多时候，还有各种支线任务，git 支持我们创建分支来进行项目开发</p>
<h3 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>

<h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch 分支名称</span><br></pre></td></tr></table></figure>

<h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout 分支名称</span><br><span class="line"><span class="comment"># 也可以使用 checkout -b 来新建分支</span></span><br><span class="line">git checkout -b 分支名称</span><br></pre></td></tr></table></figure>

<h3 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># B 合并到 A，需要切换到 A 分支</span></span><br><span class="line">git merge 被合并分支</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看已经合并的分支</span></span><br><span class="line">git branch --merged</span><br><span class="line"><span class="comment"># 查看未合并的分支</span></span><br><span class="line">git branch --no-merged</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" alt="image-20201029104640818"></p>
<blockquote>
<p>例如将pay分支的内容合并到master分支，那么先切换到master分支，然后运行<code>git merge pay</code>命令。</p>
</blockquote>
<h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果分支为未合并状态，则不允许删除</span></span><br><span class="line">git branch -d 分支名称</span><br><span class="line"><span class="comment"># 强制删除</span></span><br><span class="line">git branch -D 分支名称</span><br></pre></td></tr></table></figure>

<h2 id="合并记录"><a href="#合并记录" class="headerlink" title="合并记录"></a>合并记录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 合并 HEAD 前两个祖先记录</span></span><br><span class="line">git rebase -i HEAD~2</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>~</code>和<code>^</code>，前者表示纵向，后者表示横向。</p>
<p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" alt="1566209448773"></p>
</blockquote>
<h3 id="rebase-操作"><a href="#rebase-操作" class="headerlink" title="rebase 操作"></a>rebase 操作</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># p, pick = use commit =&gt; 使用</span></span><br><span class="line"><span class="comment"># r, reword = use commit, but edit the commit message =&gt; 使用，但重新编辑说明</span></span><br><span class="line"><span class="comment"># e, edit = use commit, but stop for amending =&gt; 使用</span></span><br><span class="line"><span class="comment"># s, squash = use commit, but meld into previous commit =&gt; 使用，但合并上一次</span></span><br><span class="line"><span class="comment"># f, fixup = like &quot;squash&quot;, but discard this commit&#x27;s log message =&gt; 就像 squash 那样，但会抛弃这个 Commit 的 Commit message</span></span><br><span class="line"><span class="comment"># x, exec = run command (the rest of the line) using shell =&gt; 执行脚本</span></span><br><span class="line"><span class="comment"># d, drop = remove commit =&gt; 移除</span></span><br><span class="line">git rebase -i HEAD~3</span><br><span class="line"><span class="comment"># 弹出编辑器，根据需要的进行修改，然后保存</span></span><br><span class="line"><span class="comment"># 如果为 r，s 则会再次弹出编辑器，修改新的 commit message，修改之后保存</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果出现一些问题，可以通过 <code>git rebase --edit-todo</code> 和 <code>git rebase --continue</code> 进行重新编辑保存</p>
</blockquote>
<p>关于合并记录的更多实例：<a href="https://www.antmoe.com/posts/5fe7c05a/index.html#commit">https://www.antmoe.com/posts/5fe7c05a/index.html#commit</a></p>
<h2 id="合并冲突"><a href="#合并冲突" class="headerlink" title="合并冲突"></a>合并冲突</h2><p>有的时候，不同的分支可能会对同一个文件内容和位置上进行操作，这样在合并的过程中就会产生冲突</p>
<ul>
<li>查看冲突文件</li>
<li>修复冲突内容</li>
<li>提交</li>
</ul>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>有的时候，我们希望给某一个特定的历史提交打上一些标签</p>
<h3 id="新建-tag"><a href="#新建-tag" class="headerlink" title="新建 tag"></a>新建 tag</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag -a v1.0.0 HEAD/commitId</span><br></pre></td></tr></table></figure>

<h3 id="查看-tag"><a href="#查看-tag" class="headerlink" title="查看 tag"></a>查看 tag</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure>

<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><h3 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;i@xiaokang.me&quot;</span></span><br></pre></td></tr></table></figure>

<p>生成的密钥默认在用户目录的<code>.ssh</code>文件下。</p>
<h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add 仓库别名 仓库地址</span><br></pre></td></tr></table></figure>

<h3 id="提交（同步远程）"><a href="#提交（同步远程）" class="headerlink" title="提交（同步远程）"></a>提交（同步远程）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br><span class="line"><span class="comment"># -u 简化后续操作</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>

<h3 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 提交到远程（分支）</span></span><br><span class="line">git push origin [本地分支名称]:[远程分支名称]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 远程先创建好分支然后拉取到本地</span></span><br><span class="line">git checkout -b [本地分支名称] origin/[远程分支名称]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取远程分支到本地</span></span><br><span class="line">git pull origin [远程分支名称]:[本地分支名称]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看远程仓库</span></span><br><span class="line">git remote show origin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看本地分支</span></span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看远程分支</span></span><br><span class="line">git branch -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有分支</span></span><br><span class="line">git branch -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除本地分支</span></span><br><span class="line">git branch -d [本地分支名称]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程分支</span></span><br><span class="line">git push origin --delete [远程分支名称]</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">git push origin :[远程分支名称]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置默认提交分支</span></span><br><span class="line">git branch --set-upstream-to=origin/[远程分支名称] [本地分支名称]</span><br></pre></td></tr></table></figure>

<h2 id="扩展：工作流-git-work-flow"><a href="#扩展：工作流-git-work-flow" class="headerlink" title="扩展：工作流 - git work flow"></a>扩展：工作流 - git work flow</h2>]]></content>
  </entry>
  <entry>
    <title>zshrc配置</title>
    <url>/2021/06/28/zshrc%E5%A4%87%E4%BB%BD/</url>
    <content><![CDATA[<h1 id="zshrc配置"><a href="#zshrc配置" class="headerlink" title="# zshrc配置"></a># zshrc配置</h1><h1 id="安装ohmyzsh"><a href="#安装ohmyzsh" class="headerlink" title="# 安装ohmyzsh"></a># 安装ohmyzsh</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL [**https://gitee.com/hubmirror/ohmyzsh/blob/master/oh-my-zsh.sh**](https://gitee.com/jklash1996/ohmyzsh/blob/master/oh-my-zsh.sh)</span>)&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="更换终端为zsh"><a href="#更换终端为zsh" class="headerlink" title="# 更换终端为zsh"></a># 更换终端为zsh</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure>

<h1 id="修复权限"><a href="#修复权限" class="headerlink" title="# 修复权限"></a># 修复权限</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">chmod 755 /usr/<span class="built_in">local</span>/share/zsh</span><br><span class="line">chmod 755 /usr/<span class="built_in">local</span>/share/zsh/site-functions</span><br></pre></td></tr></table></figure>

<h1 id="安装ohmyzsh插件"><a href="#安装ohmyzsh插件" class="headerlink" title="# 安装ohmyzsh插件"></a># 安装ohmyzsh插件</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew install  zsh-autosuggestions zsh-syntax-highlighting</span><br></pre></td></tr></table></figure>

<h1 id="设置zsh全局不读取任何-git-信息"><a href="#设置zsh全局不读取任何-git-信息" class="headerlink" title="# 设置zsh全局不读取任何 git 信息"></a># 设置zsh全局不读取任何 git 信息</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git config --global oh-my-zsh.hide-status 1</span><br></pre></td></tr></table></figure>

<h1 id="引用插件来源"><a href="#引用插件来源" class="headerlink" title="# 引用插件来源"></a># 引用插件来源</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tee &gt;&gt; ~/.zshrc &lt;&lt;<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line"><span class="comment"># ==================</span></span><br><span class="line"><span class="comment"># 引用插件来源</span></span><br><span class="line"><span class="comment"># ==================</span></span><br><span class="line"><span class="built_in">source</span> /usr/<span class="built_in">local</span>/share/zsh-autosuggestions/zsh-autosuggestions.zsh</span><br><span class="line"><span class="built_in">source</span> /usr/<span class="built_in">local</span>/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<h1 id="解决安装了autosuggestions插件复制粘贴出现很慢情况"><a href="#解决安装了autosuggestions插件复制粘贴出现很慢情况" class="headerlink" title="# 解决安装了autosuggestions插件复制粘贴出现很慢情况"></a># 解决安装了autosuggestions插件复制粘贴出现很慢情况</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tee &gt;&gt; ~/.zshrc &lt;&lt;<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line"><span class="comment"># ==================</span></span><br><span class="line"><span class="comment"># 解决安装了autosuggestions插件复制粘贴出现很慢情况</span></span><br><span class="line"><span class="comment"># ==================</span></span><br><span class="line"><span class="function"><span class="title">pasteinit</span></span>() &#123;</span><br><span class="line">OLD_SELF_INSERT=<span class="variable">$&#123;<span class="variable">$&#123;(s.:.)widgets[self-insert]&#125;</span>[2,3]&#125;</span></span><br><span class="line"> <span class="built_in">zle</span> -N self-insert url-quote-magic</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">pastefinish</span></span>() &#123;</span><br><span class="line"> <span class="built_in">zle</span> -N self-insert <span class="variable">$OLD_SELF_INSERT</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">zstyle</span> :bracketed-paste-magic paste-init pasteinit</span><br><span class="line"><span class="built_in">zstyle</span> :bracketed-paste-magic paste-finish pastefinish</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<h1 id="跳过不安全目录的验证-非必要"><a href="#跳过不安全目录的验证-非必要" class="headerlink" title="# 跳过不安全目录的验证-非必要"></a># 跳过不安全目录的验证-非必要</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tee &gt;&gt; ~/.zshrc &lt;&lt;<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line"><span class="comment"># ==================</span></span><br><span class="line"><span class="comment"># 跳过不安全目录的验证-非必要</span></span><br><span class="line"><span class="comment"># ==================</span></span><br><span class="line">ZSH_DISABLE_COMPFIX=<span class="string">&quot;true&quot;</span></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<h1 id="在“PATH”设置出错的情况下修正-非必要"><a href="#在“PATH”设置出错的情况下修正-非必要" class="headerlink" title="# 在“PATH”设置出错的情况下修正-非必要"></a># 在“PATH”设置出错的情况下修正-非必要</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat &gt;&gt; ~/.zshrc &lt;&lt; &#x27;EOF&#x27;</span></span><br><span class="line"><span class="comment"># export PATH=/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin</span></span><br><span class="line"><span class="comment"># EOF</span></span><br></pre></td></tr></table></figure>

<h1 id="不更新brew-非必要"><a href="#不更新brew-非必要" class="headerlink" title="# 不更新brew-非必要"></a># 不更新brew-非必要</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cat &gt;&gt; ~/.zshrc &lt;&lt; <span class="string">&#x27;EOF&#x27;</span></span><br><span class="line"><span class="comment"># ==================</span></span><br><span class="line"><span class="comment"># 不更新brew-非必要</span></span><br><span class="line"><span class="comment"># ==================</span></span><br><span class="line"><span class="built_in">export</span> HOMEBREW_NO_AUTO_UPDATE=<span class="literal">true</span></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<h1 id="如果高亮不生效-非必要"><a href="#如果高亮不生效-非必要" class="headerlink" title="# 如果高亮不生效-非必要"></a># 如果高亮不生效-非必要</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># export ZSH_HIGHLIGHT_HIGHLIGHTERS_DIR=/usr/local/share/zsh-syntax-highlighting/highlighters</span></span><br></pre></td></tr></table></figure>

<h1 id="使zsh配置生效"><a href="#使zsh配置生效" class="headerlink" title="# 使zsh配置生效"></a># 使zsh配置生效</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure>

<h1 id="备份zshrc"><a href="#备份zshrc" class="headerlink" title="# 备份zshrc"></a># 备份zshrc</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo cp “.bak ~/.zshrc ~/.zshrc.bak</span><br></pre></td></tr></table></figure>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
  </entry>
  <entry>
    <title>一些常用的 Emoji 符号（可直接复制）</title>
    <url>/2021/06/30/%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84-Emoji-%E7%AC%A6%E5%8F%B7%EF%BC%88%E5%8F%AF%E7%9B%B4%E6%8E%A5%E5%A4%8D%E5%88%B6%EF%BC%89/</url>
    <content><![CDATA[<h1 id="表情类"><a href="#表情类" class="headerlink" title="表情类"></a>表情类</h1><p>😀 😁 😂 🤣 😃 😄 😅 😆 😉 😊 😋 😎 😍 😘 😗 😙 😚 ☺️ 🙂 🤗 🤩 🤔 🤨 😐 😑 😶 🙄 😏 😣 😥 😮 🤐 😯 😪 😫 😴 😌 😛 😜 😝 🤤 😒 😓 😔 😕 🙃 🤑 😲 ☹️ 🙁 😖 😞 😟 😤 😢 😭 😦 😧 😨 😩 🤯 😬 😰 😱 😳 🤪 😵 😡 😠 🤬 😷 🤒 🤕 🤢 🤮 🤧 😇 🤠 🤡 🤥 🤫 🤭 🧐 🤓 😈 👿 👹 👺 💀 👻 👽 🤖 💩 😺 😸 😹 😻 😼 😽 🙀 😿 😾</p>
<hr>
<h1 id="手势类"><a href="#手势类" class="headerlink" title="手势类"></a>手势类</h1><p>🤲 👐 🙌 👏 🤝 👍 👎 👊 ✊ 🤛 🤜 🤞 ✌️ 🤟 🤘 👌 👈 👉 👆 👇 ☝️ ✋ 🤚 🖐 🖖 👋 🤙 💪🖕 ✍️ 🙏</p>
<hr>
<h1 id="人物"><a href="#人物" class="headerlink" title="人物"></a>人物</h1><p>👶 👧 🧒 👦 👩 🧑 👨 👵 🧓 👴 👲 👳‍♀️ 👳‍♂️ 🧕 🧔 👱‍♂️ 👱‍♀️<br>👮‍♀️ 👮‍♂️ 👷‍♀️ 👷‍♂️ 💂‍♀️ 💂‍♂️ 🕵️‍♀️ 🕵️‍♂️ 👩‍⚕️ 👨‍⚕️ 👩‍🌾 👨‍🌾 👩‍🍳 👨‍🍳 👩‍🎓 👨‍🎓 👩‍🎤 👨‍🎤 👩‍🏫 👨‍🏫 👩‍🏭 👨‍🏭 👩‍💻 👨‍💻 👩‍💼 👨‍💼 👩‍🔧 👨‍🔧 👩‍🔬 👨‍🔬 👩‍🎨 👨‍🎨 👩‍🚒 👨‍🚒 👩‍✈️ 👨‍✈️ 👩‍🚀 👨‍🚀 👩‍⚖️ 👨‍⚖️ 👰 🤵 👸 🤴 🤶 🎅 🧙‍♀️ 🧙‍♂️ 🧝‍♀️ 🧝‍♂️ 🧛‍♀️ 🧛‍♂️ 🧟‍♀️ 🧟‍♂️ 🧞‍♀️ 🧞‍♂️ 🧜‍♀️ 🧜‍♂️ 🧚‍♀️ 🧚‍♂️ 👼 🤰 🤱 🙇‍♀️ 🙇‍♂️ 💁‍♀️ 💁‍♂️ 🙅‍♀️ 🙅‍♂️ 🙆‍♀️ 🙆‍♂️ 🙋‍♀️ 🙋‍♂️ 🤦‍♀️ 🤦‍♂️ 🤷‍♀️ 🤷‍♂️ 🙎‍♀️ 🙎‍♂️ 🙍‍♀️ 🙍‍♂️ 💇‍♀️ 💇‍♂️ 💆‍♀️ 💆‍♂️ 🧖‍♀️ 🧖‍♂️ 💅 🤳 💃 🕺 👯‍♀️ 👯‍♂️ 🕴 🚶‍♀️ 🚶‍♂️ 🏃‍♀️ 🏃‍♂️ 👫 👭 👬 💑 👩‍❤️‍👩 👨‍❤️‍👨 💏 👩‍❤️‍💋‍👩 👨‍❤️‍💋‍👨 👪 👨‍👩‍👧 👨‍👩‍👧‍👦 👨‍👩‍👦‍👦 👨‍👩‍👧‍👧 👩‍👩‍👦 👩‍👩‍👧 👩‍👩‍👧‍👦 👩‍👩‍👦‍👦 👩‍👩‍👧‍👧 👨‍👨‍👦 👨‍👨‍👧 👨‍👨‍👧‍👦 👨‍👨‍👦‍👦 👨‍👨‍👧‍👧 👩‍👦 👩‍👧 👩‍👧‍👦 👩‍👦‍👦 👩‍👧‍👧 👨‍👦 👨‍👧 👨‍👧‍👦 👨‍👦‍👦 👨‍👧‍👧</p>
<hr>
<h1 id="动植物-自然"><a href="#动植物-自然" class="headerlink" title="动植物 自然"></a>动植物 自然</h1><p>🐶 🐱 🐭 🐹 🐰 🦊 🦝 🐻 🐼 🦘 🦡 🐨 🐯 🦁 🐮 🐷 🐽 🐸 🐵 🙈 🙉 🙊 🐒 🐔 🐧 🐦 🐤 🐣 🐥 🦆 🦢 🦅 🦉 🦚 🦜 🦇 🐺 🐗 🐴 🦄 🐝 🐛 🦋 🐌 🐚 🐞 🐜 🦗 🕷 🕸 🦂 🦟 🦠 🐢 🐍 🦎 🦖 🦕 🐙 🦑 🦐 🦀 🐡 🐠 🐟 🐬 🐳 🐋 🦈 🐊 🐅 🐆 🦓 🦍 🐘 🦏 🦛 🐪 🐫 🦙 🦒 🐃 🐂 🐄 🐎 🐖 🐏 🐑 🐐 🦌 🐕 🐩 🐈 🐓 🦃 🕊 🐇 🐁 🐀 🐿 🦔 🐾 🐉 🐲 🌵 🎄 🌲 🌳 🌴 🌱 🌿 ☘️ 🍀 🎍 🎋 🍃 🍂 🍁 🍄 🌾 💐 🌷 🌹 🥀 🌺 🌸 🌼 🌻 🌞 🌝 🌛 🌜 🌚 🌕 🌖 🌗 🌘 🌑 🌒 🌓 🌔 🌙 🌎 🌍 🌏 💫 ⭐️ 🌟 ✨ ⚡️ ☄️ 💥 🔥 🌪 🌈 ☀️ 🌤 ⛅️ 🌥 ☁️ 🌦 🌧 ⛈ 🌩 🌨 ❄️ ☃️ ⛄️ 🌬 💨 💧 💦 ☔️ ☂️ 🌊 🌫</p>
<h4 id="十二生肖"><a href="#十二生肖" class="headerlink" title="十二生肖"></a>十二生肖</h4><p>🐁🐂🐅🐇🐉🐍🐎🐐🐒🐓🐕🐖</p>
<hr>
<h3 id="水果-食物"><a href="#水果-食物" class="headerlink" title="水果 食物"></a>水果 食物</h3><p>🍏 🍎 🍐 🍊 🍋 🍌 🍉 🍇 🍓 🍈 🍒 🍑 🍍 🥭 🥥 🥝 🍅 🍆 🥑 🥦 🥒 🥬 🌶 🌽 🥕 🥔 🍠 🥐 🍞 🥖 🥨 🥯 🧀 🥚 🍳 🥞 🥓 🥩 🍗 🍖 🌭 🍔 🍟 🍕 🥪 🥙 🌮 🌯 🥗 🥘 🥫 🍝 🍜 🍲 🍛 🍣 🍱 🥟 🍤 🍙 🍚 🍘 🍥 🥮 🥠 🍢 🍡 🍧 🍨 🍦 🥧 🍰 🎂 🍮 🍭 🍬 🍫 🍿 🧂 🍩 🍪 🌰 🥜 🍯 🥛 🍼 ☕️ 🍵 🥤 🍶 🍺 🍻 🥂 🍷 🥃 🍸 🍹 🍾 🥄 🍴 🍽 🥣 🥡 🥢</p>
<hr>
<h1 id="运动-娱乐"><a href="#运动-娱乐" class="headerlink" title="运动 娱乐"></a>运动 娱乐</h1><p>⚽️ 🏀 🏈 ⚾️ 🥎 🏐 🏉 🎾 🥏 🎱 🏓 🏸 🥅 🏒 🏑 🥍 🏏 ⛳️ 🏹 🎣 🥊 🥋 🎽 ⛸ 🥌 🛷 🛹 🎿 ⛷ 🏂 🏋️‍♀️ 🏋🏻‍♀️ 🏋🏼‍♀️ 🏋🏽‍♀️ 🏋🏾‍♀️ 🏋🏿‍♀️ 🏋️‍♂️ 🏋🏻‍♂️ 🏋🏼‍♂️ 🏋🏽‍♂️ 🏋🏾‍♂️ 🏋🏿‍♂️ 🤼‍♀️ 🤼‍♂️ 🤸‍♀️ 🤸🏻‍♀️ 🤸🏼‍♀️ 🤸🏽‍♀️ 🤸🏾‍♀️ 🤸🏿‍♀️ 🤸‍♂️ 🤸🏻‍♂️ 🤸🏼‍♂️ 🤸🏽‍♂️ 🤸🏾‍♂️ 🤸🏿‍♂️ ⛹️‍♀️ ⛹🏻‍♀️ ⛹🏼‍♀️ ⛹🏽‍♀️ ⛹🏾‍♀️ ⛹🏿‍♀️ ⛹️‍♂️ ⛹🏻‍♂️ ⛹🏼‍♂️ ⛹🏽‍♂️ ⛹🏾‍♂️ ⛹🏿‍♂️ 🤺 🤾‍♀️ 🤾🏻‍♀️ 🤾🏼‍♀️ 🤾🏾‍♀️ 🤾🏾‍♀️ 🤾🏿‍♀️ 🤾‍♂️ 🤾🏻‍♂️ 🤾🏼‍♂️ 🤾🏽‍♂️ 🤾🏾‍♂️ 🤾🏿‍♂️ 🏌️‍♀️ 🏌🏻‍♀️ 🏌🏼‍♀️ 🏌🏽‍♀️ 🏌🏾‍♀️ 🏌🏿‍♀️ 🏌️‍♂️ 🏌🏻‍♂️ 🏌🏼‍♂️ 🏌🏽‍♂️ 🏌🏾‍♂️ 🏌🏿‍♂️ 🏇 🏇🏻 🏇🏼 🏇🏽 🏇🏾 🏇🏿 🧘‍♀️ 🧘🏻‍♀️ 🧘🏼‍♀️ 🧘🏽‍♀️ 🧘🏾‍♀️ 🧘🏿‍♀️ 🧘‍♂️ 🧘🏻‍♂️ 🧘🏼‍♂️ 🧘🏽‍♂️ 🧘🏾‍♂️ 🧘🏿‍♂️ 🏄‍♀️ 🏄🏻‍♀️ 🏄🏼‍♀️ 🏄🏽‍♀️ 🏄🏾‍♀️ 🏄🏿‍♀️ 🏄‍♂️ 🏄🏻‍♂️ 🏄🏼‍♂️ 🏄🏽‍♂️ 🏄🏾‍♂️ 🏄🏿‍♂️ 🏊‍♀️ 🏊🏻‍♀️ 🏊🏼‍♀️ 🏊🏽‍♀️ 🏊🏾‍♀️ 🏊🏿‍♀️ 🏊‍♂️ 🏊🏻‍♂️ 🏊🏼‍♂️ 🏊🏽‍♂️ 🏊🏾‍♂️ 🏊🏿‍♂️ 🤽‍♀️ 🤽🏻‍♀️ 🤽🏼‍♀️ 🤽🏽‍♀️ 🤽🏾‍♀️ 🤽🏿‍♀️ 🤽‍♂️ 🤽🏻‍♂️ 🤽🏼‍♂️ 🤽🏽‍♂️ 🤽🏾‍♂️ 🤽🏿‍♂️ 🚣‍♀️ 🚣🏻‍♀️ 🚣🏼‍♀️ 🚣🏽‍♀️ 🚣🏾‍♀️ 🚣🏿‍♀️ 🚣‍♂️ 🚣🏻‍♂️ 🚣🏼‍♂️ 🚣🏽‍♂️ 🚣🏾‍♂️ 🚣🏿‍♂️ 🧗‍♀️ 🧗🏻‍♀️ 🧗🏼‍♀️ 🧗🏽‍♀️ 🧗🏾‍♀️ 🧗🏿‍♀️ 🧗‍♂️ 🧗🏻‍♂️ 🧗🏼‍♂️ 🧗🏽‍♂️ 🧗🏾‍♂️ 🧗🏿‍♂️ 🚵‍♀️ 🚵🏻‍♀️ 🚵🏼‍♀️ 🚵🏽‍♀️ 🚵🏾‍♀️ 🚵🏿‍♀️ 🚵‍♂️ 🚵🏻‍♂️ 🚵🏼‍♂️ 🚵🏽‍♂️ 🚵🏾‍♂️ 🚵🏿‍♂️ 🚴‍♀️ 🚴🏻‍♀️ 🚴🏼‍♀️ 🚴🏽‍♀️ 🚴🏾‍♀️ 🚴🏿‍♀️ 🚴‍♂️ 🚴🏻‍♂️ 🚴🏼‍♂️ 🚴🏽‍♂️ 🚴🏾‍♂️ 🚴🏿‍♂️ 🏆 🥇 🥈 🥉 🏅 🎖 🏵 🎗 🎫 🎟 🎪 🤹‍♀️ 🤹🏻‍♀️ 🤹🏼‍♀️ 🤹🏽‍♀️ 🤹🏾‍♀️ 🤹🏿‍♀️ 🤹‍♂️ 🤹🏻‍♂️ 🤹🏼‍♂️ 🤹🏽‍♂️ 🤹🏾‍♂️ 🤹🏿‍♂️ 🎭 🎨 🎬 🎤 🎧 🎼 🎹 🥁 🎷 🎺 🎸 🎻 🎲 🧩 ♟ 🎯 🎳 🎮 🎰</p>
<hr>
<h1 id="交通-旅行"><a href="#交通-旅行" class="headerlink" title="交通 旅行"></a>交通 旅行</h1><p>🚗 🚕 🚙 🚌 🚎 🏎 🚓 🚑 🚒 🚐 🚚 🚛 🚜 🛴 🚲 🛵 🏍 🚨 🚔 🚍 🚘 🚖 🚡 🚠 🚟 🚃 🚋 🚞 🚝 🚄 🚅 🚈 🚂 🚆 🚇 🚊 🚉 ✈️ 🛫 🛬 🛩 💺 🛰 🚀 🛸 🚁 🛶 ⛵️ 🚤 🛥 🛳 ⛴ 🚢 ⚓️ ⛽️ 🚧 🚦 🚥 🚏 🗺 🗿 🗽 🗼 🏰 🏯 🏟 🎡 🎢 🎠 ⛲️ ⛱ 🏖 🏝 🏜 🌋 ⛰ 🏔 🗻 🏕 ⛺️ 🏠 🏡 🏘 🏚 🏗 🏭 🏢 🏬 🏣 🏤 🏥 🏦 🏨 🏪 🏫 🏩 💒 🏛 ⛪️ 🕌 🕍 🕋 ⛩ 🛤 🛣 🗾 🎑 🏞 🌅 🌄 🌠 🎇 🎆 🌇 🌆 🏙 🌃 🌌 🌉 🌁</p>
<hr>
<h3 id="物体"><a href="#物体" class="headerlink" title="物体"></a>物体</h3><p>⌚️ 📱 📲 💻 ⌨️ 🖥 🖨 🖱 🖲 🕹 🗜 💽 💾 💿 📀 📼 📷 📸 📹 🎥 📽 🎞 📞 ☎️ 📟 📠 📺 📻 🎙 🎚 🎛 ⏱ ⏲ ⏰ 🕰 ⌛️ ⏳ 📡 🔋 🔌 💡 🔦 🕯 🗑 🛢 💸 💵 💴 💶 💷 💰 💳 🧾 💎 ⚖️ 🔧 🔨 ⚒ 🛠 ⛏ 🔩 ⚙️ ⛓ 🔫 💣 🔪 🗡 ⚔️ 🛡 🚬 ⚰️ ⚱️ 🏺</p>
<hr>
<h3 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h3><p>❤️ 🧡 💛 💚 💙 💜 🖤 💔 ❣️ 💕 💞 💓 💗 💖 💘 💝 💟 ☮️ ✝️ ☪️ 🕉 ☸️ ✡️ 🔯 🕎 ☯️ ☦️ 🛐 ⛎ ♈️ ♉️ ♊️ ♋️ ♌️ ♍️ ♎️ ♏️ ♐️ ♑️ ♒️ ♓️ 🆔 ⚛️ 🉑 ☢️ ☣️ 📴 📳 🈶 🈚️ 🈸 🈺 🈷️ ✴️ 🆚 💮 🉐 ㊙️ ㊗️ 🈴 🈵 🈹 🈲 🅰️ 🅱️ 🆎 🆑 🅾️ 🆘 ❌ ⭕️ 🛑 ⛔️ 📛 🚫 💯 💢 ♨️ 🚷 🚯 🚳 🚱 🔞 📵 🚭 ❗️ ❕ ❓ ❔ ‼️ ⁉️ 🔅 🔆 〽️ ⚠️ 🚸 🔱 ⚜️ 🔰 ♻️ ✅ 🈯️ 💹 ❇️ ✳️ ❎ 🌐 💠 Ⓜ️ 🌀 💤 🏧 🚾 ♿️ 🅿️ 🈳 🈂️ 🛂 🛃 🛄 🛅 🚹 🚺 🚼 🚻 🚮 🎦 📶 🈁 🔣 ℹ️ 🔤 🔡 🔠 🆖 🆗 🆙 🆒 🆕 🆓 0️⃣ 1️⃣ 2️⃣ 3️⃣ 4️⃣ 5️⃣ 6️⃣ 7️⃣ 8️⃣ 9️⃣ 🔟 🔢 #️⃣ *️⃣ ⏏️ ▶️ ⏸ ⏯ ⏹ ⏺ ⏭ ⏮ ⏩ ⏪ ⏫ ⏬ ◀️ 🔼 🔽 ➡️ ⬅️ ⬆️ ⬇️ ↗️ ↘️ ↙️ ↖️ ↕️ ↔️ ↪️ ↩️ ⤴️ ⤵️ 🔀 🔁 🔂 🔄 🔃 🎵 🎶 ➕ ➖ ➗ ✖️ ♾ 💲 💱 ™️ ©️ ®️ 〰️ ➰ ➿ 🔚 🔙 🔛 🔝 🔜 ✔️ ☑️ 🔘 ⚪️ ⚫️ 🔴 🔵 🔺 🔻 🔸 🔹 🔶 🔷 🔳 🔲 ▪️ ▫️ ◾️ ◽️ ◼️ ◻️ ⬛️ ⬜️ 🔈 🔇 🔉 🔊 🔔 🔕 📣 📢 👁‍🗨 💬 💭 🗯 ♠️ ♣️ ♥️ ♦️ 🃏 🎴 🀄️ 🕐 🕑 🕒 🕓 🕔 🕕 🕖 🕗 🕘 🕙 🕚 🕛 🕜 🕝 🕞 🕟 🕠 🕡 🕢 🕣 🕤 🕥 🕦 🕧<br>⬆↗➡↘⬇↙⬅↖↕↔↩↪⤴⤵🔃🔄🔙🔚🔛🔜🔝</p>
]]></content>
  </entry>
  <entry>
    <title>个人简历</title>
    <url>/2020/06/30/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="8732d619e3dc50135d09cd02f66078cdda7caec434f8502b624292327deada0a">7acfc026a88986276697d298ab953b471b5a4dc836727d3b9e1f85c737bc4190ed1fd269ddebc70211d7d6b7bf728bf03cfd22b0e59faf7dd0f5c55872bd5eddd8029ee80a1e9f220e0dff3b4460abb8b15e0284adeef37222beb63bb311ab30ead22b14283971257f8168815084dd4d5a1d6e9a22ac546d7b253b19fdbc0f88fc0ffab5e9001ebbb53f1baf90cd0faffccc954528c8236b75674939e878d44e7af37cb82d79c6ba2995bb47c2de49f57aebbd435f177f238763bbb93affc563eacb3d457dedcf974ce63656208da583761a49d5a14411f6b644bd65a9866bf471bf20c6c4587dd2ee93f6a38961a7682c4d8808c4c58f0592f00ee9e867bb42a4f9e928bd59c36d8389b64ec2d9d8de22b7a810c37f443281cf4daac31fb3e8cfc4cb75c07346bc8ea2a21edbd512c8d4e1c606db17107d9f449f053bfae711388e0cae974b89e768e3ca523bd1a099228dc3d23566817af0587c2ea67d75938a9db784cc7e43564c3dbd55d1a598813d8a4ee955ca0b505da6f52e7bba6fa6d190d2307c17afac279f60d764e310f0018a82084fcefadc38f0faacf831315b9d6777d17a21538b888fa64cf3eeda5d93cf529649127904d71defcc6380f74fa170a1b0253a889875169fdbbac523ff91a0b0ace717781fb96e8c40bb7c8f78ea12f6302d81b887497bf8e46cee241e32240f700e53666ef54506a729c82067b218444f27865f71a29a1864197ad2911b50e47e4bd69b3d1e23b59ae8bf189c172cbc106d474afb7e796000d115738c0773c5a0251cb229c65606476905f2ebc28aa38241ab52fd8c0f7cc18f0d52e4c515d4251a7a5ee276fca786a661d6973c3927e733938f9700d8e18570d6d139777117c68dc0bc1588f7cf022ea5c2bc931122ad12a6292b5803c29f842d8e8362fb39573dca5a991757c2383ce72647663916fb2664505a272254a0ef68fe4846c6c257abdb379810cab80a0daf111b644d5ad674589839c14858e76fb7c2327586866d0e2fa521834819e372e877d3c529a07697bdec740c5244e5454e529073f89bd4a68c135196dff4c0f591410cd132b5e464257adf42d81c997e12a6d38083f9c3cbf3414c4cea6000036c61f129ca8ad44355d222ffe0e67f6e55faeee31ca76822dc97cd83f2945ddd637f09e92b2ecba4cad9450db506c6833ab714d49ecdff348f974632f2304e73b23df767be173cbca638193a05257425b6029f918b55570f9d299804010d5302696bac504935025c99d384cd91d7cd141efc4d5a456e16ea86d45effd5d7fc94554bfab8468779244f254f8de73c64f2c599e99d7dd92a54433ec9df73244dac9dfc3a4629edae88fe5b4fb4892a594c81abcafbd7f001959069fe682c21d75c8acb8bc10a215ed1e4a463ae09313ed29a10c6e1ca2c7b9ecf47a060b7e3bbf6d855c5c892332e1c5d74b1b44acb4a6b382afc252f58d009e9856108e657c0b34394d4c4416656b0876dc3b5f14a5ca04141d6a407dae868431031109e184513a48bb12e88f7e73fb5a9460f0e7cedd9d75c8004f07698f69981467b5cc3a20bfab42d4b63fb14f100932b201054b23125f353a8cb58f4a2b73713ea353f03fcf17c2751bcdbd1b34f353fba20ca88b1269a0d15ab03697e7b085ea8af34d73f6506d415289897bb418199c436e14f9458496a486842744604ccfcac992b628043386a862a8044adb94fda9d887c587951e4bfb675b87f58e9a01bf4b9dbda423d809adf3f971a48b45c10d405cb422a9a895b9038e5664683656efd4f6257de40b7ba50b794a1008afbb484f15429f27a7b4e094dcee41f945dd30378bbc1223e82ccc38a5ad41899a1562aa20d70ac9b9489d6b749b50bc7a54082dfeb67771c0aa113229e06df86647a11efbb6d2af1ca1b61398128ef17872faa3b130e2e282b01ffd965a4067268c80604985948adbb49d6491070953704efafdb2a0dfedde468714a12496ea3fd74988232147c391118542ff66ff2078dff635ee8c2fb8ee9114845cb2f86c6f4037a60511c13f320423b6125e38027a601d24c3301c7d4a66d24460940c7b3701a1c95970b0de446ae43e1762fbb9c09aec52c6ee6854510e80c9ffb8cf5c3c9c1c9e58887aadc9ab4c1575bdc457712677161cf9fca6ccfcae2d848de794c0546f7bb6e5077b09754111a0d33c8ae0d523b883d6ce6a11ce4c1e00fd3ee00433f20500f8628cd8740a0e1033f4197fe25004f9e565d5cedbc4dc8da8e07d330fa4bcc9563d373a31b89183619d1f114040d68052cab81fde69be3481a6a90e39b2a3430645cb78b8b3a6dd05feef581bb79e6715c3e9f9d83295e8ee5f2cb42cbf31262ae3af9a56974d18517c12407ec60dad8c302e2dc2ea9798262f7a960a9f83ce8d7f450bf3c197f0b07286b522748ff74c4ee7d6816ec47703171a53bdc3099f0270ce4f8bcb9d0a948a2ae4d2564ba1b4b462c285c9fea2d8516eac3879e47f5d7557bbf13fe4b83a34370330d93cbf3e7a2080011496e2c2acc048f2c5206e39466c4661de511f4e288f5fd488bb8e3f8ebcd83d355cd2f709a971933ca02ca2a523d447f5c208abe146910ca821fdf138929ebc6d98f756a1f046d3b1759ceed0ec111c1fb7722c6764f56597210588b474c700010d2c2063662822305523fd39ea97dddca4b24fbb807bc03a7a491336cdf70b0dd08ea58a63d8fadb9ef81b98661dca16ed01441a8d2c00ca6497350395a02f1d1459d3ac86056238a030d73214f93c151af0ade71dfdfc6b5247ac014356e8027530756c491acca006b655bb8257515025df392b306a27fea1b229ad8f5efd4636b052dc14e1f9d2ca098f778e05920be6a4a03e0677d24a35f584a9255c566902e967884d1cef860b7bce71c5a0686c375617672af2f32bbc0bd10468db213014f7812f8934082a9e6a2be42f28f21e55d648c5cf46b711ffcc5a68a667741dfeb0edf2e1aa9aef2b4be8b1559872700086cfbf5383ebb0663213cbf0cdf260048de51cdffa74f8ebe8cfb5b2b8b8f7e1cbe7c02bfbbe9b2d7949c6b608f2f113a75614c9f9e747b12ae9f2c51b9ae9bf94781479a41deb689595846f1da7522fb718e04175b52e96f6bc54f3c91713347ae34fa44f60ce45f67dc2006c0dfdfe64c4113e984979333c7465cc758bcb11bd2a7ab64d59f91b05cef5351d25b601026ec305acc77bc063e27e0dd848c827ec692d62ce3a506a52ed2dae6625e8e8d75d226b673d37e88a7be03500e2642c96715a36d00c5de2a438b531c0ecc6f257191f0667a294204ef158632892ac70fca2a6ef5bec8c6217eaef594d1ffe2f0e095b72e63fcbad9ffe18d87f847a7bb6a6d369a12d65b6b8bac28b602afe702485040c128af56bc0e5bd9c339fe5a774b09b9ee7ca1e74169cb0f4fcfa2bc83f4892a56c323a09e5ef826611e9aa8351a67a92ccf7d9b55876d5b617f17d286fe3e94863c4dd45ea6dda6eba5caaaa40e20c80805c74fc6ea7107b27ebaf36c4ffc6e1984ce1db654a5a827f0f2fbe6973dd99486e19393fc06d295fbdb4ee64e59deb3aa04a3d1c3f273848d6f733dd066f4adbe0e926ccba894f44c4ae93bcc2c4bf4754fc8ef9db7f34d4cb75baa99cccb50dda575c39d382197a32082b3def6e9ee0377dd0f5f1d4140958639d8bac4b153d035b1a63d853b87f205be6ef561fbcc2c966834031382aed37614440979328d4103406ede7bdd562418e011dfcff46b06a874950768928621eb486ba5fa8440914efe39885e09c2d0bfedfef6d30e3561b244c897f0da439747784670672786cdda6230767582c3390c7d069719ebf1b8b4ca3826ef61e7a935eeb98ef8392d4bf57c275812e479c5fad6ea575712f29b230fd1dab1a1d58b2f129b68d7eb9159ea58878ad1c745cba1f35a9d6be6bfc7d9e4dab1b9b5a091fdefc18eb806f00b490940c22d3af6f8415a758b94ff746d74cba73a3be6ecbd5999f432aca56b203bb2174a8d34969fa9c9201db6aac15a46884105a82724b4ed82db7e98391b55f4b5585ee8fdcbecbcf69e039cc1f85152b0cce6d4a7ceb1be4a1459be0bb0533f94fe13176fb5920bcce18b18f8983cb375c00dca70ee96e30f28dfb6cc6c65acb4be9c4fa24beedd2a85b3127459e96f816b0690f2dc777c3f5985c4ee0d9345d451cc3dcb11cbf6a08cb537a61e64cbd12b646e63d72e7073f1a8e3c0315308c7924b351de3e852f51bcfe1b53a08772583ba8a2457f296be89e2a7a921b301987ffcbf1c607f206ab3bb7aabd39f0298b1fce3b629683018a444c4f1b4fec1669249033fb9bbeac1e8ef715f45e392ae07af16ac0fd28e97f700e0a20233dcff2c1d1657731c1993c4dbf92d590c688aa1df226df5055d65f1f608504032fe7565846abd254bf486025eb7c4c3739383a6cb0e9a4e16122779ff9800ab2602de0fdd5ca67fdfca8ff1f492129b5d823ec8096f3cf91769b2fbc0264a545446865ab7b783f54ee746c4425f5e3c71640ab8ce6415e746046cdfb0d3f4e911e07daf9fb85c8d146711fe62c158a557930852f304031c9b60c0dbd39b2681e4ad247972549989054cfc83c90c1c29febde9a02b51a5e03f3785c74a05262865eb3958c14abae6cb6275fb772a2ec644e3b79228a40cb855695f5dd5ba3b30079d1bbd976c3a0f781ce9f73d0bf79beb532563bf68e160f41f887571f4f39c9a190989c5086a054060de6a6d0a3b9a305e1ca6520cd94f55a634d3064ff315d77d8bdc46c019987e6a5d8e69c45e867bc16505f293256939372fe505867ce8f059516f71aa6f146d8e4afcb17ef125660231fd3d71cedfd4c89db96e9556394e2c2276fa1d921bdeab788820b10f4b006d169dbad0ec0c8d3cde2c54b88d4f6087355f6e662e4981a2de4c48de420f01e7bfd5040d6c2cc0fe3afa4dbd25b3d17d2ac906afa86aeffff43edad96f08f0ea07eb222506106d248133abbe9b9e46fb7ba45600c4df04a72c8c6921478f1b69ec39d145d41e99a88539b88f12b905d513ca1568e762b9fae6d3a776c284392e7c53395366b6703141510679aefcb1da11e790b019088e6b32c7bfbde903329c64e358a55095f989a19642155d0af7b44289dc6b5be0d31257d1451aa4728f92c8a480a7dfde031267fbf1e60e44e80e96372da497071a4d1d01f648f79b88a2d6b3efda412d4491720dca49f548d41b9af3a2fba9819ff52d0c0a237f424a0a5b4afe8aa7711217fecc2499f52cb3c8afb0da1d8eea5f1934deda7aa4221c94970da12eb4430e5a9a9033e2e8726e6928e748e5978ceb321d08fcf8904342100e4f3b98fc4a4f670d92c28bd93fd6fbcab9aeb11d559393dc1c7661ba9570852974d34395a82fdb82f59f3290469607a4b5c02e0a9b76a40dfc4a72153d7966e42f0130bd3464e9de49749c881905d2f58f49bdb6c52e064fa0a025f513171fe554fd7b1239bdd83dc4d59016bb9bed5d8639ab9cb8cce1f0df9d6d1914e35fec85927b8eb133c52fa97e49f316d77c7b6cdb027bf8672c5935e8526de4afcfa3248d4e0d6fe5dcc060c20cab4a5b9ea57a943f9c990c9d8921efa205e0549601b72ca1453d048ef0565b015b3ec46611f55b7636510af565e04815405d9c49ea16bcde768837a68438a6c981ac8a3627b88685fbd9f3ea187987bf58b93a554302fa0b2f064c5f07dca6d11d1c9f679a579958b7d2bfa2893cc33eb4e2aedb1c0635729f258f9c56f5ee9f6132784729cdc8a03d8bc3837f1255df1f15b21d50c20e52b55a11be774dd2533759363119193a5073df214ea25a94f47e8f43050dae0acf93418c01a52488d4cacf51ca9250761a673d583e45a4eaee9acc39fa679c1b9a9cdb2032c88f01a7c05936190de8f4d309c2b083cff1adffc6fb5b665981c3f325f582c9aa965a260e779ffc0a2b25247a0a23ee3571b82b72bf6f6bab56bac0b1ec0d19ca5576edbb00b963982519827ee96d3581f673fda6d9283fc0fab86e69c0dd0e9eaea7d2e59e0b69e78488479283e966c4e9570978349cafb9920634c3f3eafaa8d14899971e4261ce9cb75247db8e6a98333e549b09964dbd32e5eeb5f995e470b6f82f2d43ce144f6769c5a4dbe4bc143174a18a358840598192150706f9ab3d4863c289d0d7f3d666e12d684e98cbf7ae69c08b43d5aa30f1a9185ee1ebac38105db55e37098d10a0c2bca031fa42c4881d918ef197a55576f1e036a878fcc8f297b9a99ce7d82d6853f21e378e61dfd9d38fcd91a730e8d4ca2b48f3f8c063a75a446a787e452e4f4524c8f1f0c5a758ea9afcb46bfc07eabe8a1d612a8d64946fa48bd75f5c033f963f2b6967c8894a54c57e92173199a069c3360ab63da3fe14659600986a3336629bd95d54a37004a9e2c8ca06a064b91845bb8263628cd8840a3a1b39045b7aa33ce2affff1fe468fa3fb4b3d6ee6ab93370add4735f44a18a2fc3e3d4da3ff9493b27bb42cffc844897382d239b17c5f9e683805382d3e49b99c6deedc3d4b6b00fc8e707f7cfe52346400e546e48bdd951891f091102cb7c73390e8b541ada94d8115c5efc12be4f3f8c961ac8e9abc0ed182f3c67993cd4ff43d251b2a93c31aeb5d7a285acf655a5e280ed2495ca224cd9427735f85feeed5ec943ad88c9dab98abec039969bae4bf836f6b6601b8b64ff376249bce8b4628adddea9dbbe4db71cad5793257dc8f147926e51305933e6a94196022527bbeb4b5c8f2bcc8c42e26da2eaad1ce142054e5a2d1b385114634632161b9815caa19f420869b9aee16daf8ac621a3f40e6361374197af2aa5c686044058b9ef15720087e3f8db0c65cc72f79e64f5f1fd13b6feba2641a74533e1238e7c75cd120b8e58370d76f9e94a67d3829c75298f85ea6f331d6ebbbdf5eb218538654d7e4e014d26d88a8f7c32151744a14659361c93de38a354e9593cffa163fd296023a19ea247ed1c37f95e509534c04fe3aab070d0d4f1aa5e934c8e16b72dc7330b984ef9073f96a87d64fd4fb1276b374448bc14f4a9d01584dacde78abda4f347bdbc5c5172e7de3ae95905eb6a3d5ca80680d081c723771b1f6f898fc45fbbbe556e344c64f629e8f57d6a8f1cdb888d2f1eb47aff5dc44fea858ff9286c639138530112a7e03aac333f68b966d5b0264f92849904e586a7dab29b52774fbafd649648630f4c8040e0d691485ee597d46f63e6b0ec79d205be990b8d00b90dffa135554240c1f46472a7ef8029d52eee2650aed1fb67eed865922cdfa48b9cd85e8bd41714e8f479b4e664d9e4a5de0b55e3813212d3b8862630ee740ae16fd94b726fa025951510c955fe89f8bed25efd224a900e8e923208c637c2d31a88c6c4a8c5120bd0b1a7b99b8e15152b3a65193145058a7f00ba799b0ae363e7ade75667edf359a02cd321bf65f028139e73fc151109f2fc957b1f80eff2cf061b4ebeabc3dd0576b177d7fe71f46429e1519858de13ec001ed5a0f9e3639087aa77450b1061b297ae7ffb7b46d2a06746e55cd32e9a928d9bf24351daf04f287762db3607f7a8c92ff686f8d32dee754c6b4ee3c34445948ba0402c44f5b22a2db3eb3baa5b66fb8d1e323657a1fe339959081a3937773785108bd573a146283459fbccb476e42cd762706f5fcd059f595feef7721bd69cf5a47c77645dd274476327ed2d920fc050ffd1d246ac23a9e341e5b9565796ffeefd66e58877393dd25874107833cd2f9f864cc921dfe8f02ca3b8698ed2252fcd70d63b74f83a18803ee807046da5058e0a98e1bb2fa3d782a8566e7e16b22c284fbb84597e0c7953db0b0c4b5f11db5e6465e8255b38545c60c65d93e514247e5eddd2822dd988017d3e66d616cf4aeba59b0558451772faa3a776e17394816ccbd578b598b554131e3573bbe6d2f326837e17e0e6bc317baea793f372ec9c9795003bf6a5f9a65c1fa92dbaad9ac24a83298ca12b62ecee1edef079d3452a3fb211313f59ef1470e1a630a3f4728a4b0d9177890606445bce792876e6ad9e6654085936ca3c3e391eedf249b11847e60967ae8038d947e19fc30b6d96bdced17c14be6067de1028e3641711c106ca862e20fdbf5c6bb92b202afec6ef788b3b8f2ad8d5f4cdbf739a45579623b45967ed27b0c4f42cb2b2ec98c28335107703a1b67e44c695d1d27188bf45ff2648887d58435de4e69f19c39e9bdf101f3eafe77557cce16a3196b46ed164ad7177bb018cafc7bd0837603416ad6b6454a58355c1134667ea7b87932576eba0b877d8dd69f97999eb84601452953ac3f270a33187268d9725729f44932116f08fdf36ca3ffb052c5e0e1a9277364279207f0b6ce0bbee7517962ad989194a5af028425a257e2542642537c92e75e128eb9e968f4786522e78cce54996972624fefe14ce04397f7ab53707d2014b86415f2ca58d801528ebdb4ed5bad42ff33cbc819e599ff70b5208c68ae26fd9635a7931b63c6493ef35f999ec0c09349433f71ce2f53784004657ffaad54d7e5a0841f2c9bebf210a951d2b8d1305e742bb36a581217ea6d8534635664e5eaf33e81c3d052558a14d6f328b4368368de723857ff412a2a9fc40655c5c63ad38a0db3e190831d0b56e49a48770a289284ad94a095a1123ae7f553545687083b99d05c7898cc07ae5f8798791f5ba1385fbe0749587e4d65e3bf952d03f270a4f46dae4a2d0a9c62aca6493f02201cf28b5d1ac1dbe2a13d5b5db534ac86689aef6e5ff379373e8fc65cf0da7be63af2075552e781c8cd8f9f1bf3543b3538d26f7ecc860ddf8beab851eda61780115512e37620712758fcb23224ad9d6f39eab2a26d659c315adbdd4f8924d02c6addc2cfb1061fb99313cab2dc7b7e485d5797443f7b9dc6fc40d81aa9485cb28eabe052c1595bb64b76d6963732e7ec984e7a6f695e94feab5e7872c129351e285e8b89e128f234de30e09d0956a7c77b51650bb6bcdc3bb97de54e47872c1d0e8be95fa595402db04566c8ce5397e8943b2c2599ef16d77818c998bbd4357b4128e3204d5334ccbcfa0c7f4d21b77b0f033567b6bdd57c28f76004e859785d637af0d10d622bcfc38c7c4da8795dd77a7acf48f81f57adb7c10c0b8e52b114fa2a4e07e6fb467b5c706bd5516cfb00fa12c29566483fd205a12622c2641cd59986ea124f6805478c9f15ab9382fc968f5b6da1fe06ffc9a29981fd3a1a04ee4c77ca4dea9c6befccf805c3057ff125f59969c4fa58aca953fbecf245c77a8003c7f3819baaa1a5f080095320a29526d8090fd614afb32db928d423dd5fb96dee6943bb07ca2f314fe9f418682458ea3d06b486b9a2b6324da277fb500a7e1e6a0620727ff33f383c7007e126a998826cf52c4038d946e2b36958a8622dd98db998b16b09a8459ac06f0f7c4c50703ed965c08fbe5c2e665c2f5e89679a0f74b26330a71818813d135ca3ae770dafcd104c2e7a231da834965c0402d4b9da998c26c83e617ef4edff8c7c5feaed8bb45891f71b9fb3818ce1c6da0d04c161955b853367848e1a91e3fdd5a1241c9e44013c13dde4a19412c250f0d45da9ab42ca1a50f345e16566c89502cfd8f7db892f3ad2734eeaf777eaa524a8a07402c424df8cace1ee84681cdd784e9d2c9329165fe568843b40514e4ff42e13f95843e44af095236dbdd1692c95d7523cdd869e8d7831fa9c13aedad1d1a431b317966dfd7b8cdee99d8d4f35dbe361383d479f0bfd7fd32cbcb8a39808c2419e3d4bb6039972d89ee7bc8a0992f93edb613f673a7729fb5801a54691f2ac902b5c3ec1dd78b81a7aa0ec20f3730c05388c5c9944b0f3a9947425db6a52f7a195d91f3420ee604ce32bef9126a1348df75f334f1d9cb95fb0a08a48a7c35e8ac6199c399448a45df6d5a31b82fd302d0cbbfb5d500bef72ff8fef1b160db490c4d33812d16cd5f35ad660595e2a6024f55d01cf2b79820bd04ca0b1d95256de52a5dcd146608f241503333cc7bec6fe00c6b50a7900faaeaf32c0629f0209d28dffecbc3fa75c5e0b6246058c6d4e4af17672650f7196ab3697556ea625c1634dcca4a83eee5e9f12c012df55f575723857f58ba6c85e7eaa255603a18eb6b269d556c9c341cd0d61f24dea5ca51ed4212e6c5a2560a6ab8105cc28775f36a11811e67b1235dd117ac1573043ca437fc7c9662a3f68c69c5df1378c5c0f1f1c867f1ec4e1add56f3de9baa69568ac0a48eba794e2f10ba2f4c35da2e2631e1d8115a9d31df05b967c940ca29795c9a297f071c65e86869249bdcb25b9ae626a185174339090b3853a153a196e5318f2ae39547caf673264ca49592da31cd2a39bc774e70576538ebf3951cfb97c24fdc34e3c54d4c76a786a4fff8e020223f4ffee2a62b70bf467c2e6e047e34f8e24b6281947a9f950ba395a2cabc7172e3977abeabb1c6bf0e66a7713f034d48a27c47471caadd549f959a99c2613f9c2d2d97781ffb1fa4a5e1d6f58af1bf5349c437422226c3065ce40802a5568675abb6b6412f12bc0950bdbc26364ff6294a04861f6bc6a5f675d3e392d92694edbe5228679b1ec93470c1a3c34ef50998b442b2c0aeae583ee018e7a28f794b6694bb3731d0bc35b868919f91b0f9173ee7ed2dabbe7f109734ef2df9fb03783af4ceb2e95e4c063101b8487e35fb484b73ec998128c36c88c910ff0cb8f7b05cdb7d71250af84a5ac473e78523423d21779fcb48ccfcf2ef6358ccf49c52b107a093edd1ff4ad4ca63444992cfea5e5edd07a9b8dd6da41bbffa983743306672f23614e1a06b80188e680947eb4d3cef77c85b6c7616c88ee8f84c88cb5420f743ae54c7b61d7f46c7c5098f43723fb0043443c8d69475d0c12d132ac955072af5bf9b2e7a5818de67ae516234ea2d56565e7a606d0ccaf8932c5612f0cf6a9b859aed982e0679ece365d3825147f1a73a49c928d66380c63f7b2506df493d28012f2161cbc0ce29e5e0bdc2a28da9d28b5108f110d4a1defb65973e9f14ffd396942737a891ae3f5ce3702b2479933a1a5bbd7ff305b7553ab61d590d7174174780efe7a90d14a1dc5b974f8664d2287634dc89119052c81732e5c32c68975dfaa8c7bf176df774833dbed65a6b9fdfb3d7e7103e30c3db634bc2e1e2c3c3698bab1247dc90815ab6a94188d14f2989439a49c2706053740a52871bb9027139e30abd28f4ecb8dfd8a7f70596482e1f3ec07b3a54101c97cba6b516125ee8789bd6cd2847d5e8e935bdf9fb339fe924e1490b424fbb7dec978a5bbddb8a8f2f1b64636e4682eafa896ff1bbc2163e7f82b64ddad3a11ba108428505552efadfd2b88cba04e738f62838b5256269a4b9783c1ea8455d160feaa1ce7b65ce53af88249b936f74a9a855dbced3e0547593a0db6dd878281808af30257c07a06e1a47c34d1931f7ecb3e6fe24301bf87575852b8f9cbdfc12045b4becaad862089e214856bc5051c3a157efad8cc7bc577b61b4d91e3b2ae0c2298c7277cfea6418430fc00dfbb1f59fad0a1f5f3462b09728fe12290e09b2e3398765da5692abd11c0f325589d69e93df785f38e8e9dfdef5648f4186dac3e895e95f251e0e6089cef51fe69f05da1da01fd3c8ef56f92d683772b66c72f5fcd754fdf9795d2f88a1b84020bbcd885fa4c9397f89a732e3ae953ca9da21ec791d9ebdb679ffd330f9575531858d7d03cf3f8434b566a3b2ded1fba185ae9f47606b0520bd81d4dec1a2e9d8a135e5adcd31bc260684162f8fc0b739eb3cd0b1666e21e6f8cffcceeadf142214b6d7c20ba2a08f6de12ebcccfeb54ef1b3654a39efcdb38fdf219d62c3cbd9755cb808fdd5dcf288a5091a1acce0d7cecb65607a2f52b0148adeca5c6b3434523b0466ce86532b331dcad7c15df80b3a20c2f90c85cb938ac75219aa898c626b1c3f12bba262402a565fcd6e819f88276b6495beb6fb52ac26c3e469a6d80faaede4b73221008c28c6743eba2a53cef5b4fa75b0c08c1a9e021617012f8303be96fc783427d43faf5e554df5e8b9f5c6607eacf2fccb3fffced324b3a1a50a09e250fdd5a379001d5f12a630e36ce0098e4840462ac61c37b3fa7eea26bc6f24440bfd59355fb157319d00d61c43c70d984486f6512413bc1290df04e15dfa5b6074d4c8834658428e8b234849405c209b8be180601e49871875be68893a1646b57d0f8adcd8b86c5625ea8e7bfe734698f1d898e9fada5903e3486e97f7e97715736b6339549e5dadc1f402f19ab2b970d86b011ee612a06b22d2e14a05b59facc6720f56d32f88ef1e03a1fc4d2d763a119eba784a66039359dfbe4e9f48f631c0abb6e5771c3a8f102291fcae8d1a1d97f2d897b2bc9ee33a4e9d18dc5fb6981793b279e86a4a8a0bc31f2478775184bdcd916844adcd53e465933dd2709cd9394706fda8b180807d8e769f461b56b6deda86e27427499c87a332639da18e1f103713472a0dec018d98730297afd9412a232b5a42ffa2059c3eab2056ddbc79c18204fc403ccbac577d5c4dc996980411832a4bf8fee05486945083b195107f4cef89215e6813c46b46cff3801ef1d49c155c05c433c9cdcfac14f69a09faaf219f6d965197a60ee110346244bacbbc651a3ac62867cda648b591ab4d48fbb369054e72315b77b6eabdadc59922ec5081390217a97b0d5f47ee903ba3702db4878d569c205d9262280f3daa1337cb13ca0a9987a0d61bbe3b848ba5781060d35f52c43eabf194c8d1e981da7976a5ba717f466527c7d3bf8c124630d4ec775a6f2cf91c4d4db9c0fc5e420496c23857909c4315028c899e1a671f628e8d1867179a3c3963681b95f791a4eb62accf7400158f4542fc4d60a1cde7c7f7199fc3dd3677b1d3c53622fdb8f243cc86efe88d44181f996d7930e0be0f9d6f40295aa337fa8d532a57c2b3740ed48bbf4e1c5f5646b257a2fb1f1bc430850a97f5e9b99c58dd5dfe0c3ba549d39ba2768e91e386bb1b9080330875fd7795d9fa719775102b32fc8d5bba137f3db1abe25c6aacfbdbd395f5f845879ac7fcd0144f675fd9ed37b9229c282b942d88f9d104c62b9eeb4c90076133ed25ed837a312cd6c697e3eb3b57063731507691e2525d5e00371179eb5e9b152c1433d19b774c09a73e6b151db402292099cf7054a913d8d89d0500e6dcd0cb377a13594f598e5cfaeee410e9c379badc2d25c7dad296ca86fd26b89e230ca72d4eb2f74f40760f761e8cc938c7b6b5b3181c6beb39c28a9da72c4804c76378d978b37a869cc7d040d6c12170f867fdb3f44608ecbc323c96541b5ad53f4cca6c95ed5b60d23b778af221667b17f84930530a9b691246b61b77359d665d6eaa82e78707fa4003fa77f7ec52b019a57fe05cfd44c501cc0fc387289ca6f667f6ccb69c1d758da2b66e12444f655a5ebd167055b1505dc900e11405e79b6709a1283a3e1b12fbfc9019d3783ee12f77c9a12f41834b3e52ca919ee68e83bf547aaffc62df8a0e13d0a795c8a446f1c9bcd0744a90b7f368914367c67477d1048d59d841c0b66e27e3cb8d5aef509b0c167bdd98c3ffb350519100a8f29dfef415602d67d27391c7391ae6eea5c2e7da12ec0473905b0de69e5c5a5f1ffee3d519478cd1898e908bb9edcbcb7345fcd27c3376e932eb2577341b146a642bff33ed17a70f46ad5706d6eaa93249f04305048b9b149e99a5e4211e18d0e59c30058cb6528a259a67874f6e87c469e8e6e86420fc24c692503a553a8a7052c80088be0cf553dbaae9d47eb90d62f44581c8278403123d887e6fc3b9d06b388c8e1e478bf4198442d32a27eaf0787958e214d2248e1439e084109971435e0b9ef22123f32b01b4cc9edc7ef4ab49b9c679dbd9640f2f4d3e60bac774c1a9bdfc8670f2f19f32d379263a7b5a5e1d3599eea3dc5cca479305ea017831b1ba0329f2402c96424a720935fef1dc13e38a9237acce6f2526935c9c83df0f5be81c4dd281914fea332408267984555a4db437b3f1a89475c36f1ba0ccac753ecacba04d86f3b22ba55f785e0a614d9266ea0a7239e19cb0859ced313b0d78c6445b3825909911fffb1ed33c32bdb2fe40fc465f2d7e56dba1c9ed9656529bab5c03a935ab2dd386e1989ad583bc792fdfb635ca02f4cf4b2b1de30697b4ad3ee4e46bbc88926a1f3fd1df6e24455cd28a63f42763921bbe41fe678507bf180685d5d61e33b523b1a0a5f8366cbaf8b64c4456a1c13c4976f0d8977f3630dac506b195db3ee5babfbb3d63cbeeb0990233b2c10117a1f829344386dae6e2b6f7bfeab2fdb5977fa3a0a8db024ef87101736f06b0058af62dc516c6312f004c9a879d2efa30a065134c30a58adbc722a6a5e9c88fd1d822d3531c625f68b658d17a5fbea9dbd372ba1a4282353efff6b3c3a08b18d63bf081bb9df7ae2749edd9213c9ea1eff262575cd6c57b54076bc378eb62cb4457f95772d9dc896e7807275b67150e7d1f56f5ffa186b592e5fbca3364e30dad35ef7ea4595f1b9ac488585b002ae43d978358d421257a2dd90170af57901bb868c7685be131dc1bb446cbd50a1008bdbff89ba20e126c3c71d48eca5f98c1a2600b5cb8472fb6467cc90979e8f6b4f9b240ff7ffebbebee9100d9a25310d49fb28431f5f6b9b3738fc6f3d44740cf4a443b5f016051ad75b9c89cfa7bffe02b868c5bc228a8064ac0686b8fb285bc218e66ab1a5a05d4606b9606f71659e9fc71af1710406d8af713e518eabec90d8f552250096f76ed36f93fd666ab297fba7bc99f25699f66ce2137dd086e65ac01a412e021264e7f8261db5e7e97d8f2093b701f82df99ba97be092d4f7dc92fb9be0cd5294d8fb90cea554289848863f54656205de0f92944e0f2b2b286475dcc089000a34753080e599ebfd7cdb143d6c668ac4a051b416bd8eb57190454036169bcbf8fb8efa2bddef7a5cbe15f147643cb132de79b69e912e94b8e162b25e221820f6fccf09d8125efc49585a2a9ee0546d61ba549719cc3bd3e361c3372d0981dc3ae6088df243aa727ab1c2c83f477371e51f60a33e8a58d7d5185df26a6cda9e750476c9567080a9051d7ba285452547191eaf02af546adac35c93d6ed73c0a4c61eca88f9b931d08c8f13f8566e9575a4bc1c38aa3a58edd3e989027fc3f09f9517ac1a79b4f1f921cc4d01dd479ca7c51e02bfd5dfc05c107655ed3045618adae9355a44abfdc0d41bf57245b07f48c96178445eb3fd6ce4d59074129f9cfcac159624ed57263ef0302ac7d64cbe5634268014f56f85c132399caa9071fcb40c353d65b27ccf52bf1b82a1bd72387912cc50fd31c206f865c1eab2e715d61b8a269c617ac919f7c3a0e9ec80ec103274fe6885e1f524e7990791ce54c21a7f0650af1fe40708a1574e617895e074ca2e61a001fe42ccfdc21983f4583bf885f4d198f7a6f8953ddcac3de476192795cd3e80b4fbc2724bc4af7360b5a25a175b3bcbca3fa13b4f6dc10730e20a0a8c20a8ed6614e7b68c0541c42db212d942c732d05409e7c3171bc00d96585cf4bc78844c4dcdf8cf910d862b3204458f56151e6dbbbe79c0df3298b785a6ec7635cd2f449720e4a07ac52ed9d283a4479f38c891cf6c9a63d3af46a3b7f556c527251fbeb184cd0fef79a61bf7fa21bc5e946d5a685c7da31ef5e4dc1c3a782c8ab9f06f9269b83f36c350b9d28346abc21104e8f5ee9d5b9c08c091ef4862791b83ba4c9210bbf69924e8a71e4ce3fb214fa232c82dc2462e6310354386056f73be47e08f10e17bf6aa6ff04a1d94191106cd57e2a0be0e67e9f68937d85532f483d7de506da859e5aa33b00207cc32895e41fa12de16bd275139f669622be775966d60b7d35cd0e28bee58586c43470e9b21710613a00d14d17076504918414e8ae811702eeadbfbb1294c7244d7b9292f1ec07ff2ba162188e396a15d3c4956e8bc745b1ce2f59c19203d93c5c2994822888d0035a8bb6f5362bb7813b989bc30d8f0b8226b0d64765ecd7698fff37f66fe824e3279e46ed79f36301d16e46d1023c9e3535830ba63f7f2ecaddd45a97673d6639db6530af5a32a00b0defca9200ae92783e224116d7f6826c979fc767a51d6ffc3827b45fbce8b9dd0f112da5bf21592563013827442c900eef818d9a9d4a548142945717b14646db9af3c05c691de81d407a782bc0e55a72f0f31f998a354b2115a28f4831b91f5b8625909789e584b90911c19c1cc50ea0d86c5338b85ffb0423c83f07cbf3a94c56bb68474ee3bfceb75bc4f49fb49493c3cef9bdc744850b0d839e5ceff8af0b2dd8daeac14b9a7a1ccae3bb48f952a1254737dde25b7eb4fc9fb2b890eb071027ee04cefd4feb1f857dadb951bee0a0ce1e0945de21bc0072541c42ba6c7bf100009e301ab1d28a45725cfcca8a5ef5349ac243de1907e1d4f52e4b448beec05441bab85bcdf750f49fff0ae56341e105e68f2d375e61b7fa41fbe5f2d2954aeb1d3197c68366a6ebb5dc8f5aee12c7d6fd49495cbab67bcab5a12e777c9dc9a76996e97681a11127823f4a6b11d8557daba9fda8e60324954a163c228fc5be049bfa1b5fc7022295b26ebd4f9c7c1a289c74aad4ce357a9ca3aa62fd6e11858db3f98fbb54a2a8551e487f470daf8d2060e4a29568492d328c834ead059996271477533403c313c8bcb56a79a79fb7045e210988ba4fc5ad3110896cef8c9a751fe2231aac3c3c1497b8adf67f3c2bb345d9af0baee9102c76121a66df720cf67a0476fc7f4a7896cafdd2f7d43ad67c5ef501440001aa5784f800c94edc576b0b29a10ad7eac02563586d38b832ab789bc0069b47494b1f298cb20c4b2592ce254e98ff170d527f9009d82f3e3ed047f3103f7a64e3784bc8adc89f6959f962a57b090b64801cfef41a57e5d7fbdd4cd6320740c9556f4de8b21c121edb6d68cddcd357a722471fa799e790170e16a99f3dcaa72e0d361f18b303bde8fa9c6e893bc064f0ca6d7d53527d1896d92627cf8194b7010cbfc4737b5e812f87a21b38301846e3a113c8f2c2e8d4706a8f09696c3679b4886d52152a724bdba27b0bd7864c447d44248aa0e55f2c5a7f3ffe039ac791f74c09e9c79f4330b20c0165c37a435a9ce787b699917f8ba1dc1e27ab9d55de09ff721db31844b0794f545da053c262f14ad8e48164b2288fa80035252b39635373d60e7276b029c007602435d925a8616ecf62121048bae28e820adacd1198ded5201fe111fb4284591ac83ae740ae6dcfa1026e64f9c66f41403e57670968c10c38d821431a4806971e255ab8494ce530e83245b852e63876ffd15fdfa20607b0cb5aee762a0ec06632c5c44583cce5c41789d659b729c3223b9453a81d4f8b3becaf9cf382037d147bcfbcb2d474079b4cb8a7a337d4e8f57ad40dd14379c64dc8f8ea3bad9f023531f1de0f72f4145a654f138759ce7b520b83c9789d6f895601c3bcca2206b86689b7816ec421ff4f9e6f27edd2946faa32cb4c17c35e184ab49fc93819871b5ece580324dfc7199731931bf0b9f983cb792a22f6b61da73244c9cc6d5e23b890f91363cd1673204461d0b5df804e7383688f63565560faeae35413832f14fb1247ba7d7c063d747b886151a8670e8c70c63a71a32d38cb47dc0f7b55298542cbcf351fdf30156e9543e55a51ec0faa5ab6c358c1acbbc044b119d6c7b4a17d45ab87a4f9e837fc8ff078ff7940daa859a62b689797480fd728eedf559ffdfc19b112cd6a6508d9318dc1094c890902554c302dfed359e1d89eeeae48f2794bfd19c3469aada1e82900567d0e631db986f44e31d0b68d851de3929bd9b8ae840f3c1cc31a11d24c19e606ecf9eb235887dbe2c6258c24831e58f26425827ea7212e760e52acad96765d023e404f37ea4f9ec89117f8ed3f4734c22287da59e953c6334bb5b6f57118ee336dacd6849365ce5dbf72ffc9af55d3395dd309fdb95522de18badc9f5be2f5f541e212cb4ecd3c355a8782e906482e91beb76082f49299e4bbd316c4403c7e36fe4c0d47afd32e576189b9bc4d52f5fa533c2419791c472a5e2002b2e10fcf5640e8211bf014d5233a05eab2453fd36c6c65f3aa785c5f3955423f9b5acbba202d0a672ab372aa9f8da077cbf9707f4dde07c197441a97b9132d782ebd93778c24a7c8ade70c4be9ec6baf01c943da60f2d26aa84562bce49de7a69c2955d41356c7b09d85ea4150e436d6e49b67aa65972de25258664dbb47a3dedddb2b59fce4ce678b8322a7f4c6ee4d74e6ae61a6644a65b4fb21a2352492bfed9c6facf711b1d9e2cdddd45cbe8c3080318a9dce942f1784ba5f1918ee4b4fd7e8b1b94917370c2a5c82c0ced2a586e25a4bc3bf2a4b2b6916d8ac62ac3a7b679e2f184d0bf0a05ef3e2cefa4e74c148bb9af5556c1d510319fffccfd8cc40623abbe2bef4c6e0bb39e3c3788916535ce5d82cdae02c696466ac2e1104ca4d8499acfc64c6050ed049c6950f441cbb4ffcd734a8d118e1d62d2099b08d9e619978efef8d79e8e689339193dd7e83f4ad770882b0cfc7c026371dc8fd301958b03a531b01087526ca1f9e80f988df2678723596fb54fca7b9137c626ec8a310997d74d2fb19c86d7314e60ed38e574c3daf381fca314e3ae649ba971ad9a9788639a1bef1b2544936e6260c7cf87cd1317159b4d0a45a1615b6b5d699360a002894b80d4fe4a2e2b38d4c41c02dca4fe6be2d6e43fc3a248a617d4bf0f1c51dc8d7a7c29fd6842b2b0ff640e2a7fcc9d9921f97407610a9b5ba08bf1d3d660b91924fcfcb9bd4c93135c19c71678820bd5a7f75ff557c1428d1df05c8daadf4cd3b275609c46a15c3cb57e3a88edd087d5d6706886de5e5da3f861fc458dafa8271ce87665e868006c01fe54f6c0ecd18391932b1d29a7f2aadc6ec715e60ab52fbd627bead995a0b6e098c7154f7e913913726abcae1663ef43649e9458653d4e387bc59b0bc0b46eb93460d09db7c85d313a9c6c08b0a6bd8c471401d8c5bc2f21940c025de0faca06133583a992896970a358fec9b602cd6dede0a04d0d38ff7863187478ea33977adfff7c7fb2b4d8bfa53b28468d076de5ae52f2608e2a0168c38a9ce68c3c2459cbd11e08b322b85dc81a2b2128def16509fa69dd1d0c5a3f888f5423acb3b7cc59fd5442a7904dddb9bec722a7edd34302f72d5c2dd7eef00e54519f34a5461b989c38c936b9c48c5886fa462a90d62eefbe6ad4a49c6772a23babff3412d3c8fb6be3e20c5c17f06858d81dbf5ce05c7a913f90da1af4e4e676bee2bce7a4067cbc1e579a6300d2ca462d905968c3cdf87d5a3cd71f0f4bde8ce5f4800d746e986f7a9c30864502f4a60cad14165f2a7beead655144b3a814520356f4a4e60f44495b4636b6da76666c70b444820358ea9739726d80aa9fa1ff77b9e5dd528956357768d0170b06b895a81fde87882f754396aec8404176e2d0e3cedb2aae19d35d9c214634721e62a2f3088eb3f0bbc5f925ef5c51531386fde156d4c4ff7c1a4ce4da78eec69800c1c464964d073e69a514620d182ebce4dcdfb9a962296ebc3c527eb50de7b641704552ea07967b2448de60a2de173be2ac2751526da4e0e2bc563b6ac77fdb3458b3ad552a79c9e2d5cffd7ff3e3efb3025db8a649e04b6ed42f0d0cfb7aabfb73c79806cbee0cef122243b4011dabb5efca93f89105b08b179975c977ef30c8a680c431af88a03b81936f2dc33fa1a26bf6dcd663d3b4ceb84d730d0930232718241f848fdf1baef4a9ffbef1add4356fc3d61c4d88083b45782b597c1460b6bb15912585de9c619bcaca31cde0ef1a2f2d8b1db65cb2d64602e7f33de977836c193ab7d849fd07758351f8f821b7a4dfcaf3b87598207a39b8ec0128c7cfa521dd66020e241ca1d342daafc26e896d8fc7cfb4915eb6f664b41c62811d3cad23bedea2fbd6e9e438b984ac3353d77d5a17fa7463f4d0673ae9617a2548c6d7482bb502bc2dc2e0b56b8c49d88209269d34d1afc1c0e40cb1bee4c34bda48fe3b24c7921c01cd1fea7dea6cd89965b8115a8648b066abbe3f826596796af4c6fe8932cdc5e774d4227831c2be329d89912ce9d54e273bc4dc07bccda2966537ebea58b20ad0909911cc1e4763d591233bd22cde31f9e280b2d2a26de988d9ce7e68b59059433c73764b60a3e45e0785db7e22fb9e13f1961f5ed5c39be18b2d8291550a7b7e0d26db20552e7f987ce20e735b60377c49cee2ea63fb0028423562ac62fc75619a76c4ff6bce8893e9f815eb065140b08f2f8701385a620191a89987295d70f8b90534bde3f0eda0</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>镂空文字内嵌入多个视频，自媒体视频片头制作，pr快速上手</title>
    <url>/2021/06/29/%E9%95%82%E7%A9%BA%E6%96%87%E5%AD%97%E5%86%85%E5%B5%8C%E5%85%A5%E5%A4%9A%E4%B8%AA%E8%A7%86%E9%A2%91%EF%BC%8C%E8%87%AA%E5%AA%92%E4%BD%93%E8%A7%86%E9%A2%91%E7%89%87%E5%A4%B4%E5%88%B6%E4%BD%9C%EF%BC%8Cpr%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</url>
    <content><![CDATA[<p>1、在项目面板空白处，新建项目-黑场视频</p>
<p><img src="https://pic2.zhimg.com/v2-a11e274c61eaf4aee2511329b0ae2f81_r.jpg" alt="img"></p>
<p>2、拖至所有视频轨道的最上面</p>
<p><img src="https://pic1.zhimg.com/v2-909f973f76f7115aca70cdca3ec61758_r.jpg" alt="img"></p>
<p>3.字幕-新建字幕-默认静态字幕（输出文字，字体选粗点）</p>
<p>拖至所有视频轨道的最上面</p>
<p><img src="https://pic4.zhimg.com/v2-81b0db052ee068b77b29c45924d75a23_r.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/v2-56f6888f4604d7207c26b2cb70290111_r.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/v2-254f0a1f537dacd80284de8649123604_r.jpg" alt="img"></p>
<p>4、效果面板里输入-轨道遮罩键-拖至黑场视频</p>
<p>（效果控件也同时出现-轨道遮罩键）</p>
<p><img src="https://pic4.zhimg.com/v2-9ef94a47ba11d42eb6b40aacbd0bec7f_r.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/v2-a8d3f19148bcc6f7179641c5d965df9b_r.jpg" alt="img"></p>
<p>5、轨道遮罩键-遮罩-选择视频5（也就是我们刚才输入的文字层）</p>
<p>反向打勾</p>
<p><img src="https://pic3.zhimg.com/v2-1b022379716d4c8d96e21ff405acc6ba_r.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/v2-104c3576ee56c4b82275ab40df181c44_r.jpg" alt="img"></p>
<p>6、两侧多出来的视频使用效果-裁剪</p>
<p><img src="https://pic1.zhimg.com/v2-f3b5b074405ed25eb1ba105fe67f7938_r.jpg" alt="img"></p>
]]></content>
  </entry>
  <entry>
    <title>Mware注册码</title>
    <url>/2020/07/30/blog_markdown/#%20VMware%E6%B3%A8%E5%86%8C%E7%A0%81/</url>
    <content><![CDATA[<h1 id="VMware注册码"><a href="#VMware注册码" class="headerlink" title="VMware注册码"></a>VMware注册码</h1><p>ZF3R0-FHED2-M80TY-8QYGC-NPKYF<br>YF390-0HF8P-M81RQ-2DXQE-M2UT6<br>ZF71R-DMX85-08DQY-8YMNC-PPHV8</p>
]]></content>
      <categories>
        <category>Mware注册码</category>
      </categories>
      <tags>
        <tag>Mware注册码</tag>
      </tags>
  </entry>
  <entry>
    <title>Arch安装手册</title>
    <url>/2020/07/30/blog_markdown/Arch/</url>
    <content><![CDATA[<h1 id="Arch"><a href="#Arch" class="headerlink" title="Arch"></a>Arch</h1><h2 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h2><h1 id="笔记本连网"><a href="#笔记本连网" class="headerlink" title="笔记本连网"></a>笔记本连网</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iwctl</span><br><span class="line">[iwd]# device list //列出所有的网络设备</span><br><span class="line">[iwd]# station wlan0 get-networks //过去可以使用的wifi wlan0 是我的无线网卡，不同设备名称可能不同</span><br><span class="line">[iwd]# static  wlan0 connct SSID//SSID 为wifi名称</span><br><span class="line">//输入密码之后，链接成功</span><br><span class="line">quit</span><br></pre></td></tr></table></figure>

<h1 id="解决不能连ssh"><a href="#解决不能连ssh" class="headerlink" title="解决不能连ssh"></a>解决不能连ssh</h1><p>ss -lnt #查看ip信息</p>
<p>rm -rf ~/.ssh/known_hosts </p>
<p>更新系统时钟<br>使用timedatectl确保系统时钟准确：</p>
<p># timedatectl set-ntp true</p>
<p>fdisk /dev/sda<br>mkfs.fat -F32 /dev/sda1<br>mkfs.ext4 /dev/sda2<br>mount /dev/sda2 /mnt<br>mkdir -p /mnt/boot/efi<br>mount /dev/sda1 /mnt/boot/efi<br>挂载好分区以后执行</p>
<p>kde桌面环境脚本：<br>curl -O <a href="https://gitee.com/zhaocaiall/ArchInstall/raw/master/kde.sh">https://gitee.com/zhaocaiall/ArchInstall/raw/master/kde.sh</a></p>
<p>sh ./kde.sh</p>
<p>gnome桌面环境脚本：<br>curl -O <a href="https://gitee.com/zhaocaiall/ArchInstall/raw/master/gnome.sh">https://gitee.com/zhaocaiall/ArchInstall/raw/master/gnome.sh</a></p>
<p>sh ./gnome.sh</p>
<p>deepin桌面环境脚本：<br>curl -O <a href="https://gitee.com/zhaocaiall/ArchInstall/raw/master/deepin.sh">https://gitee.com/zhaocaiall/ArchInstall/raw/master/deepin.sh</a></p>
<p>sh ./deepin.sh</p>
<h1 id="解压下载的安装脚本（解压命令起提醒作用）"><a href="#解压下载的安装脚本（解压命令起提醒作用）" class="headerlink" title="解压下载的安装脚本（解压命令起提醒作用）"></a>解压下载的安装脚本（解压命令起提醒作用）</h1><p>tar -zxvf master.tar.gz</p>
<h1 id="修复sh文件错误（非必要）"><a href="#修复sh文件错误（非必要）" class="headerlink" title="修复sh文件错误（非必要）"></a>修复sh文件错误（非必要）</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;s/\r//g&#x27; arch-linux-installer.sh</span><br></pre></td></tr></table></figure>

<h1 id="更换镜像（非必要）"><a href="#更换镜像（非必要）" class="headerlink" title="更换镜像（非必要）"></a>更换镜像（非必要）</h1><p> reflector -c China -a 5 –sort rate –save /etc/pacman.d/mirrorlist </p>
<h1 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h1><p>#先cfdisk手动分区</p>
<p>mkfs.fat /dev/sd1<br>mkfs.ext4 /dev/sda2</p>
<p>mount /dev/sda2 /mnt    #sda2根目录所在分区</p>
<p>mkdir /mnt/boot</p>
<p>mkdir /mnt/boot/efi</p>
<p>mount /dev/sda1 /mnt/boot/efi     #sda1引导分区</p>
<h1 id="桌面环境安装脚本"><a href="#桌面环境安装脚本" class="headerlink" title="桌面环境安装脚本"></a>桌面环境安装脚本</h1><p>kde桌面环境脚本： curl -O <a href="https://gitee.com/zhaocaiall/ArchInstall/raw/master/kde.sh">https://gitee.com/zhaocaiall/ArchInstall/raw/master/kde.sh</a> </p>
<p>gnome桌面环境脚本： curl -O <a href="https://gitee.com/zhaocaiall/ArchInstall/raw/master/gnome.sh">https://gitee.com/zhaocaiall/ArchInstall/raw/master/gnome.sh</a> </p>
<p>deepin桌面环境脚本： curl -O <a href="https://gitee.com/zhaocaiall/ArchInstall/raw/master/deepin.sh">https://gitee.com/zhaocaiall/ArchInstall/raw/master/deepin.sh</a></p>
]]></content>
      <categories>
        <category>Arch</category>
      </categories>
      <tags>
        <tag>Arch</tag>
      </tags>
  </entry>
  <entry>
    <title>Manjaro安装配置手册</title>
    <url>/2020/07/30/blog_markdown/Manjaro%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="Manjaro安装手册"><a href="#Manjaro安装手册" class="headerlink" title="Manjaro安装手册"></a>Manjaro安装手册</h2><p>Manjaro 是一个基于 Arch Linux 的 Linux 滚动发行版，用着挺舒服的。<br> 最大的特点，是包仓库很丰富，而且都很新。代价是偶尔会出些小毛病。</p>
<p>我一年多的使用中，遇到过 qv2-ray 动态链接库炸掉的问题，没专门去找修复方法，好像是等了一两个月，升级了两个大版本才恢复。<br> 另一个就是 <a href="https://github.com/microsoft/vscode/issues/110322">VSCode - Incorrect locale ‘en-US’ used everywhere</a></p>
<p>还遇到过 <code>libguestfs</code> 的一个问题：<code>vrit-v2v</code>/<code>virt-p2v</code> 两个工具被拆分出去，导致 manjaro 只能通过源码安装这俩货。这貌似目前仍旧没有解决。</p>
<p>总的来说体验很不错，能很及时地用上各种新版本的软件。</p>
<h2 id="一、pacman-yay-的基础命令"><a href="#一、pacman-yay-的基础命令" class="headerlink" title="一、pacman/yay 的基础命令"></a>一、pacman/yay 的基础命令</h2><p>Manjaro 装好后，需要运行的第一条命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo pacman -Syy <span class="comment">## 强制更新 package 目录</span></span><br><span class="line">sudo pacman-mirrors --interactive --country China  <span class="comment"># 列出所有国内的镜像源，并提供交互式的界面手动选择镜像源</span></span><br><span class="line">sudo pacman -Syyu  <span class="comment"># 强制更新 package 目录，并尝试更新已安装的所有 packages.</span></span><br><span class="line">sudo pacman -S yay  <span class="comment"># 安装 yay</span></span><br></pre></td></tr></table></figure>

<p>pacman 是 arch/manjaro 的官方包管理器，而刚刚安装的 yay，则是一个能查询 arch linux 的 aur 仓库的第三方包管理器，非常流行。</p>
<p>pacman 的常用命令语法：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pacman -S package_name        <span class="comment"># 安装软件  </span></span><br><span class="line">pacman -S extra/package_name  <span class="comment"># 安装不同仓库中的版本</span></span><br><span class="line">pacman -Syu                   <span class="comment"># 升级整个系统，y是更新数据库，yy是强制更新，u是升级软件</span></span><br><span class="line">pacman -Ss string             <span class="comment"># 在包数据库中查询软件</span></span><br><span class="line">pacman -Si package_name       <span class="comment"># 显示软件的详细信息</span></span><br><span class="line">pacman -Sc                    <span class="comment"># 清除软件缓存，即/var/cache/pacman/pkg目录下的文件</span></span><br><span class="line">pacman -R package_name        <span class="comment"># 删除单个软件</span></span><br><span class="line">pacman -Rs package_name       <span class="comment"># 删除指定软件及其没有被其他已安装软件使用的依赖关系</span></span><br><span class="line">pacman -Qs string             <span class="comment"># 查询已安装的软件包</span></span><br><span class="line">pacman -Qi package_name       <span class="comment"># 查询本地安装包的详细信息</span></span><br><span class="line">pacman -Ql package_name       <span class="comment"># 获取已安装软件所包含的文件的列表</span></span><br><span class="line">pacman -U package.tar.zx      <span class="comment"># 从本地文件安装</span></span><br><span class="line">pactree package_name          <span class="comment"># 显示软件的依赖树</span></span><br></pre></td></tr></table></figure>

<p>yay 的用法和 pacman 完全类似，上述所有 <code>pacman xxx</code> 命令，均可替换成 <code>yay xxx</code> 执行。</p>
<p>此外，还有一条 <code>yay</code> 命令值得记一下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yay -c  <span class="comment"># 卸载所有无用的依赖。类比 apt-get autoremove</span></span><br></pre></td></tr></table></figure>

<h2 id="常用软件与配置"><a href="#常用软件与配置" class="headerlink" title="常用软件与配置"></a>常用软件与配置</h2><h3 id="1-添加-archlinux-中文社区仓库"><a href="#1-添加-archlinux-中文社区仓库" class="headerlink" title="1. 添加 archlinux 中文社区仓库"></a>1. 添加 archlinux 中文社区仓库</h3><p><a href="https://www.archlinuxcn.org/archlinux-cn-repo-and-mirror/">Arch Linux 中文社区仓库</a> 是由 Arch Linux 中文社区驱动的非官方用户仓库，包含一些额外的软件包以及已有软件的 git 版本等变种。部分软件包的打包脚本来源于 AUR。</p>
<p>一些国内软件，如果直接从 aur 安装，那就会有一个编译过程，有点慢。而 archlinuxcn 有已经编译好的包，可以直接安装。更新速度也很快，推荐使用。</p>
<p>配置方法见 <a href="https://github.com/archlinuxcn/repo">Arch Linux Chinese Community Repository</a>。</p>
<h3 id="2-安装常用软件"><a href="#2-安装常用软件" class="headerlink" title="2. 安装常用软件"></a>2. 安装常用软件</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo pacman -S google-chrome  firefox         <span class="comment"># 浏览器</span></span><br><span class="line">sudo pacman -S netease-cloud-music     <span class="comment"># 网易云音乐</span></span><br><span class="line">sudo pacman -S noto-fonts-cjk wqy-bitmapfont wqy-microhei wqy-zenhei   <span class="comment"># 中文字体：思源系列、文泉系列</span></span><br><span class="line">sudo pacman -S wps-office ttf-wps-fonts</span><br><span class="line"></span><br><span class="line">sudo pacman -S vim                     <span class="comment"># 命令行编辑器</span></span><br><span class="line">sudo pacman -S git                     <span class="comment"># 版本管理工具</span></span><br><span class="line">sudo pacman -S clang make cmake gdb    <span class="comment"># 编译调试环境</span></span><br><span class="line">sudo pacman -S visual-studio-code-bin  <span class="comment"># 代码编辑器</span></span><br><span class="line"></span><br><span class="line">sudo pacman -S wireshark-qt  mitmproxy         <span class="comment"># 抓包工具</span></span><br><span class="line">sudo pacman -S docker  <span class="comment"># docker 容器</span></span><br></pre></td></tr></table></figure>

<p>其中 docker 和 wireshark 需要额外配置，否则会要求管理员权限：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo groupadd wireshark</span><br><span class="line">sudo gpasswd --add <span class="variable">$USER</span> wireshark  <span class="comment">#  将你添加到 wireshark 用户组中</span></span><br><span class="line"></span><br><span class="line">sudo groupadd docker</span><br><span class="line">sudo gpasswd --add <span class="variable">$USER</span> docker  <span class="comment"># 同上</span></span><br></pre></td></tr></table></figure>

<h3 id="3-中文输入法"><a href="#3-中文输入法" class="headerlink" title="3. 中文输入法"></a>3. 中文输入法</h3><p>有两个选择：<a href="https://rime.im/">中州韵（rime）</a>和<a href="https://aur.archlinux.org/packages/fcitx-sogoupinyin/">搜狗拼音（sogoupinyin）</a>。</p>
<p>简单省事用搜狗，要用特殊的输入方案（五笔、音形、二笔等等）就只有 rime 可选了。</p>
<h4 id="3-1-fcitx5-rime-配置小鹤音形"><a href="#3-1-fcitx5-rime-配置小鹤音形" class="headerlink" title="3.1 fcitx5-rime 配置小鹤音形"></a>3.1 fcitx5-rime 配置小鹤音形</h4><p>首先安装 fcitx5-rime, 注意这些组件一个都不能省略：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman -S fcitx5  fcitx5-chinese-addons fcitx5-gtk  fcitx5-qt  kcm-fcitx5 fcitx5-rime</span><br></pre></td></tr></table></figure>

<p>第二步是修改环境变量，将 fcitx5-rime 设为默认输入法并自动启动。</p>
<p>添加 <code>~/.pam_environment</code> 文件，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INPUT_METHOD  DEFAULT=fcitx5</span><br><span class="line">GTK_IM_MODULE DEFAULT=fcitx5</span><br><span class="line">QT_IM_MODULE  DEFAULT=fcitx5</span><br><span class="line">XMODIFIERS    DEFAULT=@im=fcitx5</span><br></pre></td></tr></table></figure>

<p><a href="https://wiki.archlinux.org/index.php/PAM_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">pam-env</a> 模块会在所有登录会话中读取上面的配置文件，包括 X11 会话和 Wayland 会话。</p>
<p>添加自动启动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ~/.xprofile 是 x11 GUI 的环境变量配置文件</span></span><br><span class="line">echo &#x27;fcitx5 &amp;&#x27; &gt;&gt; ~/.xprofile</span><br></pre></td></tr></table></figure>

<p>然后，从 <a href="http://flypy.ys168.com/">http://flypy.ys168.com/</a> 下载最新的鼠须管（MacOS）配置文件，将解压得到的 rime 文件夹拷贝到 ~/.local/share/fcitx5/ 下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv rime ~/.local/share/fcitx5/</span><br></pre></td></tr></table></figure>

<p>现在重启系统，在 fcitx5 配置里面添加 rime，就可以正常使用小鹤音形了。</p>
<p>1.配置镜像源:<br><code>sudo pacman-mirrors -i -c China -m rank</code><br> 选择速度最快的即可</p>
<p>2.设置 archlinuxcn 源,antergos源,arch4edu源:<br><code>sudo nano /etc/pacman.conf</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SigLevel = Optional TrustedOnly</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#中科大源</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#清华源</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[antergos]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SigLevel = TrustAll</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Server = https://mirrors.tuna.tsinghua.edu.cn/antergos/$repo/$arch</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[arch4edu]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SigLevel = TrustAll</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Server = https://mirrors.tuna.tsinghua.edu.cn/arch4edu/$arch</span><br></pre></td></tr></table></figure>

<p>3.更新源列表<br><code>sudo pacman-mirrors -g</code></p>
<p>4.更新pacman数据库并全面更新系统<br><code>sudo pacman -Syyu</code></p>
<p>5.防止PGP签名错误</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo pacman -S archlinuxcn-keyring</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sudo pacman -S antergos-keyring</span><br></pre></td></tr></table></figure>

<h1 id="安装ARU包管理工具"><a href="#安装ARU包管理工具" class="headerlink" title="安装ARU包管理工具"></a>安装ARU包管理工具</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo pacman -S yay</span><br></pre></td></tr></table></figure>

<h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h2><p>安装搜狗拼音输入法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo pacman -S fcitx-im </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sudo pacman -S fcitx-configtool</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sudo pacman -S fcitx-sogoupinyin</span><br></pre></td></tr></table></figure>

<p>最新版的搜狗和wine的微信和QQ有些冲突，造成卡顿和卡死<br> 推荐安装fcitx-rime，小狼豪/中州韵<br><code>sudo pacman -S fcitx-rime</code></p>
<p>添加输入法配置文件<br><code>sudo nano ~/.xprofile</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export GTK_IM_MODULE=fcitx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export QT_IM_MODULE=fcitx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export XMODIFIERS=&quot;@im=fcitx&quot;</span><br></pre></td></tr></table></figure>

<p>chrome浏览器：<code>yay -S google-chrome</code><br> Git软件：<code>yay -S git</code><br> Uget配合aria2：<code>yay -S aria2</code><br> 下载工具：<code>yay -S uget</code><br> 解压工具：<code>yay -S p7zip file-roller unrar</code><br> 图像编辑器：<code>yay -S gimp</code>（开源版PS）<br> WPS办公：<code>yay -S wps-office</code><br> WPS缺少的字体：<code>yay -S ttf-wps-fonts</code><br> WPS安装中文：<code>sudo pacman -S wps-office-mui-zh-cn</code><br> Vscode开发工具：<code>yay -S visual-studio-code-bin</code><br> Markdown编辑器：<code>yay -S typora</code><br> 强大的Web内容（视频，音频，图片）下载工具： <code>yay -S you-get</code><br> 火焰截图：<code>yay -S flameshot</code> (超好用,系统设置里面添加快捷键即可)<br> 云笔记软件：<code>yay -S joplin</code>(开源免费，云服务需要飞天服务)<br> chm文件阅读器：<code>yay -S kchmviewer</code><br> 有道词典：<code>yay -S youdao-dict</code><br> 开源电子书阅读器：<code>yay -S calibre</code><br> MD文件编辑器：<code>yay -S typora</code><br> Gif录制软件：<code>yay -S peek</code><br> 原生linuxQQ：<code>yay -S linuxqq</code><br> 聊天工具：<code>yay -S telegram-desktop</code><br> 网易云音乐：<code>yay -S netease-cloud-music</code><br> electron网易云音乐：<code>yay -S electron-netease-cloud-music</code><br> 落雪音乐助手：<code>yay -S lx-music-desktop-bin</code><br> 效率工具：<code>yay -S utools</code><br> 雅黑字体：<code>yay -S wqy-microhei</code><br> 正黑字体：<code>yay -S wqy-zenhei</code><br> 坚果云同步：nautilus-nutstore<br> 百度云盘：<code>yay -S baidunetdisk-bin</code><br> 飞天服务v2删ray（先装这个）：<code>yay -S v2删ray</code><br> 飞天软件（GUI界面）：<code>yay -S qv2删ray</code><br> sublime轻量级开发软件：<code>yay -S sublime-text-3</code><br> 开源FTP软件：<code>yay -S filezilla</code><br> 远程桌面：<code>yay -S remmina</code><br> 远程桌面插件：<code>yay -S freerdp</code><br> 远程桌面：<code>yay -S teamviewer</code><br> 先启动服务：<code>sudo teamviewer daemon start</code><br> 设置开机启动：<code>sudo systemctl enable teamviewerd.service</code><br> wine版微信：<code>yay -S deepin-wine-wechat</code><br> wine版钉钉：<code>yay -S deepin.com.dingtalk.com</code><br> electron版钉钉：<code>yay -S dingtalk-electron</code><br> wine版Tim：<code>yay -S deepin-wine-tim</code><br> wine版QQ：<code>yay -S deepin-wine-qq</code><br> wine版QQ音乐：<code>yay -S deepin.com.qq.qqmusic</code></p>
]]></content>
      <categories>
        <category>manjaro</category>
      </categories>
      <tags>
        <tag>manjaro</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven换源</title>
    <url>/2020/07/30/blog_markdown/Maven%E6%8D%A2%E6%BA%90/</url>
    <content><![CDATA[<h2 id="Maven换源"><a href="#Maven换源" class="headerlink" title="Maven换源"></a>Maven换源</h2><p>（1）找到 apache-maven-3.5.2\conf 目录中的 settings.xml 文件</p>
<p>（2） 修改maven 本地仓库地址,</p>
<p>首先在D:\Program Files创建文件夹MavenRepository ；</p>
<p>找到settings.xml 文件中  打开注释修改如下：</p>
<p>D:\Program Files\MavenRepository</p>
<p>（3）添加阿里源 ，找到   &lt;/ mirrors&gt;标签，标签中添加mirror子节点，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;mirror&gt;</span><br><span class="line">    &lt;id&gt;aliyunmaven&lt;/id&gt;</span><br><span class="line">    &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;</span><br><span class="line">    &lt;name&gt;阿里云公共仓库&lt;/name&gt;</span><br><span class="line">  &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;</span><br><span class="line">&lt;/mirror&gt;</span><br></pre></td></tr></table></figure>

<p>（4）实测，速度起飞。如果是Spring 项目，可使用阿里代理仓库,</p>
<p>在标签中加入对应的仓库使用地址。以使用spring代理仓为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;repository&gt;</span><br><span class="line">    &lt;id&gt;spring&lt;/id&gt;</span><br><span class="line">  &lt;url&gt;https://maven.aliyun.com/repository/spring&lt;/url&gt;</span><br><span class="line">    &lt;releases&gt;</span><br><span class="line">        &lt;enabled&gt;true&lt;/enabled&gt;</span><br><span class="line">    &lt;/releases&gt;</span><br><span class="line">    &lt;snapshots&gt;</span><br><span class="line">        &lt;enabled&gt;true&lt;/enabled&gt;</span><br><span class="line">    &lt;/snapshots&gt;</span><br><span class="line">&lt;/repository&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven自动化的构建工具</title>
    <url>/2020/07/30/blog_markdown/Maven%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="Maven自动化的构建工具"><a href="#Maven自动化的构建工具" class="headerlink" title="Maven自动化的构建工具"></a>Maven自动化的构建工具</h1><h2 id="第一章-Maven-简介"><a href="#第一章-Maven-简介" class="headerlink" title="第一章 Maven 简介"></a>第一章 Maven 简介</h2><h3 id="1-1-软件开发中的阶段"><a href="#1-1-软件开发中的阶段" class="headerlink" title="1.1 软件开发中的阶段"></a>1.1 软件开发中的阶段</h3><p>需要分析:分析项目具体完成的功能,有什么要求,具体怎么实现。</p>
<p>设计阶段:根据分析的结果,设计项目的使用什么技术,解决难点。</p>
<p>开发阶段：编码实现功能。编译代码。自我测试</p>
<p>测试阶段：专业的测试人员，测整个项目的功能十分符合设计要求。完成后出一个测试报告。</p>
<p>项目的打包，发布阶段：给用户安装项目</p>
<h2 id="1-2Maven能做什么"><a href="#1-2Maven能做什么" class="headerlink" title="1.2Maven能做什么"></a>1.2Maven能做什么</h2><p>1）项目的自动构建，帮助开发人员做项目代码的编译，测试，打包，安装，部署等工作。</p>
<p>2）管理依赖（使用到的jar包）。</p>
<p>​    依赖：项目中需要使用的其他资源，常见的是jar。比如项目要使用mysql驱动。我们就说项目依赖mysql驱动。</p>
<h2 id="1-3-没有使用maven怎么管理以来"><a href="#1-3-没有使用maven怎么管理以来" class="headerlink" title="1.3 没有使用maven怎么管理以来"></a>1.3 没有使用maven怎么管理以来</h2><p>管理jar，需要从网络中单独下载jar</p>
<p>需要选择正确版本</p>
<p>手工处理ar文件之间的依赖。aar里面要使用bar的类。</p>
<h2 id="1-4什么是-maven"><a href="#1-4什么是-maven" class="headerlink" title="1.4什么是 maven"></a>1.4什么是 maven</h2><p>maven是 apache基金会的开源项目,使用java语法开发。 Maven这个单词的本意是:专家,内行。<br>maven是项目的自动化构建工具。管理项目的依赖</p>
<h2 id="1-5-maven中概念"><a href="#1-5-maven中概念" class="headerlink" title="1.5 maven中概念"></a>1.5 maven中概念</h2><p>①PoM<br>②约定的目录结构<br>③坐标<br>④依赖管理<br>⑤仓库管理<br>⑥生命周期<br>⑦插件和目标<br>⑧继承<br>聚合</p>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot(原创是CodeSheep)</title>
    <url>/2020/08/04/blog_markdown/SpringBoot/</url>
    <content><![CDATA[<h3 id="本项目为-spring-Boot系列文章"><a href="#本项目为-spring-Boot系列文章" class="headerlink" title="本项目为 spring Boot系列文章"></a>本项目为 spring Boot系列文章</h3><p><a href="https://996.icu/#/en_US"><img src="https://img.shields.io/badge/link-996.icu-%23FF4D5B.svg" alt="Badge"></a><br><a href="https://github.com/996icu/996.ICU/blob/master/LICENSE"><img src="https://img.shields.io/badge/license-Anti%20996-blue.svg" alt="LICENSE"></a><br><a href="https://join.slack.com/t/996icu/shared_invite/enQtNTg4MjA3MzA1MzgxLWQyYzM5M2IyZmIyMTVjMzU5NTE5MGI5Y2Y2YjgwMmJiMWMxMWMzNGU3NDJmOTdhNmRlYjJlNjk5ZWZhNWIwZGM"><img src="https://img.shields.io/badge/slack-996icu-green.svg" alt="Slack"></a></p>
<hr>
<hr>
<h1 id="数据库-缓存相关"><a href="#数据库-缓存相关" class="headerlink" title="数据库/缓存相关"></a>数据库/缓存相关</h1><ul>
<li><p><a href="https://github.com/hansonwang99/Spring-Boot-In-Action/tree/master/springbt_guava_cache">Guava Cache本地缓存在 Spring Boot应用中的实践</a></p>
</li>
<li><p><a href="https://github.com/hansonwang99/Spring-Boot-In-Action/tree/master/springbt_evcache">EVCache缓存在 Spring Boot中的实战</a></p>
</li>
<li><p><a href="https://github.com/hansonwang99/Spring-Boot-In-Action/tree/master/springbt_ehcache">Spring Boot应用缓存实践之：Ehcache加持</a></p>
</li>
<li><p><a href="https://github.com/hansonwang99/Spring-Boot-In-Action/tree/master/springbt_mybatis_sqlserver">Spring Boot集成 MyBatis和 SQL Server实践</a></p>
</li>
<li><p><a href="https://github.com/hansonwang99/Spring-Boot-In-Action/tree/master/springboot_es_demo">Elasticsearch搜索引擎在Spring Boot中的实践</a></p>
</li>
<li><p><a href="https://www.codesheep.cn/2019/02/28/elasticsearch-spring-boot-starter/">自制一个 elasticsearch-spring-boot-starter</a></p>
</li>
<li><p><a href="https://www.codesheep.cn/2019/02/14/mybatis-generator/">Spring Boot项目利用MyBatis Generator进行数据层代码自动生成</a></p>
</li>
<li><p><a href="https://www.codesheep.cn/2019/04/12/springbt-mybatis-plus/">Mybatis-Plus 真好用（乡村爱情加持）</a></p>
</li>
</ul>
<hr>
<h1 id="日志相关"><a href="#日志相关" class="headerlink" title="日志相关"></a>日志相关</h1><ul>
<li><a href="http://www.codesheep.cn/2018/03/29/Boot%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%AE%9E%E8%B7%B5/">Spring Boot日志框架实践</a></li>
</ul>
<hr>
<h1 id="应用监控相关"><a href="#应用监控相关" class="headerlink" title="应用监控相关"></a>应用监控相关</h1><ul>
<li><p><a href="https://www.codesheep.cn/2019/01/17/springbt-btrace/">利用神器 BTrace 追踪线上 Spring Boot应用运行时信息</a></p>
</li>
<li><p><a href="https://github.com/hansonwang99/Spring-Boot-In-Action/tree/master/springbt_admin_server">Spring Boot应用监控实战</a></p>
</li>
<li><p><a href="https://github.com/hansonwang99/Spring-Boot-In-Action/tree/master/spring_boot_admin2.0_demo">Spring Boot Admin 2.0开箱体验</a></p>
</li>
</ul>
<hr>
<h1 id="内部机制相关"><a href="#内部机制相关" class="headerlink" title="内部机制相关"></a>内部机制相关</h1><ul>
<li><p><a href="http://www.codesheep.cn/2018/07/30/at-SpringBootApplication-zhujie/">SpringBoot 中 @SpringBootApplication注解背后的三体结构探秘</a></p>
</li>
<li><p><a href="http://www.codesheep.cn/2018/09/04/springboot-startup-process/">SpringBoot 应用程序启动过程探秘</a></p>
</li>
<li><p><a href="https://www.codesheep.cn/2019/01/24/springbt-starter/">如何自制一个Spring Boot Starter并推送到远端公服</a></p>
</li>
</ul>
<hr>
<h1 id="认证和权限相关"><a href="#认证和权限相关" class="headerlink" title="认证和权限相关"></a>认证和权限相关</h1><ul>
<li><p><a href="https://github.com/hansonwang99/Spring-Boot-In-Action/tree/master/springbt_security_jwt">基于 Spring Security和 JWT的权限系统设计</a></p>
</li>
<li><p><a href="https://github.com/hansonwang99/Spring-Boot-In-Action/tree/master/springbt_sso_jwt">基于Spring Security Oauth2的SSO单点登录+JWT权限控制实践</a></p>
</li>
</ul>
<hr>
<h1 id="实战经验相关"><a href="#实战经验相关" class="headerlink" title="实战经验相关"></a>实战经验相关</h1><ul>
<li><p><a href="https://github.com/hansonwang99/Spring-Boot-In-Action/tree/master/springbt_uid_generator">Spring Boot工程集成全局唯一ID生成器 UidGenerator</a></p>
</li>
<li><p><a href="https://github.com/hansonwang99/Spring-Boot-In-Action/tree/master/springbt_vesta">Spring Boot 工程集成全局唯一ID生成器 Vesta</a></p>
</li>
<li><p><a href="http://www.codesheep.cn/2018/04/09/SpringBoot%E4%BC%98%E9%9B%85%E7%BC%96%E7%A0%81%E4%B9%8B%EF%BC%9ALombok%E5%8A%A0%E6%8C%81/">Spring Boot优雅编码之：Lombok加持</a></p>
</li>
<li><p><a href="http://www.codesheep.cn/2018/04/12/SpringBoot%E5%BA%94%E7%94%A8Docker%E5%8C%96/">Spring Boot应用 Docker化</a></p>
</li>
<li><p><a href="http://www.codesheep.cn/2018/06/23/SpringBoot%E7%83%AD%E9%83%A8%E7%BD%B2%E5%8A%A0%E6%8C%81/">Spring Boot热部署加持</a></p>
</li>
<li><p><a href="https://github.com/hansonwang99/Spring-Boot-In-Action/tree/master/springbt_watermark">基于Spring Boot实现图片上传/加水印一把梭操作</a></p>
</li>
<li><p><a href="http://www.codesheep.cn/2018/06/10/%E4%BB%8ESpringBoot%E5%88%B0SpringMVC/">从Spring Boot到 SpringMVC</a></p>
</li>
<li><p><a href="http://www.codesheep.cn/2018/11/01/springbt-hanlp/">自然语言处理工具包 HanLP在 Spring Boot中的应用</a></p>
</li>
<li><p><a href="http://www.codesheep.cn/2018/06/05/SpringBoot%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2%E4%BA%8E%E5%A4%96%E7%BD%AETomcat%E5%AE%B9%E5%99%A8/">Spring Boot应用部署于外置Tomcat容器</a></p>
</li>
<li><p><a href="https://github.com/hansonwang99/Spring-Boot-In-Action/tree/master/kotlin_with_springbt">初探 Kotlin + Spring Boot联合编程</a></p>
</li>
</ul>
<hr>
<h1 id="本文来自CoodSheep-非原创"><a href="#本文来自CoodSheep-非原创" class="headerlink" title="本文来自CoodSheep,非原创"></a>本文来自CoodSheep,非原创</h1>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>懒人必备，IntelliJ IDEA中代码一键生成</title>
    <url>/2020/07/30/blog_markdown/dao%20service%20,%E4%B8%80%E9%94%AE%E7%94%9F%E6%88%90/</url>
    <content><![CDATA[<h1 id="懒人必备，IntelliJ-IDEA中代码一键生成"><a href="#懒人必备，IntelliJ-IDEA中代码一键生成" class="headerlink" title="懒人必备，IntelliJ IDEA中代码一键生成"></a>懒人必备，IntelliJ IDEA中代码一键生成</h1><p>EasyCode  是基于 IntelliJ IDEA  开发的代码生成插件，支持自定义任意模板（Java，html，js，xml）；只要是与数据库相关的代码都可以通过自定义模板来生成；支持数据库类型与 java 类型映射关系配置；支持同时生成生成多张表的代码，张表有独立的配置信息，完全的个性化定义，规则由你设置。</p>
<p>我自己也稍微体验了一把，还是蛮方便的。</p>
<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a><strong>1.安装</strong></h2><p>首先点击 File-&gt;Settings-&gt;Plugins，然后搜索 EasyCode，如下：</p>
<p><img src="https://pic2.zhimg.com/v2-f796536675576463a14c6527f0edcfc9_r.jpg" alt="img"></p>
<p>安装成功之后，重启 IDEA。</p>
<h2 id="2-创建项目"><a href="#2-创建项目" class="headerlink" title="2.创建项目"></a><strong>2.创建项目</strong></h2><p>如何在 Spring Boot 中使用 EasyCode。首先我们在 IDEA 中创建一个 SpringBoot 项目</p>
<h2 id="3-添加数据源"><a href="#3-添加数据源" class="headerlink" title="3.添加数据源"></a><strong>3.添加数据源</strong></h2><p>由于这个项目是基于 IDEA 上的 Database Tools 开发的，因此我们首先要通过 IDEA 上的 Database 连接数据源。</p>
<p><img src="https://pic4.zhimg.com/v2-c600e28c5ee3e1f67635e81ba4ae47b7_r.jpg" alt="img"></p>
<p>接下来配置你的数据库连接信息，如果没有检测到合适的数据库 Driver，点击左下角自动下载：</p>
<p><img src="https://pic1.zhimg.com/v2-5846c08a570f0d2c536b0b82f5ff8864_r.jpg" alt="img"></p>
<p>连接成功后，点击 OK。默认情况下没有展示连接下的数据库，需要我们手动勾选，例如我这里要连接 vhr 数据库，如下：</p>
<p><img src="https://pic1.zhimg.com/v2-3c490cf0913fd268cdebf8fcdbdda1e8_r.jpg" alt="img"></p>
<h2 id="4-生成代码"><a href="#4-生成代码" class="headerlink" title="4.生成代码"></a><strong>4.生成代码</strong></h2><p>做完前面三步，准备工作就算 OK 了，接下来就是生成代码了。例如我想给 vhr 中所有的代码生成实体类、dao 层以及 service 层，方式如下：</p>
<p>首先选中所有的表，然后右键单击，选择 Easy Code-&gt;Generate Code，如下：</p>
<p><img src="https://pic1.zhimg.com/v2-93645d55c181b06095eecc15dbde19bc_r.jpg" alt="img"></p>
<p>第一次添加的时候，如果有数据库类型没有对应的 Java 类型，就会有提示，这个根据它的引导去添加映射关系即可，例如我在添加的时候，出了一个这个提示：</p>
<p><img src="https://pic2.zhimg.com/v2-22e6ce58f3f0e8d523b528cbd19b93b5_r.jpg" alt="img"></p>
<p>点击 Yes，然后去添加自己的类型映射：</p>
<p><img src="https://pic1.zhimg.com/v2-df5c19dd5c0f6c2afae0805b47fc7f44_r.jpg" alt="img"></p>
<p>添加成功之后，再去做代码生成，这下就可以了：</p>
<p><img src="https://pic2.zhimg.com/v2-fa92e027c3d2304aacddb7a686692c2d_r.jpg" alt="img"></p>
<p>这里，如果项目是多模块项目，可以先选择代码生成的 Module，然后设置代码生成的 package，最后从下面勾选要生成的代码模版，点击 OK 即可。</p>
<blockquote>
<p>❝ 在代码生成的过程中，如果没检测到 package 下面有 service、dao 以及 entity 等包，工具会提示自动创建，点击 Yes 即可。<br> ❞</p>
</blockquote>
<p>最终生成的代码如下：</p>
<p><img src="https://pic3.zhimg.com/v2-05696f765285bae18db5c12af01a96ba_r.jpg" alt="img"></p>
<p>至此，各层的代码基本都生成了。大部分小伙伴用到这一步可能就 OK 了。</p>
<p>当然如果你觉得 EasyCode 自动生成的模版不够用，或者不好用，我们也可以自定义模版。</p>
<h2 id="5-自定义模版"><a href="#5-自定义模版" class="headerlink" title="5.自定义模版"></a><strong>5.自定义模版</strong></h2><p>例如，我想在生成的 dao 层代码中，额外添加一个不需要任何条件，获取所有数据的方法（默认的生成模版中没有这个方法）。</p>
<p>点击 File-&gt;Settings-&gt;Easy Code-&gt;Template Setting：</p>
<p><img src="https://pic3.zhimg.com/v2-bb4f4c1c33d937717913ce1dcc3f881e_r.jpg" alt="img"></p>
<p>可以参考工具自己的定义方式，我们现在先在dao.java 中，添加如下方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 查询所有数据</span><br><span class="line"> *</span><br><span class="line"> * @param $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 实例对象</span><br><span class="line"> * @return 对象列表</span><br><span class="line"> */</span><br><span class="line">List&lt;$!&#123;tableInfo.name&#125;&gt; getAll();</span><br></pre></td></tr></table></figure>

<p>然后再给它添加一个配套的 mapper.xml 中的方法，打开 mapper.xml ，添加如下方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;getAll&quot; resultMap=&quot;$!&#123;tableInfo.name&#125;Map&quot;&gt;</span><br><span class="line">    select</span><br><span class="line">      #allSqlColumn()</span><br><span class="line">    from $!&#123;tableInfo.obj.parent.name&#125;.$!tableInfo.obj.name</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>配置完成后，点击 OK。</p>
<p>接下来再去重新生成代码，就可以看到生成的方法中多了一个方法了，其他代码模版的定义与这个类似，我就不再赘述了。</p>
]]></content>
      <categories>
        <category>idea插件</category>
      </categories>
      <tags>
        <tag>idea插件</tag>
      </tags>
  </entry>
  <entry>
    <title>idea常用（好用的）插件</title>
    <url>/2020/07/30/blog_markdown/idea%E5%B8%B8%E7%94%A8%EF%BC%88%E5%A5%BD%E7%94%A8%E7%9A%84%EF%BC%89%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="idea常用（好用的）插件"><a href="#idea常用（好用的）插件" class="headerlink" title="idea常用（好用的）插件"></a>idea常用（好用的）插件</h1><h2 id="1、Lombok"><a href="#1、Lombok" class="headerlink" title="1、Lombok"></a>1、Lombok</h2><p>简化你的实体类不再写get/set方法，还能快速的实现builder模式，以及链式调用方法，总之就是为了简化实体类而生的插件。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/248e7c4d10bd8c87520557dfb83ce2d3.png" alt="idea 常用插件推荐"></p>
<h2 id="2、Free-Mybatis-Plugin"><a href="#2、Free-Mybatis-Plugin" class="headerlink" title="2、Free Mybatis Plugin"></a>2、Free Mybatis Plugin</h2><p>一个提高mybatis编码的插件。实现了dao层跳转到xml层的跳转功能。</p>
<p><img src="https://img-blog.csdnimg.cn/20201030150131311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTg2NDk2,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="3、Mybatis-log-plugin"><a href="#3、Mybatis-log-plugin" class="headerlink" title="3、Mybatis-log-plugin"></a><strong>3、Mybatis-log-plugin</strong></h2><p>根据mybatis输出的sql日志，转换为拼接好参数的sql</p>
<p><img src="https://img-blog.csdnimg.cn/20201030150801453.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTg2NDk2,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20201030150816193.png" alt="img"></p>
<h2 id="4、Jrebel"><a href="#4、Jrebel" class="headerlink" title="4、Jrebel"></a><strong>4、Jrebel</strong></h2><p>一款比较好用的热部署插件，省去了一直重启的麻烦，尤其适合项目比较大的，能够节省不少时间。</p>
<p>详情参考：<a href="https://blog.csdn.net/seanxwq/article/details/89892614">https://blog.csdn.net/seanxwq/article/details/89892614</a></p>
<p><a href="https://blog.csdn.net/top_explore/article/details/107321541">https://blog.csdn.net/top_explore/article/details/107321541</a></p>
<h2 id="5、Maven-Helper"><a href="#5、Maven-Helper" class="headerlink" title="5、Maven Helper"></a><strong>5、Maven Helper</strong></h2><p>主要功能如下：查找和排除冲突依赖项的简便方法，为包含当前文件或根模块的模块运行/调试maven目标的操作，运行/调试当前测试文件的操作。</p>
<p><img src="https://img-blog.csdnimg.cn/20201030151744238.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTg2NDk2,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="6、RestfulToolkit"><a href="#6、RestfulToolkit" class="headerlink" title="6、RestfulToolkit"></a><strong>6、RestfulToolkit</strong></h2><ul>
<li>根据 URL 直接跳转到对应的方法定义 ( Ctrl \ or Ctrl Alt N );</li>
<li>提供了一个 Services tree 的显示窗口;</li>
<li>一个简单的 http 请求工具;</li>
<li>在请求方法上添加了有用功能: 复制生成 URL;,复制方法参数…</li>
<li>其他功能: java 类上添加 Convert to JSON 功能，格式化 json 数据 ( Windows: Ctrl + Enter; Mac: Command + Enter )</li>
</ul>
<h2 id="7、GsonFormat"><a href="#7、GsonFormat" class="headerlink" title="7、GsonFormat"></a>7、<strong>GsonFormat</strong></h2><p>超级实用的一个插件，对接第三方接口，通常需要将对方的json字符串转实体类，搞的很是头疼。使用<strong>GsonFormat</strong>我们只需要创建一个类，然后把要转换的json字符串复制进去，点击OK它就会给我们生成相应的实体对象。</p>
<p>1）新建一个类</p>
<p><img src="https://img-blog.csdnimg.cn/20201030154015936.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTg2NDk2,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>2）右键，选择Generate-&gt;<strong>GsonFormat</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20201030154046939.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTg2NDk2,size_16,color_FFFFFF,t_70" alt="img"><img src="https://img-blog.csdnimg.cn/20201030154133975.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTg2NDk2,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>3）粘入json字符串</p>
<p><img src="https://img-blog.csdnimg.cn/20201030154536681.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTg2NDk2,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20201030154555960.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTg2NDk2,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="8、redis"><a href="#8、redis" class="headerlink" title="8、redis"></a>8、redis</h2><p>redis客户端工具，不需要再去安装第三方客户端，相对方便许多。</p>
<h2 id="9、arthas-idea"><a href="#9、arthas-idea" class="headerlink" title="9、arthas idea"></a>9、arthas idea</h2><p>有了arthas这种神器可以线上输出日志，但是watch语法还是不够简单，因此Idea arthas 插件就此横空出世，插件安装成功后，只需要<strong>将光标放置在具体的类、字段、方法上面 右键选择需要执行的命令，部分会有窗口弹出、根据界面操作获取命令；部分直接获取命令复制到了剪切板 ，自己启动arthas 后粘贴即可执行。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20201126102954407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTg2NDk2,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20201126102859979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTg2NDk2,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>复制出来的命令：</p>
<blockquote>
<p>watch com.demo.service.DemoService getUser ‘{params,returnObj,throwExp}’ -v -n 5 -x 3 ‘1==1’</p>
</blockquote>
<h1 id="四、settings配置导入导出（插件无法导入导出）"><a href="#四、settings配置导入导出（插件无法导入导出）" class="headerlink" title="四、settings配置导入导出（插件无法导入导出）"></a>四、settings配置导入导出（插件无法导入导出）</h1><p>使用IDEA很长一段时间，软件相关的配置也都按照自己习惯的设置好，如果需要重装软件，还得需要重新设置，为了避免重复设置，可以将以前的IDEA配置导出，然后在新的IDEA上导入即可完成迁移（注：插件无法导入导出）。</p>
<h2 id="1、导出：File-gt-Export-Settings"><a href="#1、导出：File-gt-Export-Settings" class="headerlink" title="1、导出：File-&gt;Export Settings"></a>1、导出：File-&gt;Export Settings</h2><p><img src="https://img-blog.csdnimg.cn/20201030160313896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTg2NDk2,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="2、选择保存位置"><a href="#2、选择保存位置" class="headerlink" title="2、选择保存位置"></a>2、选择保存位置</h2><p><img src="https://img-blog.csdnimg.cn/20201030160436412.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTg2NDk2,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20201030160508933.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTg2NDk2,size_16,color_FFFFFF,t_70" alt="img"></p>
<h2 id="3、导入：File-gt-Import-Settings，选择刚才导出的jar包即可"><a href="#3、导入：File-gt-Import-Settings，选择刚才导出的jar包即可" class="headerlink" title="3、导入：File-&gt;Import Settings，选择刚才导出的jar包即可"></a>3、导入：File-&gt;Import Settings，选择刚才导出的jar包即可</h2><p><img src="https://img-blog.csdnimg.cn/20201030160607478.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTg2NDk2,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20201030160659235.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTg2NDk2,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>我们又可以在新的IDEA中愉快的玩耍了。</p>
]]></content>
      <categories>
        <category>idea</category>
      </categories>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title>manjaro初始化命令一条龙</title>
    <url>/2020/07/30/blog_markdown/manjaro%E5%88%9D%E5%A7%8B%E5%8C%96%E5%91%BD%E4%BB%A4%E4%B8%80%E6%9D%A1%E9%BE%99/</url>
    <content><![CDATA[<h1 id="manjaro初始化命令一条龙"><a href="#manjaro初始化命令一条龙" class="headerlink" title="manjaro初始化命令一条龙"></a>manjaro初始化命令一条龙</h1><pre><code>echo 正在备份默认安装源
sudo cp /etc/pacman.conf /etc/pacman.conf.bak #备份源
sudo cp /etc/pacman.d/mirrorlist /etc/pacman.d/mirrorlist.bak
</code></pre>
<p>#=========================================================<br>echo 正在修改源</p>
<p>cat &gt;&gt; /etc/pacman.conf &lt;&lt; ‘EOF’<br>[archlinuxcn]<br>#SigLevel = Optional TrustedOnly<br>#清华源<br>#Server = <a href="https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch">https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch</a><br>#中科大源<br>Server = <a href="https://mirrors.ustc.edu.cn/archlinuxcn/$arch">https://mirrors.ustc.edu.cn/archlinuxcn/$arch</a><br>##阿里源##<br>##Server = <a href="https://mirrors.aliyun.com/archlinuxcn/$arch">https://mirrors.aliyun.com/archlinuxcn/$arch</a></p>
<p>EOF</p>
<pre><code>echo 正在更新软件源

  #  sudo echo &#39;Server = https://mirrors.huaweicloud.com/manjaro/stable/$repo/$arch&#39; &gt;&gt; /etc/pacman.d/mirrorlist
  #  sudo echo &#39;## Country : China&#39; &gt;&gt; /etc/pacman.d/mirrorlist
  #  sudo echo &#39;Server = https://mirrors.ustc.edu.cn/manjaro/stable/$repo/$arch&#39; &gt;&gt; /etc/pacman.d/mirrorlist    



sudo pacman-mirrors -c China
</code></pre>
<h1 id="sudo-pacman-mirrors-i-c-China-m-rank"><a href="#sudo-pacman-mirrors-i-c-China-m-rank" class="headerlink" title="sudo pacman-mirrors -i -c China -m rank"></a>sudo pacman-mirrors -i -c China -m rank</h1><h1 id="sudo-pacman-mirrors-g"><a href="#sudo-pacman-mirrors-g" class="headerlink" title="sudo pacman-mirrors -g"></a>sudo pacman-mirrors -g</h1><pre><code>sudo pacman -Syyu
sudo pacman -S --noconfirm  archlinuxcn-keyring
sudo pacman -S --noconfirm antergos-keyring
</code></pre>
<h1 id="sudo-pacman-key-–refresh-keys"><a href="#sudo-pacman-key-–refresh-keys" class="headerlink" title="sudo pacman-key –refresh-keys"></a>sudo pacman-key –refresh-keys</h1><h1 id="sudo-pacman-key-–init"><a href="#sudo-pacman-key-–init" class="headerlink" title="sudo pacman-key –init"></a>sudo pacman-key –init</h1><h1 id="sudo-pacman-key-–populate"><a href="#sudo-pacman-key-–populate" class="headerlink" title="sudo pacman-key –populate"></a>sudo pacman-key –populate</h1><pre><code>sudo pacman -S --noconfirm base-devel  #安装基本打包工具
  # gnome
</code></pre>
<p>#sudo echo ‘en_US.UTF-8 UTF-8’ &gt;&gt; /etc/locale.gen<br>#sudo locale-gen</p>
<h1 id="sudo-localectl-set-locale-LANG-zh-CN-UTF-8"><a href="#sudo-localectl-set-locale-LANG-zh-CN-UTF-8" class="headerlink" title="sudo localectl set-locale LANG=zh_CN.UTF-8"></a>sudo localectl set-locale LANG=zh_CN.UTF-8</h1><p>reboot</p>
<p>#!/bin/bash<br>####################################################</p>
<h1 id="Manjaro-Linux常用软件一键安装脚本"><a href="#Manjaro-Linux常用软件一键安装脚本" class="headerlink" title="Manjaro Linux常用软件一键安装脚本"></a>Manjaro Linux常用软件一键安装脚本</h1><h1 id="v0-3"><a href="#v0-3" class="headerlink" title="v0.3"></a>v0.3</h1><h1 id="Author-addzero"><a href="#Author-addzero" class="headerlink" title="Author: addzero"></a>Author: addzero</h1><h1 id="Copyright-c-2021-zhouxuanyi"><a href="#Copyright-c-2021-zhouxuanyi" class="headerlink" title="Copyright (c) 2021 zhouxuanyi"></a>Copyright (c) 2021 zhouxuanyi</h1><h1 id="URL"><a href="#URL" class="headerlink" title="URL:"></a>URL:</h1><h1 id="License-MIT"><a href="#License-MIT" class="headerlink" title="License: MIT"></a>License: MIT</h1><p>####################################################</p>
<h1 id="mkdir-tmp-Manjaro-linux"><a href="#mkdir-tmp-Manjaro-linux" class="headerlink" title="mkdir /tmp/Manjaro-linux"></a>mkdir /tmp/Manjaro-linux</h1><h1 id="cd-tmp-Manjaro-linux"><a href="#cd-tmp-Manjaro-linux" class="headerlink" title="cd /tmp/Manjaro-linux"></a>cd /tmp/Manjaro-linux</h1><h1 id="touch-config-txt"><a href="#touch-config-txt" class="headerlink" title="touch config.txt"></a>touch config.txt</h1><h1 id=""><a href="#" class="headerlink" title="======================================"></a>======================================</h1><pre><code> sudo pacman -S --noconfirm yay  #包管理工具
</code></pre>
<h1 id="sudo-pacman-S-–noconfirm-xorg-arch驱动"><a href="#sudo-pacman-S-–noconfirm-xorg-arch驱动" class="headerlink" title="sudo pacman -S –noconfirm xorg #arch驱动"></a>sudo pacman -S –noconfirm xorg #arch驱动</h1><h1 id="sudo-pacman-S-–noconfirm-plasma-kde-applications-kde桌面"><a href="#sudo-pacman-S-–noconfirm-plasma-kde-applications-kde桌面" class="headerlink" title="sudo pacman -S –noconfirm plasma kde-applications #kde桌面"></a>sudo pacman -S –noconfirm plasma kde-applications #kde桌面</h1><h1 id="sudo-pacman-S-–noconfirm-xf86-input-libinput-触控板驱动"><a href="#sudo-pacman-S-–noconfirm-xf86-input-libinput-触控板驱动" class="headerlink" title="sudo pacman -S –noconfirm xf86-input-libinput #触控板驱动"></a>sudo pacman -S –noconfirm xf86-input-libinput #触控板驱动</h1><h1 id="sudo-pacman-S-–noconfirm-alsa-utils-pulseaudio-alsa-声卡"><a href="#sudo-pacman-S-–noconfirm-alsa-utils-pulseaudio-alsa-声卡" class="headerlink" title="sudo pacman -S –noconfirm alsa-utils pulseaudio-alsa #声卡"></a>sudo pacman -S –noconfirm alsa-utils pulseaudio-alsa #声卡</h1><h1 id="echo-坚果云"><a href="#echo-坚果云" class="headerlink" title="echo 坚果云"></a>echo 坚果云</h1><h1 id="sudo-pacman-S-–noconfirm-nutstore"><a href="#sudo-pacman-S-–noconfirm-nutstore" class="headerlink" title="sudo pacman -S –noconfirm nutstore"></a>sudo pacman -S –noconfirm nutstore</h1><h1 id="sudo-pacman-S-–noconfirm-tmux"><a href="#sudo-pacman-S-–noconfirm-tmux" class="headerlink" title="sudo pacman -S –noconfirm tmux"></a>sudo pacman -S –noconfirm tmux</h1><pre><code>sudo pacman -S --noconfirm xed
echo typora
sudo pacman -S --noconfirm typora
</code></pre>
<h1 id="sudo-pacman-S-–noconfirm-qtwebkit-bin"><a href="#sudo-pacman-S-–noconfirm-qtwebkit-bin" class="headerlink" title="sudo pacman -S –noconfirm qtwebkit-bin"></a>sudo pacman -S –noconfirm qtwebkit-bin</h1><h1 id="sudo-pacman-S-–noconfirm-ttf-sarasa-gothic-安装更纱黑体"><a href="#sudo-pacman-S-–noconfirm-ttf-sarasa-gothic-安装更纱黑体" class="headerlink" title="sudo pacman -S –noconfirm ttf-sarasa-gothic #安装更纱黑体"></a>sudo pacman -S –noconfirm ttf-sarasa-gothic #安装更纱黑体</h1><p>#echo 输入法</p>
<h1 id="sudo-pacman-S-–noconfirm-fcitx5-fcitx5-chinese-addons-fcitx5-qt-fcitx5-gtk-kcm-fcitx5-输入法安装"><a href="#sudo-pacman-S-–noconfirm-fcitx5-fcitx5-chinese-addons-fcitx5-qt-fcitx5-gtk-kcm-fcitx5-输入法安装" class="headerlink" title="sudo pacman -S –noconfirm fcitx5 fcitx5-chinese-addons fcitx5-qt fcitx5-gtk kcm-fcitx5 #输入法安装"></a>sudo pacman -S –noconfirm fcitx5 fcitx5-chinese-addons fcitx5-qt fcitx5-gtk kcm-fcitx5 #输入法安装</h1><pre><code>sudo pacman -S --noconfirm fcitx-im fcitx-configtool
</code></pre>
<h1 id="-1"><a href="#-1" class="headerlink" title="======================================================================================================================="></a>=======================================================================================================================</h1><h1 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h1><p>#需要手动配置maven仓库<br>    echo 安装maven手动配置maven仓库<br>    sudo pacman -S –noconfirm maven</p>
<h1 id="sudo-kate-tmp-Manjaro-linux-config-txt"><a href="#sudo-kate-tmp-Manjaro-linux-config-txt" class="headerlink" title="sudo kate /tmp/Manjaro-linux/config.txt"></a>sudo kate /tmp/Manjaro-linux/config.txt</h1><h1 id="sudo-kate-opt-maven-conf-settings-xml"><a href="#sudo-kate-opt-maven-conf-settings-xml" class="headerlink" title="sudo kate /opt/maven/conf/settings.xml"></a>sudo kate /opt/maven/conf/settings.xml</h1><h1 id="sudo-pacman-S-–noconfirm-python-安装python"><a href="#sudo-pacman-S-–noconfirm-python-安装python" class="headerlink" title="sudo pacman -S –noconfirm python  #安装python"></a>sudo pacman -S –noconfirm python  #安装python</h1><pre><code>sudo pacman -S --noconfirm  jdk8-openjdk
sudo pacman -S --noconfirm jdk11-openjdk
sudo pacman -S --noconfirm  git
echo 安装docker
sudo pacman -S --noconfirm docker

sudo mkdir -p /etc/docker
</code></pre>
<p>sudo tee /etc/docker/daemon.json &lt;&lt;-‘EOF’<br>{<br>“registry-mirrors”: [“<a href="https://dqdldy32.mirror.aliyuncs.com&quot;]">https://dqdldy32.mirror.aliyuncs.com&quot;]</a><br>}<br>EOF<br>sudo systemctl daemon-reload<br>sudo systemctl restart docker</p>
<pre><code>echo 安装nodejs
sudo pacman -S --noconfirm nodejs
 echo 安装npm
sudo pacman -S --noconfirm npm
 echo 安装 visual-studio-code
sudo pacman -S --noconfirm visual-studio-code-bin ##安装vs code##
 echo  virtualbox
sudo pacman -S --noconfirm virtualbox  ##安装virtualbox##
echo 安装网易云音乐
sudo pacman -S --noconfirm netease-cloud-music
</code></pre>
<h1 id="sudo-pacman-S-–noconfirm-google-chrome-安装谷歌浏览器"><a href="#sudo-pacman-S-–noconfirm-google-chrome-安装谷歌浏览器" class="headerlink" title="sudo pacman -S –noconfirm google-chrome #安装谷歌浏览器"></a>sudo pacman -S –noconfirm google-chrome #安装谷歌浏览器</h1><h1 id="sudo-pacman-S-–noconfirm-vim-安装vim"><a href="#sudo-pacman-S-–noconfirm-vim-安装vim" class="headerlink" title="sudo pacman -S –noconfirm vim #安装vim"></a>sudo pacman -S –noconfirm vim #安装vim</h1><h1 id="sudo-pacman-S-–noconfirm-zsh-安装zsh"><a href="#sudo-pacman-S-–noconfirm-zsh-安装zsh" class="headerlink" title="sudo pacman -S –noconfirm zsh #安装zsh"></a>sudo pacman -S –noconfirm zsh #安装zsh</h1><h1 id="sudo-pacman-–aururl-“https-aur-tuna-tsinghua-edu-cn-quot-–save-包管理工具-可以不用"><a href="#sudo-pacman-–aururl-“https-aur-tuna-tsinghua-edu-cn-quot-–save-包管理工具-可以不用" class="headerlink" title="sudo pacman –aururl “https://aur.tuna.tsinghua.edu.cn&quot; –save  # 包管理工具(可以不用)"></a>sudo pacman –aururl “<a href="https://aur.tuna.tsinghua.edu.cn&quot;/">https://aur.tuna.tsinghua.edu.cn&quot;</a> –save  # 包管理工具(可以不用)</h1><pre><code>echo  ##npm换源##
sudo npm config set registry https://registry.npm.taobao.org
</code></pre>
<p>echo  cnpm<br>sudo npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a> &amp;&amp; cnpm sync connect</p>
<h1 id="lt-npm换源-gt"><a href="#lt-npm换源-gt" class="headerlink" title="&lt;npm换源&gt;"></a>&lt;npm换源&gt;</h1><pre><code>echo 使用cnpm安装hexo框架
sudo cnpm install -g hexo-cli  #使用cnpm安装hexo框架（搭建博客用）
</code></pre>
<h1 id="-2"><a href="#-2" class="headerlink" title="======================================================================================================================="></a>=======================================================================================================================</h1><h1 id="通过下载安装"><a href="#通过下载安装" class="headerlink" title="通过下载安装"></a>通过下载安装</h1><h1 id="echo-安装QQ"><a href="#echo-安装QQ" class="headerlink" title="echo 安装QQ"></a>echo 安装QQ</h1><h1 id="wget-http-down-qq-com-qqweb-LinuxQQ-linuxqq-2-0-0-b2-1084-x86-64-pkg-tar-xz"><a href="#wget-http-down-qq-com-qqweb-LinuxQQ-linuxqq-2-0-0-b2-1084-x86-64-pkg-tar-xz" class="headerlink" title="wget http://down.qq.com/qqweb/LinuxQQ/linuxqq_2.0.0-b2-1084_x86_64.pkg.tar.xz"></a>wget <a href="http://down.qq.com/qqweb/LinuxQQ/linuxqq_2.0.0-b2-1084_x86_64.pkg.tar.xz">http://down.qq.com/qqweb/LinuxQQ/linuxqq_2.0.0-b2-1084_x86_64.pkg.tar.xz</a></h1><h1 id="sudo-pacman-U-–noconfirm-linuxqq-2-0-0-b2-1084-x86-64-pkg-tar-xz"><a href="#sudo-pacman-U-–noconfirm-linuxqq-2-0-0-b2-1084-x86-64-pkg-tar-xz" class="headerlink" title="sudo pacman -U –noconfirm linuxqq_2.0.0-b2-1084_x86_64.pkg.tar.xz"></a>sudo pacman -U –noconfirm linuxqq_2.0.0-b2-1084_x86_64.pkg.tar.xz</h1><h1 id="-3"><a href="#-3" class="headerlink" title="========================================================="></a>=========================================================</h1><pre><code># &lt;追加配置文件&gt;
</code></pre>
<h1 id="配置jAVA-HOME"><a href="#配置jAVA-HOME" class="headerlink" title="配置jAVA_HOME"></a>配置jAVA_HOME</h1><pre><code>sudo echo &#39;# export JAVA_HOME=/usr/lib/jvm/java-8-openjdk&#39; &gt;&gt; /etc/profile
sudo echo &#39;export JAVA_HOME=/usr/lib/jvm/java-11-openjdk&#39; &gt;&gt; /etc/profile
sudo echo &#39;export JRE_HOME=$&#123;JAVA_HOME&#125;/jre&#39; &gt;&gt; /etc/profile
sudo echo &#39;export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib&#39; &gt;&gt; /etc/profile
sudo echo &#39;export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH&#39; &gt;&gt; /etc/profile
</code></pre>
<h1 id="export-JAVA-HOME-usr-lib-jvm-java-8-openjdk"><a href="#export-JAVA-HOME-usr-lib-jvm-java-8-openjdk" class="headerlink" title="export JAVA_HOME=/usr/lib/jvm/java-8-openjdk"></a>export JAVA_HOME=/usr/lib/jvm/java-8-openjdk</h1><h1 id="export-JAVA-HOME-usr-lib-jvm-java-15-openjdk"><a href="#export-JAVA-HOME-usr-lib-jvm-java-15-openjdk" class="headerlink" title="export JAVA_HOME=/usr/lib/jvm/java-15-openjdk"></a>export JAVA_HOME=/usr/lib/jvm/java-15-openjdk</h1><h1 id="export-JAVA-HOME-usr-lib-jvm-java-11-openjdk"><a href="#export-JAVA-HOME-usr-lib-jvm-java-11-openjdk" class="headerlink" title="export JAVA_HOME=/usr/lib/jvm/java-11-openjdk"></a>export JAVA_HOME=/usr/lib/jvm/java-11-openjdk</h1><h1 id="export-JRE-HOME-JAVA-HOME-jre"><a href="#export-JRE-HOME-JAVA-HOME-jre" class="headerlink" title="export JRE_HOME=${JAVA_HOME}/jre"></a>export JRE_HOME=${JAVA_HOME}/jre</h1><h1 id="export-CLASSPATH-JAVA-HOME-lib-JRE-HOME-lib"><a href="#export-CLASSPATH-JAVA-HOME-lib-JRE-HOME-lib" class="headerlink" title="export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib"></a>export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib</h1><h1 id="export-PATH-JAVA-HOME-bin-PATH"><a href="#export-PATH-JAVA-HOME-bin-PATH" class="headerlink" title="export PATH=${JAVA_HOME}/bin:$PATH"></a>export PATH=${JAVA_HOME}/bin:$PATH</h1><h1 id="-4"><a href="#-4" class="headerlink" title="========================================================="></a>=========================================================</h1><pre><code># fcitx5的配置
</code></pre>
<h1 id="sudo-echo-‘GTK-IM-MODULE-DEFAULT-fcitx’-gt-gt-pam-environment"><a href="#sudo-echo-‘GTK-IM-MODULE-DEFAULT-fcitx’-gt-gt-pam-environment" class="headerlink" title="sudo echo ‘GTK_IM_MODULE DEFAULT=fcitx’ &gt;&gt; ~/.pam_environment"></a>sudo echo ‘GTK_IM_MODULE DEFAULT=fcitx’ &gt;&gt; ~/.pam_environment</h1><h1 id="sudo-echo-‘QT-IM-MODULE-DEFAULT-fcitx’-gt-gt-pam-environment"><a href="#sudo-echo-‘QT-IM-MODULE-DEFAULT-fcitx’-gt-gt-pam-environment" class="headerlink" title="sudo echo ‘QT_IM_MODULE  DEFAULT=fcitx’ &gt;&gt; ~/.pam_environment"></a>sudo echo ‘QT_IM_MODULE  DEFAULT=fcitx’ &gt;&gt; ~/.pam_environment</h1><h1 id="sudo-echo-‘XMODIFIERS-DEFAULT-im-fcitx’-gt-gt-pam-environment"><a href="#sudo-echo-‘XMODIFIERS-DEFAULT-im-fcitx’-gt-gt-pam-environment" class="headerlink" title="sudo echo ‘XMODIFIERS    DEFAULT=@im=fcitx’ &gt;&gt; ~/.pam_environment"></a>sudo echo ‘XMODIFIERS    DEFAULT=@im=fcitx’ &gt;&gt; ~/.pam_environment</h1><h1 id="sudo-echo-‘SDL-IM-MODULE-DEFAULT-fcitx’-gt-gt-pam-environment"><a href="#sudo-echo-‘SDL-IM-MODULE-DEFAULT-fcitx’-gt-gt-pam-environment" class="headerlink" title="sudo echo ‘SDL_IM_MODULE DEFAULT=fcitx’ &gt;&gt; ~/.pam_environment"></a>sudo echo ‘SDL_IM_MODULE DEFAULT=fcitx’ &gt;&gt; ~/.pam_environment</h1><h1 id="sudo-echo-‘QT-IM-MODULE-fcitx5’-gt-gt-xprofile-wps用户"><a href="#sudo-echo-‘QT-IM-MODULE-fcitx5’-gt-gt-xprofile-wps用户" class="headerlink" title="sudo echo ‘QT_IM_MODULE=fcitx5’ &gt;&gt; ~/.xprofile  #wps用户"></a>sudo echo ‘QT_IM_MODULE=fcitx5’ &gt;&gt; ~/.xprofile  #wps用户</h1><h1 id="-5"><a href="#-5" class="headerlink" title="========================================================="></a>=========================================================</h1><pre><code>#fcitx的配置
sudo echo -e &quot;export GTK_IM_MODULE=fcitx\n export QT_IM_MODULE=fcitx\n export XMODIFIERS=@im=fcitx&quot; &gt;&gt;~/.xprofile
</code></pre>
<h1 id="docker"><a href="#docker" class="headerlink" title="=========================================================docker"></a>=========================================================docker</h1><pre><code>sudo groupadd docker #添加docker用户组
sudo gpasswd -a $USER docker #将登陆用户加入到docker用户组中
newgrp docker #更新用户组
sudo systemctl enable docker
</code></pre>
<h1 id="-6"><a href="#-6" class="headerlink" title="========================================================="></a>=========================================================</h1><h1 id="需要替换的配置文件-ZSH-THEME-”agnoster”-zshrc"><a href="#需要替换的配置文件-ZSH-THEME-”agnoster”-zshrc" class="headerlink" title="需要替换的配置文件 ZSH_THEME=”agnoster”              ./.zshrc"></a>需要替换的配置文件 ZSH_THEME=”agnoster”              ./.zshrc</h1><h1 id="plugins"><a href="#plugins" class="headerlink" title="plugins=("></a>plugins=(</h1><h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><h1 id="zsh-autosuggestions"><a href="#zsh-autosuggestions" class="headerlink" title="zsh-autosuggestions"></a>zsh-autosuggestions</h1><h1 id="-7"><a href="#-7" class="headerlink" title=")"></a>)</h1><h1 id="-8"><a href="#-8" class="headerlink" title="========================================================="></a>=========================================================</h1><pre><code> # 配置maven仓库国内源
</code></pre>
<p>sudo mkdir -p ~/.m2<br>sudo tee ~/.m2/settings.xml &lt;&lt;-‘EOF’<br><?xml version="1.0" encoding="UTF-8"?><br><settings
xmlns="http://maven.apache.org/SETTINGS/1.0.0"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd"><br><mirrors><br><mirror><br><id>aliyunmaven</id><br><mirrorOf><em></mirrorOf><br><name>阿里云公共仓库</name><br><url><a href="https://maven.aliyun.com/repository/public">https://maven.aliyun.com/repository/public</a></url><br></mirror><br><mirror><br><id>nexus-tencentyun</id><br><mirrorOf></em></mirrorOf><br><name>Nexus tencentyun</name><br><url><a href="http://mirrors.cloud.tencent.com/nexus/repository/maven-public/">http://mirrors.cloud.tencent.com/nexus/repository/maven-public/</a></url><br></mirror><br><mirror><br><id>huaweicloud</id><br><mirrorOf><em></mirrorOf><br><url><a href="https://mirrors.huaweicloud.com/repository/maven/">https://mirrors.huaweicloud.com/repository/maven/</a></url><br></mirror><br><mirror><br><id>nexus-163</id><br><mirrorOf></em></mirrorOf><br><name>Nexus 163</name><br><url><a href="http://mirrors.163.com/maven/repository/maven-public/">http://mirrors.163.com/maven/repository/maven-public/</a></url><br></mirror><br></mirrors><br></settings><br>EOF<br>echo 成功安装完成！<br>exit 1<br>fi</p>
<h1 id="-9"><a href="#-9" class="headerlink" title="=========================================="></a>==========================================</h1><h1 id="yay安装"><a href="#yay安装" class="headerlink" title="yay安装"></a>yay安装</h1><h1 id="yay-S-–noconfirm-xdman"><a href="#yay-S-–noconfirm-xdman" class="headerlink" title="yay -S –noconfirm xdman"></a>yay -S –noconfirm xdman</h1><h1 id="yay-S-–noconfirm-typora"><a href="#yay-S-–noconfirm-typora" class="headerlink" title="yay -S –noconfirm typora"></a>yay -S –noconfirm typora</h1><h1 id="yay-S-–noconfirm-deepin-wine-wechat-deepin-wine-qq"><a href="#yay-S-–noconfirm-deepin-wine-wechat-deepin-wine-qq" class="headerlink" title="yay -S –noconfirm deepin-wine-wechat deepin-wine-qq"></a>yay -S –noconfirm deepin-wine-wechat deepin-wine-qq</h1><pre><code> yay -S --noconfirm xunlei-bin
</code></pre>
<p>yay -S –noconfirm utools<br>yay -S –noconfirm balena-etcher<br>yay -S –noconfirm fcitx-sogoupinyin</p>
<h1 id="yay-S-–noconfirm-wps-office-cn"><a href="#yay-S-–noconfirm-wps-office-cn" class="headerlink" title="yay -S –noconfirm wps-office-cn"></a>yay -S –noconfirm wps-office-cn</h1><h1 id="yay-S-–noconfirm-wps-office-mui-zh-cn"><a href="#yay-S-–noconfirm-wps-office-mui-zh-cn" class="headerlink" title="yay -S –noconfirm wps-office-mui-zh-cn"></a>yay -S –noconfirm wps-office-mui-zh-cn</h1><h1 id="yay-S-–noconfirm-fcitx-qt4-kcm-fcitx-fcitx-sogoupinyin"><a href="#yay-S-–noconfirm-fcitx-qt4-kcm-fcitx-fcitx-sogoupinyin" class="headerlink" title="yay -S –noconfirm fcitx-qt4 kcm-fcitx fcitx-sogoupinyin"></a>yay -S –noconfirm fcitx-qt4 kcm-fcitx fcitx-sogoupinyin</h1><p>yay -S –noconfirm intellij-idea-ultimate-edition-jre<br>yay -S –noconfirm intellij-idea-ultimate-edition</p>
<h1 id="-10"><a href="#-10" class="headerlink" title="========================================"></a>========================================</h1><h1 id="配置oymyzsh"><a href="#配置oymyzsh" class="headerlink" title="配置oymyzsh"></a>配置oymyzsh</h1><pre><code>sudo pacman -S --noconfirm unzip
</code></pre>
<h1 id="zsh-syntax-highlighting插件"><a href="#zsh-syntax-highlighting插件" class="headerlink" title="zsh-syntax-highlighting插件"></a>zsh-syntax-highlighting插件</h1><p>git clone –depth=1 <a href="https://github.com.cnpmjs.org/zsh-users/zsh-syntax-highlighting.git">https://github.com.cnpmjs.org/zsh-users/zsh-syntax-highlighting.git</a> ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting</p>
<h1 id="zsh-autosuggestions-插件"><a href="#zsh-autosuggestions-插件" class="headerlink" title="zsh-autosuggestions 插件"></a>zsh-autosuggestions 插件</h1><p>git clone –depth=1 <a href="https://github.com.cnpmjs.org/zsh-users/zsh-autosuggestions.git">https://github.com.cnpmjs.org/zsh-users/zsh-autosuggestions.git</a> ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions</p>
<p>sudo rm -rf ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/</p>
<h1 id="vscode-插件"><a href="#vscode-插件" class="headerlink" title="vscode 插件"></a>vscode 插件</h1><p>git clone –depth=1 <a href="https://hub.fastgit.org/valentinocossar/vscode.git">https://hub.fastgit.org/valentinocossar/vscode.git</a> ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/vscode</p>
<h1 id="powerlevel10k主题"><a href="#powerlevel10k主题" class="headerlink" title="powerlevel10k主题"></a>powerlevel10k主题</h1><h1 id="git-clone-–depth-1-https-gitee-com-romkatv-powerlevel10k-git-ZSH-CUSTOM-HOME-oh-my-zsh-custom-themes-powerlevel10k"><a href="#git-clone-–depth-1-https-gitee-com-romkatv-powerlevel10k-git-ZSH-CUSTOM-HOME-oh-my-zsh-custom-themes-powerlevel10k" class="headerlink" title="git clone –depth=1 https://gitee.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k"></a>git clone –depth=1 <a href="https://gitee.com/romkatv/powerlevel10k.git">https://gitee.com/romkatv/powerlevel10k.git</a> ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k</h1><p>cat &gt;&gt; ~/.zshrc &lt;&lt; ‘EOF’</p>
<h1 id="-11"><a href="#-11" class="headerlink" title="========================================"></a>========================================</h1><h1 id="得删除原有的"><a href="#得删除原有的" class="headerlink" title="得删除原有的"></a>得删除原有的</h1><p>ZSH_THEME=”agnoster”<br>plugins=(<br>git<br>zsh-syntax-highlighting<br>zsh-autosuggestions<br>vscode<br>)</p>
<h1 id="-12"><a href="#-12" class="headerlink" title="========================================"></a>========================================</h1><h1 id="如果安装了powerlevel10k-powerlevel10k则取消下边注释"><a href="#如果安装了powerlevel10k-powerlevel10k则取消下边注释" class="headerlink" title="如果安装了powerlevel10k/powerlevel10k则取消下边注释"></a>如果安装了powerlevel10k/powerlevel10k则取消下边注释</h1><h1 id="POWERLEVEL9K-MODE-”awesome-patched”"><a href="#POWERLEVEL9K-MODE-”awesome-patched”" class="headerlink" title="POWERLEVEL9K_MODE=”awesome-patched”"></a>POWERLEVEL9K_MODE=”awesome-patched”</h1><h1 id="-13"><a href="#-13" class="headerlink" title="========================================"></a>========================================</h1><h1 id="backup-解决ohmyzsh卡"><a href="#backup-解决ohmyzsh卡" class="headerlink" title="backup 解决ohmyzsh卡"></a>backup 解决ohmyzsh卡</h1><h1 id="This-speeds-up-pasting-w-autosuggest"><a href="#This-speeds-up-pasting-w-autosuggest" class="headerlink" title="This speeds up pasting w/ autosuggest"></a>This speeds up pasting w/ autosuggest</h1><h1 id="https-github-com-zsh-users-zsh-autosuggestions-issues-238"><a href="#https-github-com-zsh-users-zsh-autosuggestions-issues-238" class="headerlink" title="https://github.com/zsh-users/zsh-autosuggestions/issues/238"></a><a href="https://github.com/zsh-users/zsh-autosuggestions/issues/238">https://github.com/zsh-users/zsh-autosuggestions/issues/238</a></h1><p>pasteinit() {</p>
<p>OLD_SELF_INSERT=${${(s.:.)widgets[self-insert]}[2,3]}</p>
<p>zle -N self-insert url-quote-magic # I wonder if you’d need <code>.url-quote-magic</code>?</p>
<p>}</p>
<p>pastefinish() {</p>
<p>zle -N self-insert $OLD_SELF_INSERT</p>
<p>}</p>
<p>zstyle :bracketed-paste-magic paste-init pasteinit</p>
<p>zstyle :bracketed-paste-magic paste-finish pastefinish</p>
<h1 id="https-github-com-zsh-users-zsh-autosuggestions-issues-351"><a href="#https-github-com-zsh-users-zsh-autosuggestions-issues-351" class="headerlink" title="https://github.com/zsh-users/zsh-autosuggestions/issues/351"></a><a href="https://github.com/zsh-users/zsh-autosuggestions/issues/351">https://github.com/zsh-users/zsh-autosuggestions/issues/351</a></h1><p>ZSH_AUTOSUGGEST_CLEAR_WIDGETS+=(bracketed-paste)</p>
<h1 id="-14"><a href="#-14" class="headerlink" title="============================================="></a>=============================================</h1><p>EOF</p>
<h1 id="sudo-xed-tmp-Manjaro-linux-config-txt"><a href="#sudo-xed-tmp-Manjaro-linux-config-txt" class="headerlink" title="sudo xed /tmp/Manjaro-linux/config.txt"></a>sudo xed /tmp/Manjaro-linux/config.txt</h1><pre><code>sudo kate ~/.zshrc

echo 设置主题和更改插件 
echo 正在清理残余文件
sudo rm -f -r /tmp/Manjaro-linux/
</code></pre>
]]></content>
      <categories>
        <category>manjaro</category>
      </categories>
      <tags>
        <tag>manjaro</tag>
      </tags>
  </entry>
  <entry>
    <title>docker手册</title>
    <url>/2020/07/30/docker%E6%89%8B%E5%86%8C/docker%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h1 id="docker手册"><a href="#docker手册" class="headerlink" title="docker手册"></a>docker手册</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 容器复制到宿主</span></span><br><span class="line">docker cp  容器id:容器目录 宿主目录</span><br><span class="line"><span class="comment">#宿主复制到容器</span></span><br><span class="line">docker cp  容器id:容器目录 宿主目录</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//登录docker Hub</span><br><span class="line">docker login Username: zjarlin Password: 密码 Email:zjarlin@outlook.com </span><br><span class="line"></span><br><span class="line">//上传镜像</span><br><span class="line">docker push easyswoole:1.0</span><br></pre></td></tr></table></figure>

<p>一、 docker 服务启动启动</p>
<pre><code># 开启 docker 自启动
systemctl enable docker.service
 
# 关闭 docker 自启动
systemctl disable docker.service
</code></pre>
<p>二、docker 容器自动启动</p>
<pre><code># 开启容器自启动
docker update --restart=always 【容器名】
例如：docker update --restart=always tracker
</code></pre>
<p>​<br>​    # 关闭容器自启动<br>​    docker update –restart=no【容器名】<br>​    例如：docker update –restart=no tracker<br>​<br>    ##### 相关配置解析<br>    no：<br>        不要自动重启容器。（默认）</p>
<pre><code>on-failure： 
    如果容器由于错误而退出，则重新启动容器，该错误表现为非零退出代码。
 
always：
    如果容器停止，请务必重启容器。如果手动停止，则仅在Docker守护程序重新启动或手动重新启动容器本身时才重新启动。（参见重启政策详情中列出的第二个项目）
 
unless-stopped：
    类似于always，除了当容器停止（手动或其他方式）时，即使在Docker守护程序重新启动后也不会重新启动容器。
</code></pre>
<h1 id="docker启动mysql"><a href="#docker启动mysql" class="headerlink" title="docker启动mysql"></a>docker启动mysql</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -p 3306:3306 --name mysql \</span><br><span class="line">-v /mydata/mysql/<span class="built_in">log</span>:/var/<span class="built_in">log</span>/mysql \</span><br><span class="line">-v /mydata/mysql/data:/var/lib/mysql \</span><br><span class="line">-v /mydata/mysql/conf:/etc/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root \</span><br><span class="line">-d mysql:5.7</span><br></pre></td></tr></table></figure>



<h1 id="docker启动redis"><a href="#docker启动redis" class="headerlink" title="docker启动redis"></a>docker启动redis</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -itd --name redis-test -p 6379:6379 redis</span><br></pre></td></tr></table></figure>

<p>#docker启动node</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -it node /bin/bash</span><br></pre></td></tr></table></figure>





<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//启动docker</span><br><span class="line">systemctl start docker</span><br><span class="line">//停止docker</span><br><span class="line">systemctl stop docker</span><br><span class="line">//查看docker是否启动</span><br><span class="line">systemctl status docker</span><br><span class="line">//设置开机自动启动</span><br><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>2.5 容器的操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1. 运行容器</span><br><span class="line"># 简单操作</span><br><span class="line">docker run 镜像的标识|镜像名称[tag]</span><br><span class="line"># 常用的参数</span><br><span class="line">docker run -d -p  宿主机端口:容器端口 --name 容器名称 镜像的标识|镜像名称[tag]</span><br><span class="line"># -d: 代表后台运行容器</span><br><span class="line"># -p: 宿主机端口:容器端口: 为了映射当前Linux的端口和容器的端口</span><br><span class="line"># --name 容器名称: 指定容器的名称</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 2. 查看正在运行的容器</span><br><span class="line">docker ps [OPTIONS]</span><br><span class="line"> OPTIONS说明:</span><br><span class="line"> -a: 代表查看全部的容器，包括没有运行</span><br><span class="line">-q: 只查看容器的标识</span><br><span class="line">-f: 根据条件过滤显示的内容</span><br><span class="line">--format: 指定返回值的模板文件</span><br><span class="line">-l: 显示最近创建的容器</span><br><span class="line">-n: 列出最近创建的n个容器</span><br><span class="line">--no-trunc: 不截断输出</span><br><span class="line">-s: 显示总的文件大小</span><br><span class="line">-i：容器的标准输入保持打开</span><br><span class="line">-t：让docker分配一个伪终端并绑定到容器的标准输入上</span><br><span class="line">-p : 端口映射 格式为[主机端口：容器端口]</span><br><span class="line">-name : 给容器的起一个名字</span><br><span class="line">-v：挂载主机的目录</span><br><span class="line">-d：容器后台运行，并返回容器ID</span><br><span class="line">-p：指定端口映射，格式为：主机（宿主）端口：容器端口</span><br><span class="line">-v：绑定一个卷，资源映射</span><br><span class="line">--name：给容器命名</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 3. 查看容器的日志</span><br><span class="line">docker logs -f 容器id</span><br><span class="line"># -f: 可以滚动查看日志的最后几行</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 4. 进入到容器内部</span><br><span class="line">docker exec -it 容器id bash</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 5. 删除容器(删除容器前，需要先停止容器)</span><br><span class="line">docker stop 容器id</span><br><span class="line"># 停止指定的容器</span><br><span class="line">docker stop $(docker ps -qa)</span><br><span class="line"># 停止全部容器</span><br><span class="line">docker rm 镜像id</span><br><span class="line"># 删除指定容器</span><br><span class="line">docker rm $(docker ps -qa)</span><br><span class="line"># 删除全部容器</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>docker手册</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>将Docker容器转移至另一服务器</title>
    <url>/2020/07/30/docker%E6%89%8B%E5%86%8C/docker%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB%E5%92%8C%E5%A4%87%E4%BB%BD/</url>
    <content><![CDATA[<h1 id="将Docker容器转移至另一服务器"><a href="#将Docker容器转移至另一服务器" class="headerlink" title="将Docker容器转移至另一服务器"></a>将Docker容器转移至另一服务器</h1><ul>
<li>1 把当前的容器提交为一个镜像：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker commit 容器名 镜像名</span><br></pre></td></tr></table></figure>

<ul>
<li>2 将镜像存为tar文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker save 镜像名 &gt;备份文件.tar</span><br></pre></td></tr></table></figure>

<ul>
<li>3将 备份文件.tar 复制到目的主机下</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[localhost$ ~]scp nginx.tar root@192.X.X.X:/data</span><br></pre></td></tr></table></figure>

<ul>
<li>4将 备份文件.tar恢复为镜像 ，具体用法请见docker load –help</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker load -i &lt;备份文件.tar</span><br></pre></td></tr></table></figure>

<ul>
<li>5根据镜像重新运行起容器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run  -p 81:80 --name=&#x27;容器名&#x27; -d -镜像名</span><br><span class="line"></span><br><span class="line">[这里注意暴露的端口不是当前主机在用的端口号，要不然会报错失败]</span><br></pre></td></tr></table></figure>

<p> #备份脚本</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 设置mysql的登录用户名和密码(根据实际情况填写)</span></span><br><span class="line">mysql_user=<span class="string">&quot;root&quot;</span></span><br><span class="line">mysql_password=<span class="string">&quot;root&quot;</span></span><br><span class="line"><span class="comment"># mysql_host=&quot;localhost&quot;</span></span><br><span class="line"><span class="comment"># mysql_port=&quot;3306&quot;</span></span><br><span class="line"><span class="comment"># mysql_charset=&quot;utf8mb4&quot;</span></span><br><span class="line">container_id=<span class="string">&#x27;543f03622637&#x27;</span></span><br><span class="line"><span class="comment">#dbname=&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 备份文件存放地址(根据实际情况填写)</span></span><br><span class="line"><span class="comment">#backup_dir=&#x27;/usr/local&#x27;</span></span><br><span class="line">backup_dir=~/docker-bak/</span><br><span class="line"><span class="comment"># 判断目录是不是已经存在，如果不存在则创建</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="variable">$backup_dir</span> ]; <span class="keyword">then</span></span><br><span class="line">  mkdir -p <span class="variable">$backup_dir</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment">#===================================</span></span><br><span class="line"><span class="comment"># 是否删除过期数据</span></span><br><span class="line">expire_backup_delete=<span class="string">&quot;ON&quot;</span></span><br><span class="line">expire_days=7</span><br><span class="line">backup_time=`date +%Y%m%d%H%M`</span><br><span class="line">welcome_msg=<span class="string">&quot;Welcome to use MySQL backup tools!&quot;</span></span><br><span class="line"><span class="comment">#===========================================</span></span><br><span class="line"><span class="comment"># 备份指定数据库中数据(此处假设数据库是mysql_backup_test)</span></span><br><span class="line"><span class="comment">#docker exec $container_id mysqldump -u$mysql_user -p$mysql_password -B $dbname &gt; $backup_dir/$dbname-$backup_time.sql</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#备份全部数据库</span></span><br><span class="line">docker <span class="built_in">exec</span> <span class="variable">$&#123;container_id&#125;</span> mysqldump -u<span class="variable">$&#123;mysql_user&#125;</span> -p<span class="variable">$&#123;mysql_password&#125;</span> -A &gt; <span class="variable">$&#123;backup_dir&#125;</span>/alldb-<span class="variable">$&#123;backup_time&#125;</span>.sql</span><br><span class="line"><span class="comment">#==================================================</span></span><br><span class="line">删除过期数据</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$expire_backup_delete</span>&quot;</span> == <span class="string">&quot;ON&quot;</span> -a  <span class="string">&quot;<span class="variable">$backup_dir</span>&quot;</span> != <span class="string">&quot;&quot;</span> ];<span class="keyword">then</span></span><br><span class="line">        `find <span class="variable">$backup_dir</span>/ -<span class="built_in">type</span> f -mtime +<span class="variable">$expire_days</span> | xargs rm -rf`</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Expired backup data delete complete!&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>docker手册</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>macAPP和package安装</title>
    <url>/2021/06/28/%E7%83%AD%E6%9B%B4%E6%96%B0/mac-app-package/</url>
    <content><![CDATA[<p>###########APP安装(可全选梭哈到终端安装)##########</p>
<p>################################/usr/local/Caskroom###########</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">brew install visual-studio-code --cask</span><br><span class="line"></span><br><span class="line">brew install free-download-manager --cask</span><br><span class="line"><span class="comment"># brew install bilibili --cask</span></span><br><span class="line">brew install qq --cask</span><br><span class="line">brew install  qqmusic --cask</span><br><span class="line">brew install thunder --cask</span><br><span class="line">brew install typora --cask</span><br><span class="line">brew install wechat --cask</span><br><span class="line"><span class="comment">#brew install videofusion --cask #剪映</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#brew install wechatwebdevtools --cask</span></span><br><span class="line">brew install iterm2 --cask</span><br><span class="line"><span class="comment"># defaults delete com.googlecode.iterm2</span></span><br><span class="line">brew install intellij-idea --cask</span><br><span class="line"><span class="comment">#brew install datagrip --cask</span></span><br><span class="line">brew install microsoft-excel --cask</span><br><span class="line"><span class="comment">#brew install nutstore --cask ##不确定能不能装坚果云,反正我失败了手动装</span></span><br><span class="line"><span class="comment">#brew install virtualbox --cask</span></span><br><span class="line">brew install google-chrome --cask</span><br><span class="line"></span><br><span class="line"><span class="comment">#brew install balenaetcher  --cask ##写盘工具</span></span><br><span class="line">brew install keka  --cask</span><br><span class="line">brew install sogouinput --cask;open /usr/<span class="built_in">local</span>/Caskroom/sogouinput/*/sogou_mac_*.app</span><br><span class="line">brew install datagrip --cask</span><br><span class="line"><span class="comment">#下载特别慢的执行</span></span><br><span class="line"><span class="comment">#走代理输入: export ALL_PROXY=socks5://127.0.0.1:1080 </span></span><br><span class="line"><span class="comment">#brew install sublime-text --cask</span></span><br><span class="line"><span class="comment">#brew install microsoft-edge --cask</span></span><br><span class="line">brew install ngrok --cask</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p>###############/usr/local/Cellar########################          </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew install zsh-syntax-highlighting zsh-autosuggestions <span class="comment">#zsh插件环境已配好了</span></span><br><span class="line">brew install ranger</span><br><span class="line"><span class="comment">#ranger --copy-config=all</span></span><br><span class="line">brew install maven</span><br><span class="line">brew install neovim</span><br><span class="line"><span class="comment">#brew install gradle</span></span><br></pre></td></tr></table></figure>



<p>#安装jdk8</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew install openjdk@8 </span><br><span class="line"><span class="comment">#建立软连接</span></span><br><span class="line">sudo ln -sfn /usr/<span class="built_in">local</span>/opt/openjdk@8/libexec/openjdk.jdk /Library/Java/JavaVirtualMachines/openjdk-8.jdk</span><br></pre></td></tr></table></figure>

<p>#安装jdk11</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew install openjdk@11</span><br><span class="line"><span class="comment">#建立软连接</span></span><br><span class="line">sudo ln -sfn /usr/<span class="built_in">local</span>/opt/openjdk@11/libexec/openjdk.jdk /Library/Java/JavaVirtualMachines/openjdk-11.jdk</span><br><span class="line">brew install maven</span><br></pre></td></tr></table></figure>





<p>#git换源</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#brew脚本安装时会自己安装git</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="subst">$(brew --repo)</span>&quot;</span></span><br><span class="line">git remote set-url origin https://mirrors.ustc.edu.cn/brew.git</span><br><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="subst">$(brew --repo)</span>/Library/Taps/homebrew/homebrew-core&quot;</span></span><br><span class="line">git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git</span><br><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="subst">$(brew --repo)</span>/Library/Taps/homebrew/homebrew-cask&quot;</span></span><br><span class="line">git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask.git</span><br><span class="line">brew update</span><br></pre></td></tr></table></figure>

<p>#<strong>yabai</strong> 平铺式桌面安装</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew tap koekeishiya/formulae</span><br><span class="line">brew install yabai</span><br><span class="line"><span class="comment"># start yabai as a service</span></span><br><span class="line">brew services start koekeishiya/formulae/yabai <span class="comment">#配置就是用软链接配置的</span></span><br></pre></td></tr></table></figure>

<p>#安装nodejs和npm</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew install nodejs</span><br><span class="line"><span class="comment"># 换源</span></span><br><span class="line">sudo npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br><span class="line">npm config <span class="built_in">set</span> disturl https://npm.taobao.org/dist --global</span><br><span class="line"><span class="comment"># 这里不建议装cnpm会出问题</span></span><br><span class="line"><span class="comment">#sudo npm install -g cnpm --registry=https://registry.npm.taobao.org</span></span><br></pre></td></tr></table></figure>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>#npm安装管理版本工具n</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install -g n</span><br><span class="line"><span class="comment"># 切换版本 sudo n 这里填版本号</span></span><br><span class="line"><span class="comment"># 例:</span></span><br><span class="line"><span class="comment"># sudo n 14.15.0</span></span><br><span class="line"><span class="comment"># sudo n 12.22.2</span></span><br><span class="line"><span class="comment"># 列出所有node版本</span></span><br><span class="line"><span class="comment"># n ls-remote --all</span></span><br><span class="line"><span class="comment"># n ls</span></span><br></pre></td></tr></table></figure>

<p>#npm安装yarn</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install -g yarn</span><br></pre></td></tr></table></figure>

<p>#npm安装vue</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br></pre></td></tr></table></figure>

<p>#npm安装hexo(博客框架)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g </span><br></pre></td></tr></table></figure>

<p>#docker</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew install docker --cask </span><br><span class="line"><span class="comment">#mysql </span></span><br><span class="line"><span class="comment">#docker pull centos/mysql-57-centos7</span></span><br><span class="line">docker run -p 3306:3306 --name mysql \</span><br><span class="line">-v /mydata/mysql/<span class="built_in">log</span>:/var/<span class="built_in">log</span>/mysql \</span><br><span class="line">-v /mydata/mysql/data:/var/lib/mysql \</span><br><span class="line">-v /mydata/mysql/conf:/etc/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root \</span><br><span class="line">-d mysql:5.7</span><br><span class="line"><span class="comment">#redis</span></span><br><span class="line">docker run -itd --name redis-test -p 6379:6379 redis</span><br><span class="line"><span class="comment">#ngnix</span></span><br><span class="line">docker pull nginx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>mac可选配置</title>
    <url>/2021/06/28/%E7%83%AD%E6%9B%B4%E6%96%B0/mac%E5%8F%AF%E9%80%89%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">defaults write com.apple.finder _FXShowPosixPathInTitle -bool YES</span><br></pre></td></tr></table></figure>

<p>#始终显示用户「资料库」(小白不建议)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">chflags nohidden ~/Library/</span><br></pre></td></tr></table></figure>

<p>#开启hidpi(黑果用,白果别用这个,所以我注释掉了)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#sh -c &quot;$(curl -fsSL https://html.sqlsec.com/hidpi.sh)&quot;</span></span><br></pre></td></tr></table></figure>

<p>#这里改放入github的ip映射地址(反正我改了没用,就不往上写了)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo tee &gt;&gt; /etc/hosts &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># GitHub Start</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># GitHub End</span></span><br><span class="line">EOF</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>#设置DNS(试了好像不管用)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看所有网络连接</span></span><br><span class="line">networksetup -listallnetworkservices</span><br><span class="line"></span><br><span class="line">networksetup -getdnsservers Ethernet 8.8.8.8 8.8.4.4 114.114.114.114  4.2.2.2  4.2.2.1</span><br><span class="line"></span><br><span class="line">Ethernet</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>新mac配置脚本</title>
    <url>/2021/06/28/%E7%83%AD%E6%9B%B4%E6%96%B0/%E6%96%B0mac%E9%85%8D%E7%BD%AE%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<p>#安装brew</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/bin/zsh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>#安装字体</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span></span><br><span class="line">git <span class="built_in">clone</span> https://gitee.com/zjarlin/some-fonts.git ~/GitRepository</span><br><span class="line"><span class="built_in">cd</span> ~/GitRepository</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装	font-jetbrains-mono-nerd-font</span></span><br><span class="line"><span class="built_in">cd</span> ~/GitRepository/some-fonts/font-jetbrains-mono-nerd-font</span><br><span class="line">cp ./* ~/Library/Fonts</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装 sarasa-mono-sc-nerd</span></span><br><span class="line"><span class="comment">#cd ~/GitRepository/some-fonts/sarasa-mono-sc-nerd</span></span><br><span class="line"><span class="comment">#cp ./* ~/Library/Fonts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#安装 font-awesome</span></span><br><span class="line"><span class="comment">#cd ~/GitRepository/some-fonts/font-awesome</span></span><br><span class="line"><span class="comment">#cp ./* ~/Library/Fonts</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>#需要先安装坚果云,配置环境的核心就是下边的代码建立软连接</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span></span><br><span class="line">mkdir -p .gradle</span><br><span class="line">mkdir -p .docker</span><br><span class="line">mkdir -p .ngrok</span><br><span class="line">mkdir -p .vim</span><br><span class="line">mkdir -p .config</span><br><span class="line">mkdir -p .config/nvim</span><br><span class="line">mkdir -p .config/ranger</span><br><span class="line">mkdir -p .m2/repository </span><br><span class="line">mkdir -p DockerBak</span><br><span class="line"><span class="comment">#ln -snf A/.* ~ ,这个命令的意思就是把A目录下所有隐藏文件都映射到家目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#======================功能介绍</span></span><br><span class="line"><span class="comment">#各种环境变量的配置</span></span><br><span class="line"><span class="comment">#配置了alias别名可以使用如下操作</span></span><br><span class="line"><span class="comment"># idea 跟路径 #使用idea打开</span></span><br><span class="line"><span class="comment"># sb 跟路径 #使用sublime打开</span></span><br><span class="line"><span class="comment">#======================功能介绍</span></span><br><span class="line"><span class="comment">#这些链接好处就是你频繁修改也能同步,而且你git push到你的仓库也能复用(省去每次提交变更)</span></span><br><span class="line"><span class="comment">#环境变量配置</span></span><br><span class="line">ln -snf ~/Nutstore\ Files/我的坚果云/config-mac/.~config/.* ~</span><br><span class="line"><span class="comment">#gradle配置</span></span><br><span class="line">ln -snf  ~/Nutstore\ Files/我的坚果云/config-mac/.gradle/* ~/.gradle/</span><br><span class="line"><span class="comment">#docker配置</span></span><br><span class="line">ln -snf  ~/Nutstore\ Files/我的坚果云/config-mac/.docker/* ~/.docker/</span><br><span class="line"><span class="comment">#ngrok内网穿透配置</span></span><br><span class="line">ln -snf  ~/Nutstore\ Files/我的坚果云/config-mac/.ngrok/* ~/.ngrok/</span><br><span class="line"><span class="comment">#maven仓库及阿里源配置(这里千万不要把整个.m2软链接过去,不然你的坚果云会存储所有仓库的jar包=.=)</span></span><br><span class="line">ln -snf  ~/Nutstore\ Files/我的坚果云/config-mac/.m2/settings.xml ~/.m2/</span><br><span class="line">ln -snf  ~/Nutstore\ Files/我的坚果云/config-mac/.m2/repository/archetype-catalog.xml  ~/.m2/repository/</span><br><span class="line"><span class="comment">#docker镜像源配置</span></span><br><span class="line">ln -snf  ~/Nutstore\ Files/我的坚果云/config-mac/DockerBak/bakDockerMysql.sh ~/DockerBak</span><br><span class="line"><span class="comment">#vim及neovim配置(方案1)</span></span><br><span class="line">ln -snf ~/Nutstore\ Files/我的坚果云/config-mac/.vim ~</span><br><span class="line">ln -snf ~/Nutstore\ Files/我的坚果云/config-mac/.vim/*	~/.config/nvim		</span><br><span class="line">ln -snf ~/Nutstore\ Files/我的坚果云/config-mac/.config/nvim/* ~/.config/nvim</span><br><span class="line">ln -snf ~/Nutstore\ Files/我的坚果云/config-mac/.config/nvim/* ~/.vimrc</span><br><span class="line"><span class="comment">#ranger配置</span></span><br><span class="line">ln -snf ~/Nutstore\ Files/我的坚果云/config-mac/.config/ranger/* ~/.config/ranger</span><br><span class="line"></span><br><span class="line"><span class="comment">#vim及neovim配置(方案2,在坚果云自建软链接,再连接到家目录,不推荐!,会有传递依赖!)						</span></span><br><span class="line"><span class="comment">#ln -snf ~/Nutstore\ Files/我的坚果云/config-mac/.vim ~</span></span><br><span class="line"><span class="comment">#ln -snf ~/Nutstore\ Files/我的坚果云/config-mac/.vim/* ~/Nutstore\ Files/我的坚果云/config-mac/.config/nvim</span></span><br><span class="line"><span class="comment">#ln -snf ~/Nutstore\ Files/我的坚果云/config-mac/.config/nvim/* ~/.config/nvim</span></span><br><span class="line"><span class="comment">#ln -snf ~/Nutstore\ Files/我的坚果云/config-mac/.config/nvim/init.vim ~/.vimrc</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>#ohmyzsh安装及配置</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://gitee.com/hubmirror/ohmyzsh/blob/master/oh-my-zsh.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>#更换终端为zsh</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure>

<p>#修复权限</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">chmod -R 777 .oh-my-zsh</span><br></pre></td></tr></table></figure>

<p>#Mac -&gt; linux sed命令映射</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew install gnu-sed</span><br><span class="line">PATH=<span class="string">&quot;/usr/local/opt/gnu-sed/libexec/gnubin:<span class="variable">$PATH</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>#<strong>mac</strong> 设置一位密码</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pwpolicy -clearaccountpolicies </span><br></pre></td></tr></table></figure>



<p>#进入gitee仓库路径克隆config-mac—&gt;(给其他人看)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#基础环境准备,建立仓库</span></span><br><span class="line"><span class="comment">#cd #什么也不填默认进入家目录</span></span><br><span class="line"><span class="comment">#git clone https://gitee.com/zjarlin/config-mac.git</span></span><br><span class="line"><span class="comment">#mv config-mac ~/Nutstore\ Files/我的坚果云/</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>File类、递归</title>
    <url>/2020/08/06/Java%20%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/File%E7%B1%BB%E3%80%81%E9%80%92%E5%BD%92/day08%E3%80%90File%E7%B1%BB%E3%80%81%E9%80%92%E5%BD%92%E3%80%91/</url>
    <content><![CDATA[<h1 id="day08【File类、递归】"><a href="#day08【File类、递归】" class="headerlink" title="day08【File类、递归】"></a>day08【File类、递归】</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li> File类</li>
<li> 递归</li>
</ul>
<h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><ul>
<li><input disabled="" type="checkbox"> 能够说出File对象的创建方式</li>
<li><input disabled="" type="checkbox"> 能够说出File类获取名称的方法名称</li>
<li><input disabled="" type="checkbox"> 能够说出File类获取绝对路径的方法名称</li>
<li><input disabled="" type="checkbox"> 能够说出File类获取文件大小的方法名称</li>
<li><input disabled="" type="checkbox"> 能够说出File类判断是否是文件的方法名称</li>
<li><input disabled="" type="checkbox"> 能够说出File类判断是否是文件夹的方法名称</li>
<li><input disabled="" type="checkbox"> 能够辨别相对路径和绝对路径</li>
<li><input disabled="" type="checkbox"> 能够遍历文件夹</li>
<li><input disabled="" type="checkbox"> 能够解释递归的含义</li>
<li><input disabled="" type="checkbox"> 能够使用递归的方式计算5的阶乘</li>
<li><input disabled="" type="checkbox"> 能够说出使用递归会内存溢出隐患的原因</li>
</ul>
<h1 id="第一章-File类"><a href="#第一章-File类" class="headerlink" title="第一章 File类"></a>第一章 File类</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p><code>java.io.File</code> 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。</p>
<h2 id="1-2-构造方法"><a href="#1-2-构造方法" class="headerlink" title="1.2 构造方法"></a>1.2 构造方法</h2><ul>
<li><code>public File(String pathname) </code> ：通过将给定的<strong>路径名字符串</strong>转换为抽象路径名来创建新的 File实例。  </li>
<li><code>public File(String parent, String child) </code> ：从<strong>父路径名字符串和子路径名字符串</strong>创建新的 File实例。</li>
<li><code>public File(File parent, String child)</code> ：从<strong>父抽象路径名和子路径名字符串</strong>创建新的 File实例。  </li>
</ul>
<ul>
<li>构造举例，代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件路径名</span></span><br><span class="line">String pathname = <span class="string">&quot;D:\\aaa.txt&quot;</span>;</span><br><span class="line">File file1 = <span class="keyword">new</span> File(pathname); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件路径名</span></span><br><span class="line">String pathname2 = <span class="string">&quot;D:\\aaa\\bbb.txt&quot;</span>;</span><br><span class="line">File file2 = <span class="keyword">new</span> File(pathname2); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过父路径和子路径字符串</span></span><br><span class="line"> String parent = <span class="string">&quot;d:\\aaa&quot;</span>;</span><br><span class="line"> String child = <span class="string">&quot;bbb.txt&quot;</span>;</span><br><span class="line"> File file3 = <span class="keyword">new</span> File(parent, child);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过父级File对象和子路径字符串</span></span><br><span class="line">File parentDir = <span class="keyword">new</span> File(<span class="string">&quot;d:\\aaa&quot;</span>);</span><br><span class="line">String child = <span class="string">&quot;bbb.txt&quot;</span>;</span><br><span class="line">File file4 = <span class="keyword">new</span> File(parentDir, child);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：</p>
<ol>
<li>一个File对象代表硬盘中实际存在的一个文件或者目录。</li>
<li>无论该路径下是否存在文件或者目录，都不影响File对象的创建。</li>
</ol>
</blockquote>
<h2 id="1-3-常用方法"><a href="#1-3-常用方法" class="headerlink" title="1.3 常用方法"></a>1.3 常用方法</h2><h3 id="获取功能的方法"><a href="#获取功能的方法" class="headerlink" title="获取功能的方法"></a>获取功能的方法</h3><ul>
<li><p><code>public String getAbsolutePath() </code> ：返回此File的绝对路径名字符串。</p>
</li>
<li><p><code>public String getPath()</code> ：将此File转换为路径名字符串。 </p>
</li>
<li><p><code>public String getName()</code>  ：返回由此File表示的文件或目录的名称。  </p>
</li>
<li><p><code>public long length()</code>  ：返回由此File表示的文件的长度。 </p>
<p>方法演示，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileGet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;d:/aaa/bbb.java&quot;</span>);     </span><br><span class="line">        System.out.println(<span class="string">&quot;文件绝对路径:&quot;</span>+f.getAbsolutePath());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件构造路径:&quot;</span>+f.getPath());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件名称:&quot;</span>+f.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件长度:&quot;</span>+f.length()+<span class="string">&quot;字节&quot;</span>);</span><br><span class="line"></span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">&quot;d:/aaa&quot;</span>);     </span><br><span class="line">        System.out.println(<span class="string">&quot;目录绝对路径:&quot;</span>+f2.getAbsolutePath());</span><br><span class="line">        System.out.println(<span class="string">&quot;目录构造路径:&quot;</span>+f2.getPath());</span><br><span class="line">        System.out.println(<span class="string">&quot;目录名称:&quot;</span>+f2.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;目录长度:&quot;</span>+f2.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">文件绝对路径:d:\aaa\bbb.java</span><br><span class="line">文件构造路径:d:\aaa\bbb.java</span><br><span class="line">文件名称:bbb.java</span><br><span class="line">文件长度:<span class="number">636</span>字节</span><br><span class="line"></span><br><span class="line">目录绝对路径:d:\aaa</span><br><span class="line">目录构造路径:d:\aaa</span><br><span class="line">目录名称:aaa</span><br><span class="line">目录长度:<span class="number">4096</span></span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>API中说明：length()，表示文件的长度。但是File对象表示目录，则返回值未指定。</p>
</blockquote>
<h3 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h3><ul>
<li><strong>绝对路径</strong>：从盘符开始的路径，这是一个完整的路径。</li>
<li><strong>相对路径</strong>：相对于项目目录的路径，这是一个便捷的路径，开发中经常使用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilePath</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      	<span class="comment">// D盘下的bbb.java文件</span></span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;D:\\bbb.java&quot;</span>);</span><br><span class="line">        System.out.println(f.getAbsolutePath());</span><br><span class="line">      	</span><br><span class="line">		<span class="comment">// 项目下的bbb.java文件</span></span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">&quot;bbb.java&quot;</span>);</span><br><span class="line">        System.out.println(f2.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">D:\bbb.java</span><br><span class="line">D:\idea_project_test4\bbb.java</span><br></pre></td></tr></table></figure>

<h3 id="判断功能的方法"><a href="#判断功能的方法" class="headerlink" title="判断功能的方法"></a>判断功能的方法</h3><ul>
<li><code>public boolean exists()</code> ：此File表示的文件或目录是否实际存在。</li>
<li><code>public boolean isDirectory()</code> ：此File表示的是否为目录。</li>
<li><code>public boolean isFile()</code> ：此File表示的是否为文件。</li>
</ul>
<p>方法演示，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileIs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;d:\\aaa\\bbb.java&quot;</span>);</span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">&quot;d:\\aaa&quot;</span>);</span><br><span class="line">      	<span class="comment">// 判断是否存在</span></span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa\\bbb.java 是否存在:&quot;</span>+f.exists());</span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa 是否存在:&quot;</span>+f2.exists());</span><br><span class="line">      	<span class="comment">// 判断是文件还是目录</span></span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa 文件?:&quot;</span>+f2.isFile());</span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa 目录?:&quot;</span>+f2.isDirectory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">d:\aaa\bbb.java 是否存在:<span class="keyword">true</span></span><br><span class="line">d:\aaa 是否存在:<span class="keyword">true</span></span><br><span class="line">d:\aaa 文件?:<span class="keyword">false</span></span><br><span class="line">d:\aaa 目录?:<span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<h3 id="创建删除功能的方法"><a href="#创建删除功能的方法" class="headerlink" title="创建删除功能的方法"></a>创建删除功能的方法</h3><ul>
<li><code>public boolean createNewFile()</code> ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。 </li>
<li><code>public boolean delete()</code> ：删除由此File表示的文件或目录。  </li>
<li><code>public boolean mkdir()</code> ：创建由此File表示的目录。</li>
<li><code>public boolean mkdirs()</code> ：创建由此File表示的目录，包括任何必需但不存在的父目录。</li>
</ul>
<p>方法演示，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileCreateDelete</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 文件的创建</span></span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;aaa.txt&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在:&quot;</span>+f.exists()); <span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否创建:&quot;</span>+f.createNewFile()); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在:&quot;</span>+f.exists()); <span class="comment">// true</span></span><br><span class="line">		</span><br><span class="line">     	<span class="comment">// 目录的创建</span></span><br><span class="line">      	File f2= <span class="keyword">new</span> File(<span class="string">&quot;newDir&quot;</span>);	</span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在:&quot;</span>+f2.exists());<span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否创建:&quot;</span>+f2.mkdir());	<span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在:&quot;</span>+f2.exists());<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建多级目录</span></span><br><span class="line">      	File f3= <span class="keyword">new</span> File(<span class="string">&quot;newDira\\newDirb&quot;</span>);</span><br><span class="line">        System.out.println(f3.mkdir());<span class="comment">// false</span></span><br><span class="line">        File f4= <span class="keyword">new</span> File(<span class="string">&quot;newDira\\newDirb&quot;</span>);</span><br><span class="line">        System.out.println(f4.mkdirs());<span class="comment">// true</span></span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 文件的删除</span></span><br><span class="line">       	System.out.println(f.delete());<span class="comment">// true</span></span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 目录的删除</span></span><br><span class="line">        System.out.println(f2.delete());<span class="comment">// true</span></span><br><span class="line">        System.out.println(f4.delete());<span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>API中说明：delete方法，如果此File表示目录，则目录必须为空才能删除。</p>
</blockquote>
<h2 id="1-4-目录的遍历"><a href="#1-4-目录的遍历" class="headerlink" title="1.4 目录的遍历"></a>1.4 目录的遍历</h2><ul>
<li><code>public String[] list()</code> ：返回一个String数组，表示该File目录中的所有子文件或目录。</li>
</ul>
<ul>
<li><code>public File[] listFiles()</code> ：返回一个File数组，表示该File目录中的所有的子文件或目录。  </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileFor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File dir = <span class="keyword">new</span> File(<span class="string">&quot;d:\\java_code&quot;</span>);</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">//获取当前目录下的文件以及文件夹的名称。</span></span><br><span class="line">		String[] names = dir.list();</span><br><span class="line">		<span class="keyword">for</span>(String name : names)&#123;</span><br><span class="line">			System.out.println(name);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//获取当前目录下的文件以及文件夹对象，只要拿到了文件对象，那么就可以获取更多信息</span></span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            System.out.println(file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：</p>
<p>调用listFiles方法的File对象，表示的必须是实际存在的目录，否则返回null，无法进行遍历。</p>
</blockquote>
<h1 id="第二章-递归"><a href="#第二章-递归" class="headerlink" title="第二章 递归"></a>第二章 递归</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><ul>
<li><p><strong>递归</strong>：指在当前方法内调用自己的这种现象。</p>
</li>
<li><p><strong>递归的分类:</strong></p>
<ul>
<li>递归分为两种，直接递归和间接递归。</li>
<li>直接递归称为方法自身调用自己。</li>
<li>间接递归可以A方法调用B方法，B方法调用C方法，C方法调用A方法。</li>
</ul>
</li>
<li><p><strong>注意事项</strong>：</p>
<ul>
<li>递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。</li>
<li>在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。</li>
<li>构造方法,禁止递归</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01DiGui</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// a();</span></span><br><span class="line">		b(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 3.构造方法,禁止递归</span></span><br><span class="line"><span class="comment">	 * 编译报错:构造方法是创建对象使用的,不能让对象一直创建下去</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Demo01DiGui</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//Demo01DiGui();</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 2.在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。</span></span><br><span class="line"><span class="comment">	 * 4993</span></span><br><span class="line"><span class="comment">	 * 	Exception in thread &quot;main&quot; java.lang.StackOverflowError</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">		System.out.println(i);</span><br><span class="line">		<span class="comment">//添加一个递归结束的条件,i==5000的时候结束</span></span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">5000</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span>;<span class="comment">//结束方法</span></span><br><span class="line">		&#125;</span><br><span class="line">		b(++i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 1.递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。 Exception in thread &quot;main&quot;</span></span><br><span class="line"><span class="comment">	 * java.lang.StackOverflowError</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;a方法&quot;</span>);</span><br><span class="line">		a();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-递归累加求和"><a href="#2-2-递归累加求和" class="headerlink" title="2.2 递归累加求和"></a>2.2 递归累加求和</h2><h3 id="计算1-n的和"><a href="#计算1-n的和" class="headerlink" title="计算1 ~ n的和"></a>计算1 ~ n的和</h3><p><strong>分析</strong>：num的累和 = num + (num-1)的累和，所以可以把累和的操作定义成一个方法，递归调用。</p>
<p><strong>实现代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiGuiDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//计算1~num的和，使用递归完成</span></span><br><span class="line">		<span class="keyword">int</span> num = <span class="number">5</span>;</span><br><span class="line">      	<span class="comment">// 调用求和的方法</span></span><br><span class="line">		<span class="keyword">int</span> sum = getSum(num);</span><br><span class="line">      	<span class="comment">// 输出结果</span></span><br><span class="line">		System.out.println(sum);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">  	<span class="comment">/*</span></span><br><span class="line"><span class="comment">  	  通过递归算法实现.</span></span><br><span class="line"><span class="comment">  	  参数列表:int </span></span><br><span class="line"><span class="comment">  	  返回值类型: int </span></span><br><span class="line"><span class="comment">  	*/</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">      	<span class="comment">/* </span></span><br><span class="line"><span class="comment">      	   num为1时,方法返回1,</span></span><br><span class="line"><span class="comment">      	   相当于是方法的出口,num总有是1的情况</span></span><br><span class="line"><span class="comment">      	*/</span></span><br><span class="line">		<span class="keyword">if</span>(num == <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">      	<span class="comment">/*</span></span><br><span class="line"><span class="comment">          num不为1时,方法返回 num +(num-1)的累和</span></span><br><span class="line"><span class="comment">          递归调用getSum方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">		<span class="keyword">return</span> num + getSum(num-<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码执行图解"><a href="#代码执行图解" class="headerlink" title="代码执行图解"></a>代码执行图解</h3><p><img src="/img/day08_01_%E9%80%92%E5%BD%92%E7%B4%AF%E5%92%8C.jpg"></p>
<blockquote>
<p>小贴士：递归一定要有条件限定，保证递归能够停止下来，次数不要太多，否则会发生栈内存溢出。</p>
</blockquote>
<h2 id="2-3-递归求阶乘"><a href="#2-3-递归求阶乘" class="headerlink" title="2.3 递归求阶乘"></a>2.3 递归求阶乘</h2><ul>
<li><strong>阶乘</strong>：所有小于及等于该数的正整数的积。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">n的阶乘：n! = n * (n-<span class="number">1</span>) *...* <span class="number">3</span> * <span class="number">2</span> * <span class="number">1</span> </span><br></pre></td></tr></table></figure>

<p><strong>分析</strong>：这与累和类似,只不过换成了乘法运算，学员可以自己练习，需要注意阶乘值符合int类型的范围。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">推理得出：n! = n * (n-1)!</span><br></pre></td></tr></table></figure>

<p><strong>代码实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiGuiDemo</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//计算n的阶乘，使用递归完成</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">3</span>;</span><br><span class="line">      	<span class="comment">// 调用求阶乘的方法</span></span><br><span class="line">        <span class="keyword">int</span> value = getValue(n);</span><br><span class="line">      	<span class="comment">// 输出结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;阶乘为:&quot;</span>+ value);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">  	  通过递归算法实现.</span></span><br><span class="line"><span class="comment">  	  参数列表:int </span></span><br><span class="line"><span class="comment">  	  返回值类型: int </span></span><br><span class="line"><span class="comment">  	*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      	<span class="comment">// 1的阶乘为1</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">/*</span></span><br><span class="line"><span class="comment">      	  n不为1时,方法返回 n! = n*(n-1)!</span></span><br><span class="line"><span class="comment">          递归调用getValue方法</span></span><br><span class="line"><span class="comment">      	*/</span></span><br><span class="line">        <span class="keyword">return</span> n * getValue(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-递归打印多级目录"><a href="#2-4-递归打印多级目录" class="headerlink" title="2.4 递归打印多级目录"></a>2.4 递归打印多级目录</h2><p><strong>分析</strong>：多级目录的打印，就是当目录的嵌套。遍历之前，无从知道到底有多少级目录，所以我们还是要使用递归实现。</p>
<p><strong>代码实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiGuiDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      	<span class="comment">// 创建File对象</span></span><br><span class="line">        File dir  = <span class="keyword">new</span> File(<span class="string">&quot;D:\\aaa&quot;</span>);</span><br><span class="line">      	<span class="comment">// 调用打印目录方法</span></span><br><span class="line">        printDir(dir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">printDir</span><span class="params">(File dir)</span> </span>&#123;</span><br><span class="line">      	<span class="comment">// 获取子文件和目录</span></span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">      	<span class="comment">// 循环打印</span></span><br><span class="line">      	<span class="comment">/*</span></span><br><span class="line"><span class="comment">      	  判断:</span></span><br><span class="line"><span class="comment">      	  当是文件时,打印绝对路径.</span></span><br><span class="line"><span class="comment">      	  当是目录时,继续调用打印目录的方法,形成递归调用.</span></span><br><span class="line"><span class="comment">      	*/</span></span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">    		<span class="comment">// 判断</span></span><br><span class="line">            <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">              	<span class="comment">// 是文件,输出文件绝对路径</span></span><br><span class="line">                System.out.println(<span class="string">&quot;文件名:&quot;</span>+ file.getAbsolutePath());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              	<span class="comment">// 是目录,输出目录绝对路径</span></span><br><span class="line">                System.out.println(<span class="string">&quot;目录:&quot;</span>+file.getAbsolutePath());</span><br><span class="line">              	<span class="comment">// 继续遍历,调用printDir,形成递归</span></span><br><span class="line">                printDir(file);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第三章-综合案例"><a href="#第三章-综合案例" class="headerlink" title="第三章 综合案例"></a>第三章 综合案例</h1><h2 id="3-1-文件搜索"><a href="#3-1-文件搜索" class="headerlink" title="3.1 文件搜索"></a>3.1 文件搜索</h2><p>搜索<code>D:\aaa</code> 目录中的<code>.java</code> 文件。</p>
<p><strong>分析</strong>：</p>
<ol>
<li>目录搜索，无法判断多少级目录，所以使用递归，遍历所有目录。</li>
<li>遍历目录时，获取的子文件，通过文件名称，判断是否符合条件。</li>
</ol>
<p><strong>代码实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiGuiDemo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建File对象</span></span><br><span class="line">        File dir  = <span class="keyword">new</span> File(<span class="string">&quot;D:\\aaa&quot;</span>);</span><br><span class="line">      	<span class="comment">// 调用打印目录方法</span></span><br><span class="line">        printDir(dir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printDir</span><span class="params">(File dir)</span> </span>&#123;</span><br><span class="line">      	<span class="comment">// 获取子文件和目录</span></span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">      	</span><br><span class="line">      	<span class="comment">// 循环打印</span></span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">              	<span class="comment">// 是文件，判断文件名并输出文件绝对路径</span></span><br><span class="line">                <span class="keyword">if</span> (file.getName().endsWith(<span class="string">&quot;.java&quot;</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;文件名:&quot;</span> + file.getAbsolutePath());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 是目录，继续遍历,形成递归</span></span><br><span class="line">                printDir(file);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-文件过滤器优化"><a href="#3-2-文件过滤器优化" class="headerlink" title="3.2 文件过滤器优化"></a>3.2 文件过滤器优化</h2><p><code>java.io.FileFilter</code>是一个接口，是File的过滤器。 该接口的对象可以传递给File类的<code>listFiles(FileFilter)</code> 作为参数， 接口中只有一个方法。</p>
<p><code>boolean accept(File pathname)  </code> ：测试pathname是否应该包含在当前File目录中，符合则返回true。</p>
<p><strong>分析</strong>：</p>
<ol>
<li>接口作为参数，需要传递子类对象，重写其中方法。我们选择匿名内部类方式，比较简单。</li>
<li><code>accept</code>方法，参数为File，表示当前File下所有的子文件和子目录。保留住则返回true，过滤掉则返回false。保留规则：<ol>
<li>要么是.java文件。</li>
<li>要么是目录，用于继续遍历。</li>
</ol>
</li>
<li>通过过滤器的作用，<code>listFiles(FileFilter)</code>返回的数组元素中，子文件对象都是符合条件的，可以直接打印。</li>
</ol>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiGuiDemo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File dir = <span class="keyword">new</span> File(<span class="string">&quot;D:\\aaa&quot;</span>);</span><br><span class="line">        printDir2(dir);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printDir2</span><span class="params">(File dir)</span> </span>&#123;</span><br><span class="line">      	<span class="comment">// 匿名内部类方式,创建过滤器子类对象</span></span><br><span class="line">        File[] files = dir.listFiles(<span class="keyword">new</span> FileFilter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File pathname)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> pathname.getName().endsWith(<span class="string">&quot;.java&quot;</span>)||pathname.isDirectory();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      	<span class="comment">// 循环打印</span></span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;文件名:&quot;</span> + file.getAbsolutePath());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                printDir2(file);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;      </span><br></pre></td></tr></table></figure>



<h2 id="3-3-Lambda优化"><a href="#3-3-Lambda优化" class="headerlink" title="3.3 Lambda优化"></a>3.3 Lambda优化</h2><p><strong>分析：</strong><code>FileFilter</code>是只有一个方法的接口，因此可以用lambda表达式简写。</p>
<p>lambda格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">()-&gt;&#123; &#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printDir3</span><span class="params">(File dir)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// lambda的改写</span></span><br><span class="line">    File[] files = dir.listFiles(f -&gt;&#123; </span><br><span class="line">      	<span class="keyword">return</span> f.getName().endsWith(<span class="string">&quot;.java&quot;</span>) || f.isDirectory(); </span><br><span class="line">    &#125;);</span><br><span class="line">  	</span><br><span class="line">	<span class="comment">// 循环打印</span></span><br><span class="line">    <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">        <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;文件名:&quot;</span> + file.getAbsolutePath());</span><br><span class="line">      	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	printDir3(file);</span><br><span class="line">      	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>File类、递归</tag>
      </tags>
  </entry>
  <entry>
    <title>Font Awesome Icons收集</title>
    <url>/2021/06/28/Font%20Awesome%20Icons%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[<p><i class="fa fa-automobile" aria-hidden="true"></i>小汽车</p>
<p><i class="fa fa-code-fork" aria-hidden="true"></i>git</p>
<p><i class="fa fa-coffee" aria-hidden="true"></i>java</p>
<p><i class="fa fa-cogs" aria-hidden="true"></i>config</p>
<p><i class="fa fa-connectdevelop" aria-hidden="true"></i>网络</p>
<p><i class="fa fa-desktop" aria-hidden="true"></i>电脑屏幕(操作系统)</p>
<p><i class="fa fa-envira" aria-hidden="true"></i>spring</p>
<p><i class="fa fa-git" aria-hidden="true"></i>git</p>
<p><i class="fa fa-github-alt" aria-hidden="true"></i>github</p>
<p><i class="fa fa-hand-lizard-o" aria-hidden="true"></i>拿捏了</p>
<p><i class="fa fa-hand-o-down" aria-hidden="true"></i>手指向下方<br><i class="fa fa-th-large" aria-hidden="true"></i>    1<br><i class="fa fa-arrow-right" aria-hidden="true"></i>    2<br><i class="fa fa-arrow-up" aria-hidden="true"></i>    3<br><i class="fa fa-arrow-down" aria-hidden="true"></i>    4<br><i class="fa fa-mail-forward" aria-hidden="true"></i>    5<br><i class="fa fa-share" aria-hidden="true"></i>    6<br><i class="fa fa-expand" aria-hidden="true"></i>    7<br><i class="fa fa-compress" aria-hidden="true"></i>    8<br><i class="fa fa-plus" aria-hidden="true"></i>    9<br><i class="fa fa-minus" aria-hidden="true"></i>    10<br><i class="fa fa-asterisk" aria-hidden="true"></i>    11<br><i class="fa fa-th" aria-hidden="true"></i>    12<br><i class="fa fa-exclamation-circle" aria-hidden="true"></i>    13<br><i class="fa fa-gift" aria-hidden="true"></i>    14<br><i class="fa fa-leaf" aria-hidden="true"></i>    15<br><i class="fa fa-fire" aria-hidden="true"></i>    16<br><i class="fa fa-eye" aria-hidden="true"></i>    17<br><i class="fa fa-eye-slash" aria-hidden="true"></i>    18<br><i class="fa fa-warning" aria-hidden="true"></i>    19<br><i class="fa fa-exclamation-triangle" aria-hidden="true"></i>    20<br><i class="fa fa-plane" aria-hidden="true"></i>    21<br><i class="fa fa-calendar" aria-hidden="true"></i>    22<br><i class="fa fa-th-list" aria-hidden="true"></i>    23<br><i class="fa fa-random" aria-hidden="true"></i>    24<br><i class="fa fa-comment" aria-hidden="true"></i>    25<br><i class="fa fa-magnet" aria-hidden="true"></i>    26<br><i class="fa fa-chevron-up" aria-hidden="true"></i>    27<br><i class="fa fa-chevron-down" aria-hidden="true"></i>    28<br><i class="fa fa-retweet" aria-hidden="true"></i>    29<br><i class="fa fa-shopping-cart" aria-hidden="true"></i>    30<br><i class="fa fa-folder" aria-hidden="true"></i>    31<br><i class="fa fa-folder-open" aria-hidden="true"></i>    32<br><i class="fa fa-arrows-v" aria-hidden="true"></i>    33<br><i class="fa fa-check" aria-hidden="true"></i>    34<br><i class="fa fa-arrows-h" aria-hidden="true"></i>    35<br><i class="fa fa-bar-chart-o" aria-hidden="true"></i>    36<br><i class="fa fa-bar-chart" aria-hidden="true"></i>    37<br><i class="fa fa-twitter-square" aria-hidden="true"></i>    38<br><i class="fa fa-facebook-square" aria-hidden="true"></i>    39<br><i class="fa fa-camera-retro" aria-hidden="true"></i>    40<br><i class="fa fa-key" aria-hidden="true"></i>    41<br><i class="fa fa-gears" aria-hidden="true"></i>    42<br><i class="fa fa-cogs" aria-hidden="true"></i>    43<br><i class="fa fa-comments" aria-hidden="true"></i>    44<br><i class="fa fa-remove" aria-hidden="true"></i>    45<br><i class="fa fa-thumbs-o-up" aria-hidden="true"></i>    46<br><i class="fa fa-thumbs-o-down" aria-hidden="true"></i>    47<br><i class="fa fa-star-half" aria-hidden="true"></i>    48<br><i class="fa fa-heart-o" aria-hidden="true"></i>    49<br><i class="fa fa-sign-out" aria-hidden="true"></i>    50<br><i class="fa fa-linkedin-square" aria-hidden="true"></i>    51<br><i class="fa fa-thumb-tack" aria-hidden="true"></i>    52<br><i class="fa fa-external-link" aria-hidden="true"></i>    53<br><i class="fa fa-sign-in" aria-hidden="true"></i>    54<br><i class="fa fa-trophy" aria-hidden="true"></i>    55<br><i class="fa fa-close" aria-hidden="true"></i>    56<br><i class="fa fa-github-square" aria-hidden="true"></i>    57<br><i class="fa f-upload" aria-hidden="true"></i>    58<br><i class="fa fa-lemon-o" aria-hidden="true"></i>    59<br><i class="fa fa-phone" aria-hidden="true"></i>    60<br><i class="fa fa-square-o" aria-hidden="true"></i>    61<br><i class="fa fa-bookmark-o" aria-hidden="true"></i>    62<br><i class="fa fa-phone-square" aria-hidden="true"></i>    63<br><i class="fa fa-twitter" aria-hidden="true"></i>    64<br><i class="fa fa-facebook" aria-hidden="true"></i>    65<br><i class="fa fa-github" aria-hidden="true"></i>    66<br><i class="fa fa-times" aria-hidden="true"></i>    67<br><i class="fa fa-unlock" aria-hidden="true"></i>    68<br><i class="fa fa-credit-card" aria-hidden="true"></i>    69<br><i class="fa fa-rss" aria-hidden="true"></i>    70<br><i class="fa fa-hdd-o" aria-hidden="true"></i>    71<br><i class="fa fa-bullhorn" aria-hidden="true"></i>    72<br><i class="fa fa-bell" aria-hidden="true"></i>    73<br><i class="fa fa-certificate" aria-hidden="true"></i>    74<br><i class="fa fa-hand-o-right" aria-hidden="true"></i>    75<br><i class="fa fa-hand-o-left" aria-hidden="true"></i>    76<br><i class="fa fa-hand-o-up" aria-hidden="true"></i>    77<br><i class="fa fa-search-plus" aria-hidden="true"></i>    78<br><i class="fa fa-hand-o-down" aria-hidden="true"></i>    79<br><i class="fa fa-arrow-circle-left" aria-hidden="true"></i>    80<br><i class="fa fa-arrow-circle-right" aria-hidden="true"></i>    81<br><i class="fa fa-arrow-circle-up" aria-hidden="true"></i>    82<br><i class="fa fa-arrow-circle-down" aria-hidden="true"></i>    83<br><i class="fa fa-globe" aria-hidden="true"></i>    84<br><i class="fa fa-wrench" aria-hidden="true"></i>    85<br><i class="fa fa-tasks" aria-hidden="true"></i>    86<br><i class="fa fa-filter" aria-hidden="true"></i>    87<br><i class="fa fa-briefcase" aria-hidden="true"></i>    88<br><i class="fa fa-search-minus" aria-hidden="true"></i>    89<br><i class="fa fa-arrows-alt" aria-hidden="true"></i>    90<br><i class="fa fa-group" aria-hidden="true"></i>    91<br><i class="fa fa-users" aria-hidden="true"></i>    92<br><i class="fa fa-chain" aria-hidden="true"></i>    93<br><i class="fa fa-link" aria-hidden="true"></i>    94<br><i class="fa fa-cloud" aria-hidden="true"></i>    95<br><i class="fa fa-flask" aria-hidden="true"></i>    96<br><i class="fa fa-cut" aria-hidden="true"></i>    97<br><i class="fa fa-scissors" aria-hidden="true"></i>    98<br><i class="fa fa-copy" aria-hidden="true"></i>    99<br><i class="fa fa-power-off" aria-hidden="true"></i>    100<br><i class="fa fa-files-o" aria-hidden="true"></i>    101<br><i class="fa fa-paperclip" aria-hidden="true"></i>    102<br><i class="fa fa-save" aria-hidden="true"></i>    103<br><i class="fa fa-floppy-o" aria-hidden="true"></i>    104<br><i class="fa fa-square" aria-hidden="true"></i>    105<br><i class="fa fa-navicon" aria-hidden="true"></i>    106<br><i class="fa fa-reorder" aria-hidden="true"></i>    107<br><i class="fa fa-bars" aria-hidden="true"></i>    108<br><i class="fa fa-list-ul" aria-hidden="true"></i>    109<br><i class="fa fa-list-ol" aria-hidden="true"></i>    110<br><i class="fa fa-music" aria-hidden="true"></i>    111<br><i class="fa fa-signal" aria-hidden="true"></i>    112<br><i class="fa fa-strikethrough" aria-hidden="true"></i>    113<br><i class="fa fa-underline" aria-hidden="true"></i>    114<br><i class="fa fa-table" aria-hidden="true"></i>    115<br><i class="fa fa-magic" aria-hidden="true"></i>    116<br><i class="fa fa-truck" aria-hidden="true"></i>    117<br><i class="fa fa-pinterest" aria-hidden="true"></i>    118<br><i class="fa fa-pinterest-square" aria-hidden="true"></i>    119<br><i class="fa fa-google-plus-square" aria-hidden="true"></i>    120<br><i class="fa fa-google-plus" aria-hidden="true"></i>    121<br><i class="fa fa-money" aria-hidden="true"></i>    122<br><i class="fa fa-gear" aria-hidden="true"></i>    123<br><i class="fa fa-caret-down" aria-hidden="true"></i>    124<br><i class="fa fa-caret-up" aria-hidden="true"></i>    125<br><i class="fa fa-caret-left" aria-hidden="true"></i>    126<br><i class="fa fa-caret-right" aria-hidden="true"></i>    127<br><i class="fa fa-columns" aria-hidden="true"></i>    128<br><i class="fa fa-unsorted" aria-hidden="true"></i>    129<br><i class="fa fa-sort" aria-hidden="true"></i>    130<br><i class="fa fa-sort-down" aria-hidden="true"></i>    131<br><i class="fa fa-sort-desc" aria-hidden="true"></i>    132<br><i class="fa fa-sort-up" aria-hidden="true"></i>    133<br><i class="fa fa-cog" aria-hidden="true"></i>    134<br><i class="fa fa-sort-asc" aria-hidden="true"></i>    135<br><i class="fa fa-envelope" aria-hidden="true"></i>    136<br><i class="fa fa-linkedin" aria-hidden="true"></i>    137<br><i class="fa fa-rotate-left" aria-hidden="true"></i>    138<br><i class="fa fa-undo" aria-hidden="true"></i>    139<br><i class="fa fa-legal" aria-hidden="true"></i>    140<br><i class="fa fa-gavel" aria-hidden="true"></i>    141<br><i class="fa fa-dashboard" aria-hidden="true"></i>    142<br><i class="fa fa-tachometer" aria-hidden="true"></i>    143<br><i class="fa fa-comment-o" aria-hidden="true"></i>    144<br><i class="fa fa-trash-o" aria-hidden="true"></i>    145<br><i class="fa fa-comments-o" aria-hidden="true"></i>    146<br><i class="fa fa-flash" aria-hidden="true"></i>    147<br><i class="fa fa-bolt" aria-hidden="true"></i>    148<br><i class="fa fa-sitemap" aria-hidden="true"></i>    149<br><i class="fa fa-umbrella" aria-hidden="true"></i>    150<br><i class="fa fa-paste" aria-hidden="true"></i>    151<br><i class="fa fa-clipboard" aria-hidden="true"></i>    152<br><i class="fa fa-lightbulb-o" aria-hidden="true"></i>    153<br><i class="fa fa-exchange" aria-hidden="true"></i>    154<br><i class="fa fa-cloud-download" aria-hidden="true"></i>    155<br><i class="fa fa-home" aria-hidden="true"></i>    156<br><i class="fa fa-cloud-upload" aria-hidden="true"></i>    157<br><i class="fa fa-user-md" aria-hidden="true"></i>    158<br><i class="fa fa-stethoscope" aria-hidden="true"></i>    159<br><i class="fa fa-suitcase" aria-hidden="true"></i>    160<br><i class="fa fa-bell-o" aria-hidden="true"></i>    161<br><i class="fa fa-coffee" aria-hidden="true"></i>    162<br><i class="fa fa-cutlery" aria-hidden="true"></i>    163<br><i class="fa fa-file-text-o" aria-hidden="true"></i>    164<br><i class="fa fa-building-o" aria-hidden="true"></i>    165<br><i class="fa fa-hospital-o" aria-hidden="true"></i>    166<br><i class="fa fa-file-o" aria-hidden="true"></i>    167<br><i class="fa fa-ambulance" aria-hidden="true"></i>    168<br><i class="fa fa-medkit" aria-hidden="true"></i>    169<br><i class="fa fa-fighter-jet" aria-hidden="true"></i>    170<br><i class="fa fa-beer" aria-hidden="true"></i>    171<br><i class="fa fa-h-square" aria-hidden="true"></i>    172<br><i class="fa fa-plus-square" aria-hidden="true"></i>    173<br><i class="fa fa-angle-double-left" aria-hidden="true"></i>    174<br><i class="fa fa-angle-double-right" aria-hidden="true"></i>    175<br><i class="fa fa-angle-double-up" aria-hidden="true"></i>    176<br><i class="fa fa-angle-double-down" aria-hidden="true"></i>    177<br><i class="fa fa-clock-o" aria-hidden="true"></i>    178<br><i class="fa fa-angle-left" aria-hidden="true"></i>    179<br><i class="fa fa-angle-right" aria-hidden="true"></i>    180<br><i class="fa fa-angle-up" aria-hidden="true"></i>    181<br><i class="fa fa-angle-down" aria-hidden="true"></i>    182<br><i class="fa fa-desktop" aria-hidden="true"></i>    183<br><i class="fa fa-laptop" aria-hidden="true"></i>    184<br><i class="fa fa-tablet" aria-hidden="true"></i>    185<br><i class="fa fa-mobile-phone" aria-hidden="true"></i>    186<br><i class="fa fa-mobile" aria-hidden="true"></i>    187<br><i class="fa fa-circle-o" aria-hidden="true"></i>    188<br><i class="fa fa-road" aria-hidden="true"></i>    189<br><i class="fa fa-quote-left" aria-hidden="true"></i>    190<br><i class="fa fa-quote-right" aria-hidden="true"></i>    191<br><i class="fa fa-spinner" aria-hidden="true"></i>    192<br><i class="fa fa-circle" aria-hidden="true"></i>    193<br><i class="fa fa-mail-reply" aria-hidden="true"></i>    194<br><i class="fa fa-reply" aria-hidden="true"></i>    195<br><i class="fa fa-github-alt" aria-hidden="true"></i>    196<br><i class="fa fa-folder-o" aria-hidden="true"></i>    197<br><i class="fa fa-folder-open-o" aria-hidden="true"></i>    198<br><i class="fa fa-smile-o" aria-hidden="true"></i>    199<br><i class="fa fa-download" aria-hidden="true"></i>    200<br><i class="fa fa-frown-o" aria-hidden="true"></i>    201<br><i class="fa fa-meh-o" aria-hidden="true"></i>    202<br><i class="fa fa-gamepad" aria-hidden="true"></i>    203<br><i class="fa fa-keyboard-o" aria-hidden="true"></i>    204<br><i class="fa fa-flag-o" aria-hidden="true"></i>    205<br><i class="fa fa-flag-checkered" aria-hidden="true"></i>    206<br><i class="fa fa-terminal" aria-hidden="true"></i>    207<br><i class="fa fa-code" aria-hidden="true"></i>    208<br><i class="fa fa-mail-reply-all" aria-hidden="true"></i>    209<br><i class="fa fa-reply-all" aria-hidden="true"></i>    210<br><i class="fa fa-arrow-circle-o-down" aria-hidden="true"></i>    211<br><i class="fa fa-star-half-empty" aria-hidden="true"></i>    212<br><i class="fa fa-star-half-full" aria-hidden="true"></i>    213<br><i class="fa fa-star-half-o" aria-hidden="true"></i>    214<br><i class="fa fa-location-arrow" aria-hidden="true"></i>    215<br><i class="fa fa-crop" aria-hidden="true"></i>    216<br><i class="fa fa-code-fork" aria-hidden="true"></i>    217<br><i class="fa fa-unlink" aria-hidden="true"></i>    218<br><i class="fa fa-chain-broken" aria-hidden="true"></i>    219<br><i class="fa fa-question" aria-hidden="true"></i>    220<br><i class="fa fa-info" aria-hidden="true"></i>    221<br><i class="fa fa-search" aria-hidden="true"></i>    222<br><i class="fa fa-arrow-circle-o-up" aria-hidden="true"></i>    223<br><i class="fa fa-exclamation" aria-hidden="true"></i>    224<br><i class="fa fa-superscript" aria-hidden="true"></i>    225<br><i class="fa fa-subscript" aria-hidden="true"></i>    226<br><i class="fa fa-eraser" aria-hidden="true"></i>    227<br><i class="fa fa-puzzle-piece" aria-hidden="true"></i>    228<br><i class="fa fa-microphone" aria-hidden="true"></i>    229<br><i class="fa fa-microphone-slash" aria-hidden="true"></i>    230<br><i class="fa fa-shield" aria-hidden="true"></i>    231<br><i class="fa fa-calendar-o" aria-hidden="true"></i>    232<br><i class="fa fa-fire-extinguisher" aria-hidden="true"></i>    233<br><i class="fa fa-inbox" aria-hidden="true"></i>    234<br><i class="fa fa-rocket" aria-hidden="true"></i>    235<br><i class="fa fa-maxcdn" aria-hidden="true"></i>    236<br><i class="fa fa-chevron-circle-left" aria-hidden="true"></i>    237<br><i class="fa fa-chevron-circle-right" aria-hidden="true"></i>    238<br><i class="fa fa-chevron-circle-up" aria-hidden="true"></i>    239<br><i class="fa fa-chevron-circle-down" aria-hidden="true"></i>    240<br><i class="fa fa-html5" aria-hidden="true"></i>    241<br><i class="fa fa-css3" aria-hidden="true"></i>    242<br><i class="fa fa-anchor" aria-hidden="true"></i>    243<br><i class="fa fa-unlock-alt" aria-hidden="true"></i>    244<br><i class="fa fa-play-circle-o" aria-hidden="true"></i>    245<br><i class="fa fa-bullseye" aria-hidden="true"></i>    246<br><i class="fa fa-ellipsis-h" aria-hidden="true"></i>    247<br><i class="fa fa-ellipsis-v" aria-hidden="true"></i>    248<br><i class="fa fa-rss-square" aria-hidden="true"></i>    249<br><i class="fa fa-play-circle" aria-hidden="true"></i>    250<br><i class="fa fa-ticket" aria-hidden="true"></i>    251<br><i class="fa fa-minus-square" aria-hidden="true"></i>    252<br><i class="fa fa-minus-square-o" aria-hidden="true"></i>    253<br><i class="fa fa-level-up" aria-hidden="true"></i>    254<br><i class="fa fa-level-down" aria-hidden="true"></i>    255<br><i class="fa fa-rotate-right" aria-hidden="true"></i>    256<br><i class="fa fa-check-square" aria-hidden="true"></i>    257<br><i class="fa fa-pencil-square" aria-hidden="true"></i>    258<br><i class="fa fa-external-link-square" aria-hidden="true"></i>    259<br><i class="fa fa-share-square" aria-hidden="true"></i>    260<br><i class="fa fa-compass" aria-hidden="true"></i>    261<br><i class="fa fa-toggle-down" aria-hidden="true"></i>    262<br><i class="fa fa-caret-square-o-down" aria-hidden="true"></i>    263<br><i class="fa fa-toggle-up" aria-hidden="true"></i>    264<br><i class="fa fa-caret-square-o-up" aria-hidden="true"></i>    265<br><i class="fa fa-toggle-right" aria-hidden="true"></i>    266<br><i class="fa fa-repeat" aria-hidden="true"></i>    267<br><i class="fa fa-caret-square-o-right" aria-hidden="true"></i>    268<br><i class="fa fa-euro" aria-hidden="true"></i>    269<br><i class="fa fa-eur" aria-hidden="true"></i>    270<br><i class="fa fa-gbp" aria-hidden="true"></i>    271<br><i class="fa fa-dollar" aria-hidden="true"></i>    272<br><i class="fa fa-usd" aria-hidden="true"></i>    273<br><i class="fa fa-rupee" aria-hidden="true"></i>    274<br><i class="fa fa-inr" aria-hidden="true"></i>    275<br><i class="fa fa-cny" aria-hidden="true"></i>    276<br><i class="fa fa-rmb" aria-hidden="true"></i>    277<br><i class="fa fa-refresh" aria-hidden="true"></i>    278<br><i class="fa fa-yen" aria-hidden="true"></i>    279<br><i class="fa fa-jpy" aria-hidden="true"></i>    280<br><i class="fa fa-ruble" aria-hidden="true"></i>    281<br><i class="fa fa-rouble" aria-hidden="true"></i>    282<br><i class="fa fa-rub" aria-hidden="true"></i>    283<br><i class="fa fa-won" aria-hidden="true"></i>    284<br><i class="fa fa-krw" aria-hidden="true"></i>    285<br><i class="fa fa-bitcoin" aria-hidden="true"></i>    286<br><i class="fa fa-btc" aria-hidden="true"></i>    287<br><i class="fa fa-file" aria-hidden="true"></i>    288<br><i class="fa fa-list-alt" aria-hidden="true"></i>    289<br><i class="fa fa-file-text" aria-hidden="true"></i>    290<br><i class="fa fa-sort-alpha-asc" aria-hidden="true"></i>    291<br><i class="fa fa-sort-alpha-desc" aria-hidden="true"></i>    292<br><i class="fa fa-sort-amount-asc" aria-hidden="true"></i>    293<br><i class="fa fa-sort-amount-desc" aria-hidden="true"></i>    294<br><i class="fa fa-sort-numeric-asc" aria-hidden="true"></i>    295<br><i class="fa fa-sort-numeric-desc" aria-hidden="true"></i>    296<br><i class="fa fa-thumbs-up" aria-hidden="true"></i>    297<br><i class="fa fa-thumbs-down" aria-hidden="true"></i>    298<br><i class="fa fa-youtube-square" aria-hidden="true"></i>    299<br><i class="fa fa-lock" aria-hidden="true"></i>    300<br><i class="fa fa-youtube" aria-hidden="true"></i>    301<br><i class="fa fa-xing" aria-hidden="true"></i>    302<br><i class="fa fa-xing-square" aria-hidden="true"></i>    303<br><i class="fa fa-youtube-play" aria-hidden="true"></i>    304<br><i class="fa fa-dropbox" aria-hidden="true"></i>    305<br><i class="fa fa-stack-overflow" aria-hidden="true"></i>    306<br><i class="fa fa-instagram" aria-hidden="true"></i>    307<br><i class="fa fa-flickr" aria-hidden="true"></i>    308<br><i class="fa fa-adn" aria-hidden="true"></i>    309<br><i class="fa fa-bitbucket" aria-hidden="true"></i>    310<br><i class="fa fa-flag" aria-hidden="true"></i>    311<br><i class="fa fa-bitbucket-square" aria-hidden="true"></i>    312<br><i class="fa fa-tumblr" aria-hidden="true"></i>    313<br><i class="fa fa-tumblr-square" aria-hidden="true"></i>    314<br><i class="fa fa-long-arrow-down" aria-hidden="true"></i>    315<br><i class="fa fa-long-arrow-up" aria-hidden="true"></i>    316<br><i class="fa fa-long-arrow-left" aria-hidden="true"></i>    317<br><i class="fa fa-long-arrow-right" aria-hidden="true"></i>    318<br><i class="fa fa-apple" aria-hidden="true"></i>    319<br><i class="fa fa-windows" aria-hidden="true"></i>    320<br><i class="fa fa-android" aria-hidden="true"></i>    321<br><i class="fa fa-headphones" aria-hidden="true"></i>    322<br><i class="fa fa-linux" aria-hidden="true"></i>    323<br><i class="fa fa-dribbble" aria-hidden="true"></i>    324<br><i class="fa fa-skype" aria-hidden="true"></i>    325<br><i class="fa fa-foursquare" aria-hidden="true"></i>    326<br><i class="fa fa-trello" aria-hidden="true"></i>    327<br><i class="fa fa-female" aria-hidden="true"></i>    328<br><i class="fa fa-male" aria-hidden="true"></i>    329<br><i class="fa fa-gittip" aria-hidden="true"></i>    330<br><i class="fa fa-sun-o" aria-hidden="true"></i>    331<br><i class="fa fa-moon-o" aria-hidden="true"></i>    332<br><i class="fa fa-envelope-o" aria-hidden="true"></i>    333<br><i class="fa fa-volume-off" aria-hidden="true"></i>    334<br><i class="fa fa-archive" aria-hidden="true"></i>    335<br><i class="fa fa-bug" aria-hidden="true"></i>    336<br><i class="fa fa-vk" aria-hidden="true"></i>    337<br><i class="fa fa-weibo" aria-hidden="true"></i>    338<br><i class="fa fa-renren" aria-hidden="true"></i>    339<br><i class="fa fa-pagelines" aria-hidden="true"></i>    340<br><i class="fa fa-stack-exchange" aria-hidden="true"></i>    341<br><i class="fa fa-arrow-circle-o-right" aria-hidden="true"></i>    342<br><i class="fa fa-arrow-circle-o-left" aria-hidden="true"></i>    343<br><i class="fa fa-toggle-left" aria-hidden="true"></i>    344<br><i class="fa fa-volume-down" aria-hidden="true"></i>    345<br><i class="fa fa-caret-square-o-left" aria-hidden="true"></i>    346<br><i class="fa fa-dot-circle-o" aria-hidden="true"></i>    347<br><i class="fa fa-wheelchair" aria-hidden="true"></i>    348<br><i class="fa fa-vimeo-square" aria-hidden="true"></i>    349<br><i class="fa fa-turkish-lira" aria-hidden="true"></i>    350<br><i class="fa fa-try" aria-hidden="true"></i>    351<br><i class="fa fa-plus-square-o" aria-hidden="true"></i>    352<br><i class="fa fa-space-shuttle" aria-hidden="true"></i>    353<br><i class="fa fa-slack" aria-hidden="true"></i>    354<br><i class="fa fa-envelope-square" aria-hidden="true"></i>    355<br><i class="fa fa-volume-up" aria-hidden="true"></i>    356<br><i class="fa fa-wordpress" aria-hidden="true"></i>    357<br><i class="fa fa-openid" aria-hidden="true"></i>    358<br><i class="fa fa-institution" aria-hidden="true"></i>    359<br><i class="fa fa-bank" aria-hidden="true"></i>    360<br><i class="fa fa-university" aria-hidden="true"></i>    361<br><i class="fa fa-mortar-board" aria-hidden="true"></i>    362<br><i class="fa fa-graduation-cap" aria-hidden="true"></i>    363<br><i class="fa fa-yahoo" aria-hidden="true"></i>    364<br><i class="fa fa-google" aria-hidden="true"></i>    365<br><i class="fa fa-reddit" aria-hidden="true"></i>    366<br><i class="fa fa-qrcode" aria-hidden="true"></i>    367<br><i class="fa fa-reddit-square" aria-hidden="true"></i>    368<br><i class="fa fa-stumbleupon-circle" aria-hidden="true"></i>    369<br><i class="fa fa-stumbleupon" aria-hidden="true"></i>    370<br><i class="fa fa-delicious" aria-hidden="true"></i>    371<br><i class="fa fa-digg" aria-hidden="true"></i>    372<br><i class="fa fa-pied-piper" aria-hidden="true"></i>    373<br><i class="fa fa-pied-piper-alt" aria-hidden="true"></i>    374<br><i class="fa fa-drupal" aria-hidden="true"></i>    375<br><i class="fa fa-joomla" aria-hidden="true"></i>    376<br><i class="fa fa-language" aria-hidden="true"></i>    377<br><i class="fa fa-barcode" aria-hidden="true"></i>    378<br><i class="fa fa-fax" aria-hidden="true"></i>    379<br><i class="fa fa-building" aria-hidden="true"></i>    380<br><i class="fa fa-child" aria-hidden="true"></i>    381<br><i class="fa fa-paw" aria-hidden="true"></i>    382<br><i class="fa fa-spoon" aria-hidden="true"></i>    383<br><i class="fa fa-cube" aria-hidden="true"></i>    384<br><i class="fa fa-cubes" aria-hidden="true"></i>    385<br><i class="fa fa-behance" aria-hidden="true"></i>    386<br><i class="fa fa-behance-square" aria-hidden="true"></i>    387<br><i class="fa fa-steam" aria-hidden="true"></i>    388<br><i class="fa fa-tag" aria-hidden="true"></i>    389<br><i class="fa fa-steam-square" aria-hidden="true"></i>    390<br><i class="fa fa-recycle" aria-hidden="true"></i>    391<br><i class="fa fa-automobile" aria-hidden="true"></i>    392<br><i class="fa fa-car" aria-hidden="true"></i>    393<br><i class="fa fa-cab" aria-hidden="true"></i>    394<br><i class="fa fa-taxi" aria-hidden="true"></i>    395<br><i class="fa fa-tree" aria-hidden="true"></i>    396<br><i class="fa fa-spotify" aria-hidden="true"></i>    397<br><i class="fa fa-deviantart" aria-hidden="true"></i>    398<br><i class="fa fa-soundcloud" aria-hidden="true"></i>    399<br><i class="fa fa-tags" aria-hidden="true"></i>    400<br><i class="fa fa-database" aria-hidden="true"></i>    401<br><i class="fa fa-file-pdf-o" aria-hidden="true"></i>    402<br><i class="fa fa-file-word-o" aria-hidden="true"></i>    403<br><i class="fa fa-file-excel-o" aria-hidden="true"></i>    404<br><i class="fa fa-file-powerpoint-o" aria-hidden="true"></i>    405<br><i class="fa fa-file-photo-o" aria-hidden="true"></i>    406<br><i class="fa fa-file-picture-o" aria-hidden="true"></i>    407<br><i class="fa fa-file-image-o" aria-hidden="true"></i>    408<br><i class="fa fa-file-zip-o" aria-hidden="true"></i>    409<br><i class="fa fa-file-archive-o" aria-hidden="true"></i>    410<br><i class="fa fa-book" aria-hidden="true"></i>    411<br><i class="fa fa-file-sound-o" aria-hidden="true"></i>    412<br><i class="fa fa-file-audio-o" aria-hidden="true"></i>    413<br><i class="fa fa-file-movie-o" aria-hidden="true"></i>    414<br><i class="fa fa-file-video-o" aria-hidden="true"></i>    415<br><i class="fa fa-file-code-o" aria-hidden="true"></i>    416<br><i class="fa fa-vine" aria-hidden="true"></i>    417<br><i class="fa fa-codepen" aria-hidden="true"></i>    418<br><i class="fa fa-jsfiddle" aria-hidden="true"></i>    419<br><i class="fa fa-life-bouy" aria-hidden="true"></i>    420<br><i class="fa fa-life-buoy" aria-hidden="true"></i>    421<br><i class="fa fa-bookmark" aria-hidden="true"></i>    422<br><i class="fa fa-life-saver" aria-hidden="true"></i>    423<br><i class="fa fa-support" aria-hidden="true"></i>    424<br><i class="fa fa-life-ring" aria-hidden="true"></i>    425<br><i class="fa fa-circle-o-notch" aria-hidden="true"></i>    426<br><i class="fa fa-ra" aria-hidden="true"></i>    427<br><i class="fa fa-rebel" aria-hidden="true"></i>    428<br><i class="fa fa-ge" aria-hidden="true"></i>    429<br><i class="fa fa-empire" aria-hidden="true"></i>    430<br><i class="fa fa-git-square" aria-hidden="true"></i>    431<br><i class="fa fa-git" aria-hidden="true"></i>    432<br><i class="fa fa-print" aria-hidden="true"></i>    433<br><i class="fa fa-hacker-news" aria-hidden="true"></i>    434<br><i class="fa fa-tencent-weibo" aria-hidden="true"></i>    435<br><i class="fa fa-qq" aria-hidden="true"></i>    436<br><i class="fa fa-wechat" aria-hidden="true"></i>    437<br><i class="fa fa-weixin" aria-hidden="true"></i>    438<br><i class="fa fa-send" aria-hidden="true"></i>    439<br><i class="fa fa-paper-plane" aria-hidden="true"></i>    440<br><i class="fa fa-send-o" aria-hidden="true"></i>    441<br><i class="fa fa-paper-plane-o" aria-hidden="true"></i>    442<br><i class="fa fa-history" aria-hidden="true"></i>    443<br><i class="fa fa-heart" aria-hidden="true"></i>    444<br><i class="fa fa-camera" aria-hidden="true"></i>    445<br><i class="fa fa-circle-thin" aria-hidden="true"></i>    446<br><i class="fa fa-header" aria-hidden="true"></i>    447<br><i class="fa fa-paragraph" aria-hidden="true"></i>    448<br><i class="fa fa-sliders" aria-hidden="true"></i>    449<br><i class="fa fa-share-alt" aria-hidden="true"></i>    450<br><i class="fa fa-share-alt-square" aria-hidden="true"></i>    451<br><i class="fa fa-bomb" aria-hidden="true"></i>    452<br><i class="fa fa-soccer-ball-o" aria-hidden="true"></i>    453<br><i class="fa fa-futbol-o" aria-hidden="true"></i>    454<br><i class="fa fa-tty" aria-hidden="true"></i>    455<br><i class="fa fa-font" aria-hidden="true"></i>    456<br><i class="fa fa-binoculars" aria-hidden="true"></i>    457<br><i class="fa fa-plug" aria-hidden="true"></i>    458<br><i class="fa fa-slideshare" aria-hidden="true"></i>    459<br><i class="fa fa-twitch" aria-hidden="true"></i>    460<br><i class="fa fa-yelp" aria-hidden="true"></i>    461<br><i class="fa fa-newspaper-o" aria-hidden="true"></i>    462<br><i class="fa fa-wifi" aria-hidden="true"></i>    463<br><i class="fa fa-calculator" aria-hidden="true"></i>    464<br><i class="fa fa-paypal" aria-hidden="true"></i>    465<br><i class="fa fa-google-wallet" aria-hidden="true"></i>    466<br><i class="fa fa-bold" aria-hidden="true"></i>    467<br><i class="fa fa-cc-visa" aria-hidden="true"></i>    468<br><i class="fa fa-cc-mastercard" aria-hidden="true"></i>    469<br><i class="fa fa-cc-discover" aria-hidden="true"></i>    470<br><i class="fa fa-cc-amex" aria-hidden="true"></i>    471<br><i class="fa fa-cc-paypal" aria-hidden="true"></i>    472<br><i class="fa fa-cc-stripe" aria-hidden="true"></i>    473<br><i class="fa fa-bell-slash" aria-hidden="true"></i>    474<br><i class="fa fa-bell-slash-o" aria-hidden="true"></i>    475<br><i class="fa fa-trash" aria-hidden="true"></i>    476<br><i class="fa fa-copyright" aria-hidden="true"></i>    477<br><i class="fa fa-italic" aria-hidden="true"></i>    478<br><i class="fa fa-at" aria-hidden="true"></i>    479<br><i class="fa fa-eyedropper" aria-hidden="true"></i>    480<br><i class="fa fa-paint-brush" aria-hidden="true"></i>    481<br><i class="fa fa-birthday-cake" aria-hidden="true"></i>    482<br><i class="fa fa-area-chart" aria-hidden="true"></i>    483<br><i class="fa fa-pie-chart" aria-hidden="true"></i>    484<br><i class="fa fa-line-chart" aria-hidden="true"></i>    485<br><i class="fa fa-lastfm" aria-hidden="true"></i>    486<br><i class="fa fa-lastfm-square" aria-hidden="true"></i>    487<br><i class="fa fa-toggle-off" aria-hidden="true"></i>    488<br><i class="fa fa-text-height" aria-hidden="true"></i>    489<br><i class="fa fa-toggle-on" aria-hidden="true"></i>    490<br><i class="fa fa-bicycle" aria-hidden="true"></i>    491<br><i class="fa fa-bus" aria-hidden="true"></i>    492<br><i class="fa fa-ioxhost" aria-hidden="true"></i>    493<br><i class="fa fa-angellist" aria-hidden="true"></i>    494<br><i class="fa fa-cc" aria-hidden="true"></i>    495<br><i class="fa fa-shekel" aria-hidden="true"></i>    496<br><i class="fa fa-sheqel" aria-hidden="true"></i>    497<br><i class="fa fa-ils" aria-hidden="true"></i>    498<br><i class="fa fa-meanpath" aria-hidden="true"></i>    499<br><i class="fa fa-text-width" aria-hidden="true"></i>    500<br><i class="fa fa-align-left" aria-hidden="true"></i>    501<br><i class="fa fa-align-center" aria-hidden="true"></i>    502<br><i class="fa fa-align-right" aria-hidden="true"></i>    503<br><i class="fa fa-align-justify" aria-hidden="true"></i>    504<br><i class="fa fa-star" aria-hidden="true"></i>    505<br><i class="fa fa-list" aria-hidden="true"></i>    506<br><i class="fa fa-dedent" aria-hidden="true"></i>    507<br><i class="fa fa-outdent" aria-hidden="true"></i>    508<br><i class="fa fa-indent" aria-hidden="true"></i>    509<br><i class="fa fa-video-camera" aria-hidden="true"></i>    510<br><i class="fa fa-photo" aria-hidden="true"></i>    511<br><i class="fa fa-image" aria-hidden="true"></i>    512<br><i class="fa fa-picture-o" aria-hidden="true"></i>    513<br><i class="fa fa-pencil" aria-hidden="true"></i>    514<br><i class="fa fa-map-marker" aria-hidden="true"></i>    515<br><i class="fa fa-star-o" aria-hidden="true"></i>    516<br><i class="fa fa-adjust" aria-hidden="true"></i>    517<br><i class="fa fa-tint" aria-hidden="true"></i>    518<br><i class="fa fa-edit" aria-hidden="true"></i>    519<br><i class="fa fa-pencil-square-o" aria-hidden="true"></i>    520<br><i class="fa fa-share-square-o" aria-hidden="true"></i>    521<br><i class="fa fa-check-square-o" aria-hidden="true"></i>    522<br><i class="fa fa-arrows" aria-hidden="true"></i>    523<br><i class="fa fa-step-backward" aria-hidden="true"></i>    524<br><i class="fa fa-fast-backward" aria-hidden="true"></i>    525<br><i class="fa fa-backward" aria-hidden="true"></i>    526<br><i class="fa fa-user" aria-hidden="true"></i>    527<br><i class="fa fa-play" aria-hidden="true"></i>    528<br><i class="fa fa-pause" aria-hidden="true"></i>    529<br><i class="fa fa-stop" aria-hidden="true"></i>    530<br><i class="fa fa-forward" aria-hidden="true"></i>    531<br><i class="fa fa-fast-forward" aria-hidden="true"></i>    532<br><i class="fa fa-step-forward" aria-hidden="true"></i>    533<br><i class="fa fa-eject" aria-hidden="true"></i>    534<br><i class="fa fa-chevron-left" aria-hidden="true"></i>    535<br><i class="fa fa-chevron-right" aria-hidden="true"></i>    536<br><i class="fa fa-plus-circle" aria-hidden="true"></i>    537<br><i class="fa fa-film" aria-hidden="true"></i>    538<br><i class="fa fa-minus-circle" aria-hidden="true"></i>    539<br><i class="fa fa-times-circle" aria-hidden="true"></i>    540<br><i class="fa fa-check-circle" aria-hidden="true"></i>    541<br><i class="fa fa-question-circle" aria-hidden="true"></i>    542<br><i class="fa fa-info-circle" aria-hidden="true"></i>    543<br><i class="fa fa-crosshairs" aria-hidden="true"></i>    544<br><i class="fa fa-times-circle-o" aria-hidden="true"></i>    545<br><i class="fa fa-check-circle-o" aria-hidden="true"></i>    546<br><i class="fa fa-ban" aria-hidden="true"></i>    547<br><i class="fa fa-arrow-left" aria-hidden="true"></i>    548<br><i class="fa fa-automobile" aria-hidden="true"></i>    549<br><i class="fa fa-code-fork" aria-hidden="true"></i>    550<br><i class="fa fa-coffee" aria-hidden="true"></i>    551<br><i class="fa fa-cogs" aria-hidden="true"></i>    552<br><i class="fa fa-connectdevelop" aria-hidden="true"></i>    553<br><i class="fa fa-desktop" aria-hidden="true"></i>    554<br><i class="fa fa-envira" aria-hidden="true"></i>    555<br><i class="fa fa-git" aria-hidden="true"></i>    556<br><i class="fa fa-github-alt" aria-hidden="true"></i>    557<br><i class="fa fa-hand-lizard-o" aria-hidden="true"></i>    558<br><i class="fa fa-hand-o-down" aria-hidden="true"></i>    559</p>
]]></content>
  </entry>
  <entry>
    <title>Hexo资料备份</title>
    <url>/2021/06/26/Hexo%E8%B5%84%E6%96%99%E5%A4%87%E4%BB%BD/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="0a8d06975d66e8205cf75821054714e4eb56bbbf798d7e1195a42c0422ec90c7">f0c149f72439c7ef7e2db179cea9a9dc3529c9e35a4e2c201bcb915a8db6219f3198c6e5077fffd3e524c72b301c5c393faebea1f18f1ee8ccdd3231a29071dd05b550ae80197d94ac2e478751648d427aa6193b7c77908c8652403ee13dbc67937b37d6a9d66a4901cfa2d7fe783c909483e3effb40005f23c60966dba65d9e2457c861dbe28ee2707102c0fb1d87e94fe333979b4e1744ee1d3827c3ac0335adb4f1c70ab48efb91341c4da1d09d84fac00c6eb94b60b199ddcb53f3a3d04e174cdb894fdf2b43e94e13ee41c029dcc64264363809094b0758300ac623b2de404eb23182c585c9d57fa66b5d39d3ddf203e06dafb76724c16a80b683ee3e1502f0bf60745705c930fbfa54015a72d2e31b823b0177693d29fc1bfc81289a29f29a11d4055fe9918435fc1d837a98064d8304b0de44648005efed1fa951edaec7e7323ee3f9f20285683a987e513231a4019803f2dc5b60ffb80765be2fc0e877983370085a5e534c5d2043f11ce175ec2875e5a3de2bfdebf8d88600d71673659adb76550df25045970a40f52a348fdfb6305e2d6573816894e86ca2972a5a2fb2a9ba1a88ad621f8a473b96c1e752f17dcaf6651e8efcd79dbd1814df97579eea2452274e7908a93463706d687b073e192c3887f4cb435237e6541f277be7190d7993174cf5c4868a619eb9e4f96f2c85c6a507b1fc93488b2bf7a35dcbe8f65f7eb1e71486c22745f7eba410662e988b5bd17944cfd5fb2b98dffc6c45cc36567d04bfafc2e9c779207f5a62ec0b44585add1a7324f446b9e1cf0202f7c9f5035fe62680eca584a4494d7143dc8d177884eabd0ecbff0261cff5fa441d025581f20165b467644397da2c9e427e60fbbcfdd93cc9d864dfa7f5a74f3c94e936f7d80347c3f2a8163f58b6ffcd076a4fd540f3b7745b851aea53004b084d415e327d18fa9ca4d89fc322474e068e2fe79b9c6c2e4f2edccb013e3a51452e439172d62fcc0a275fc23eb8e0e559a63d7d2c78620a2623b8c67e9ebc8460ade15b333a473ea075f3cfa42d995c18a8146422d9fb0647d78102ecbc4238bade6d2d3e37af9426e396112d9755281c83205a51976c79e87ef85cf7779a633b5c4f0d1159a68d97e8d0786d08801d47edb5c801b2f25d4868fbf39e5e403000aa0607042412c3e781532e8d64951e9ebde92cc426c0f3907d04aab1cd8b0639fb1135c0d1252e6112999c8e9b96f2fabf338f53023714d1cd05150e12e8595459e22a1e9879af60745b8d57114cf63efd5ac86a8ad5f4792ef4c4ce2731f475ce8a41c37f17eb6b827cc8f01a0d93fa459ca6280dd6d9fd8015843f75c745795525650c783a0579e2189ba2ebf16d11fb0a51737eb074d21e18b89ec0d95b75b5e0d1d3802d7d4d8c59b1809317e5402545b6f1d2403891ac1f8ceec7ff3aa7ad803d9fafce2410fd8e271559cafb91025f57ae548ea3ec4ec201f30feb2524bfe8f6e6491dd59824c27c4ef04419e5fff01c0e3977504d0b9d1f938c7c37998fcc405558710294e1a519d1b36e4c1f317d9cddc788666cd22ee38208adf7514f858af6a8fb0856ea1ab26665af3f03a9cd4bd006558ab8ace64615704d3a3dfb09846bb7f8fede09cebfc77034651c2f31de43fdde68a7157b63a9f20204eb1f72ff56c203656d34aa8143d11720df1ffb1e3bcec299542aa2365faf0ac74473471405ee29b69714c8fb58159dbf6611271ec45b295e4df8494c5dbd196413c321c86c70459fba7d2d5a27a8262b6265d8f151f03cd9b31969e21573ad94d487afd1b97902384be45e608727016303885cfa7a207ec72b1518b9881c9f909d138fb2c66a3c633efbe04af946d44e8980da0d54b462becdf28b00d1d07a7b0e052bf262f6aa8f4de605af16b3cfd283ac2feae8ac88cb3758d988f71d3eec9604b3f50550fcab3797eb148d5ab0f553735f319d01f74e8e2a2bda11c1b0ed7d5f9408476cfd46cab86d358971021fdf4cc78520e5fc744a2bb7789481d078c9b140cb38e92c792e83a3a312d4da01bec793c9df67f14ebb430198a0d3bc684539ce311fca5a5d24d648f2e4e3f2595f16555222575681e6b545fb61cc9d189a77773689c5220042e6aa59e5fd985e2824d9628b1b13405f132712de601690b182c73f65b7aa168e46cd9bde2e75b776156cfcc6cffc7e103bbb12332c38d80beb8d28bdce866b64881552fb83dcc7c77e134f72773107ea237d2b8ea56d389db7be867d8c0e0bcaed21136147eac5534e6b555e44af8c6be0edb3cbc45c4831f1de3943ec8c4298902737768ed677b14fb7eb8ecba6f8a63ccb3bf834e73247e23302cc9a9d561e056e3dce907f89d01cfd19e8180f8bf4d6193e6bb5c74297071f3b416ee8edbd4c27c2ec9e0060d98346998619852275dfc51ce3f85810f7776cd353cf45ae42d7c15b3607bc1f64f56a903e0fbb035ff3137f28a266f04c6f2abc5f195869967a767ac186b6098f2a081c6f12b36db2649b6059dbd7f5c2aeec0574a0523a0315f47166f409d097928c1507730e7cb324a01652f71ee33bfb7f1f18df0eb1c0defd435bd10745253fa92f08fa62a8417d697a8742650cbd2697f4c4486478d958660e39ad4bff7cd271c97dc72c9ead3e3bf8079dcc55bc100f05a90420981334567be6e868cea5298c225fcfd164a15313544b12dc836d5dd93f3c498ee8298800f1807bc57d4eb8a946e07e5961b50d27904c3ea3191b055ac4b346c9dd962a997ad01c19e5c1672dda11713fc8de4a27d71a3b41b39c45adebbce8146b332e07141951a08e35df18e219851a62d788b56fc860a9f3dc6119d434cd0acfc698226339f1bbaa481b884bd1c65f983748ef3d956ea0ec6aa249d35b47c40876d98fd168f06db28c8ecce349d6ea4953351c27835cc870b2076c9a14ab350e4559462fb900d08d47eea60d82abb2512f02963df05a173de57eaef9ad9e0dc42b3a31f5173743c9d46786a8d52395b3866642ad4172ee4e3996af6d8e6c18692fba362adec32d02370b10295a8c791ad07fbd7dd4dba924e607dbeccede1c4687a8f5847cd560431426b0f2476022f4c7301e0e2e313ad6c2b3223a844a4a3567a9487c0d4b6679d59df3cdd09fb376b000116bdd5e204a4a2365521e4a08569f949ebdcd3afef258776edcc9f6413e1503afa707f7d93b4186c39fdf835725b577bdc9c3474e282c2711cb48aa60b3cd6cd8a272ab021a8c29a8dc3c1002d30b70ebcf6e9f3fe82a171a5cdde02bf95f302251337d695e04d3ac09c1fe24cc65b8e54f06c1382c12a379fc65125a242b74f7d1af420b0af4cd3341ed8518dcc93b97d10cf266378660c87aa9b557031fdd9df5127b397b797647da0c329aed476cb0e3920823498c26c9896a838d3ccb99e71d8eca5114825e4172d1b03ac64898b89666515e6f7b8c52c4e2d1fe8e3fd10ccbc2a2b85cc33d56cc7f25d73a0935c0636355d9498dc6100a3b5d3a45ba1763363794c70807c0bca4092af40934289f44d5b1fddc4795fc08718b21eaa4afe5f2bbafdcf378bbd51036288f254c9bc998b4171d72b427952e821745bd3bdec1687316ec55e03fe45a2a02941b128c16ef08581376fa520e202ea9254b9bcbafc4ccd45292b1996f4278915bda4fc81778218a41474d3543d906c653b063b925340575bda56f57605b9cc14c1ffd9b529fd186cc1952722f7eb26af2104dfa4054c459351596b811b4f90cd4091e3baae0e7a07aaaced663ba65a8ace1fa44b650007e5e55af1608afb9271882ef1be3eb03749643878dad6b8a3e9d6d67fab39530da883023a23e41fc84062b3e9151c0ae0ff3947fb311c5d3034d2885b3ae59f7e5da13357a01c97261386897d139e2122e793e393ac2a6e272e5d4ef8c0d29fe0d82c2de118fd4b17f0a98e09ab44f0f3ad65756b5c2262b05f1ad8d295c4722e8e831b84673d0e51a6ecfd7c915e503c196341a7e6192bc1a63001c0b82df9438983917d0318a5f45293b3d74ec9302d960b3288001aa922aab67f5959402f073602b8b4bdee24cf8ad20bb10167f8b96f5cadccd305cdc2e03756accb627685aa06bcc862e72b9c372804090da58279b24db4755193fc8ca58b621373f799e1df8ebf066d319f5c9ac50f585148fe270c0ba85c82be412700f9226588d7e7ed84c3c5157d8d050a500dd829d778bfc3ab418fa1e1af8ceac192bd134466cb3fc9530d72b76711237f5998974eb7ddd10f85c4a1133be3fce8324a1732d7a7d2429149316c0ecdc2df40065de62e1d8d1a1c909bdaf426f561dff4fab80c262f30b7eb96cead0acbb5454700d9042fba74b17dd79f435ce2158a40cfeb471e4f075bef69940fc4f8ae90edecdd161c3954810b4d2920efc29f51ed77a5b0621b6d580eb645655f9855606fb87e4bc089d6180e77aa3019b4c15adab165021b9493b4db358df434e79ad8dd3689bb0d08b00b9c343275f201c716bc21bc2c94620b157256dfd47e2bc1d70f38829197af66d6a3b375693ae02944fd6330488162295605e928a287c2e975abd9a874ca0b392967386d7ea57ec2a3faaa632d8aefcf929466660e2d3200b9f86ecfb43b8a7281596d9f07bde10eb1578060a29b653500fd98bd9c514ade109f2c170ba47f7356abbb3fb15507bc13441150f3524f94f62175364ac45c86562cbbc3955f77cabb0cdc1da92b4887c552822eb631b616f51629f1b57287974623583f884866d6bae92fce5c80795f5ffc63609eec3793dfd4f8958812396a9a67caa7347bfeea5167cea3d37a8b9ea37a7ea9e1c39a98a39a26fe2f8aeab7b82fe3f93b970025bb76cb8f96c3e2a52e73b10ae48542e2e8b89b68809e76567960c27d1a8b67281e1c755cabc39b080a04899df664a5022c9fd575c51176d9430a6c7fe45fc28511d25c51f5d0cb21e547e4a4e61460a2a870ed8cdef77d7e58df705634b9a04ac5ad27609c200a4d638a9c97faf37a0152e0863b1214699b6ace0e2ae885c1a783cb72213d03b52bb0e312a9a73c087c2d06e4d478a253236507c7423e214baad25554888c14caed21bd6098869841516166cae9a041dc22446b33154ffe7900d588ee137c38ebbeb7e047ed72c4728625707d9a9fce5bcbf5cd81a936cff573ce9fc99cdb0ec02fac2626e2127dacde3ce78fc661b2b9d4255277c0ab0ada94c5b648305eff637e841633fdd3cb5243225df0817118f8d875c3140c7fb9b65dc79cc282da982864e807248799847c99198975cce5792353b1013b8522a56e488efc759330392e4c9df7f53284eb20610999e95796bd42ca0db1cd5ef1533b643f00dcca93319e440e36ede8232d1997f57ca4b2118bd593dc42b54bd284e398deb9c57c3ecb2093f9310433f735271899aff3ec9055c1cfb1aa96db90a6a050c84a31a601823b93a7b2a0054b92fe6c87e87dcb0f8e39b0f5c9970116db78e8947af147269486725570bed4f7ba9e911913f5f2af0ce96b8e38715d35866be46118583ecf24bd9be33f50636024a7e856538e1ed3aa15c283b537fce29d1bcfac14862f559903964dcb22970ce3d7bb2e79670885e7ffc52005470aa00a7f7df6231dbad6f73d87b96a408360cee9461746ee16a6aa0506cb7506feb272d4dac02fa766c8ea0ce32a42831cca8e60ef7ce362e66f94e7a0feae45e71d975d4ea5e7d444a88598d16c691300a91f6dd6ca0c2b4f894386a453ff32e9a35806ec1b7ac69d4b48d6f7221f2380f6e62016f5b8e804051b9caeb852793bb3616aafc5e16283899613b34f04749f4edf86efd4dcfc081876c82f7e2f15d121113d4596407f21bf4d5adf140efb9b26fd9856c24dbb761d33c4cdc3e44f492031beacd4f7e1115d8cca2f52b36fb7ec4802bf6f83b3a07baac4493d841946f7d4ddabc05dab4722feb83481bab4214b45ba7635d1d56583055d6eb4c336ab6666deb1de87f8199ed5bca3bdd82e10be9d0f949743c465ba720fc3a498a6dda0b5116b8a9c2965cbd859aa64c715a977139cbe0b5a0d865c712b886af45e0f413e466253f48f0c8318fcfcd5b8d72247a92422909ccc55555a7775ac4c42c396e57f6e7a5f7abbfbdab4a9a52e1764b1317ea912e64ae1eb9f643e830ec29255d6906a6a65558d97bd8d64b691e55609407a9cc360d6f8ee88dac9403a602a86d1f43f224a5435bc21373acc65191502ad1c85cf5a1b0415d88b99a9b0d56325cad0f67b094bc9a8d7360ef7e34f0002874b80ed491a9c8d56afe7953619b3b959dc3fc4e9177c8da10ea10424fab501e5e7aa4ec87c06a29fd1a0d3898209d2416d6f93df03a3d0500478f6b243c4503eca964a765c955d9221b395f5273c15528413bd5bf91753d441b561607f015b1e0fb82f3603f77c113f75275a8ccedd99b86e60f3662bf0dff99c6e2a5b6f7dd0488399fe4cfbee89a2ee3a94493de72f86d1f00aa5c46bbdfe6f608565c658e1f4d60b22eeeedf7ae8270e728fc3ce6406a857b8678a5a459de62679455322c3776cd574511b47221d3119923fca79eb30e3216747ebe0a7d2a47342a4df5a8d7691a7b8eb2620387645bb1929d289bbabf7bdf1fd2ba6ba20e18765e4b0497058a06dd91dcd816b9a64e357089cd0442743c08f48443f9420b0bcf74e5dde251fe92ac342071554cbbc4e72c2d018ce083ac74a2c4158c99564c93eec4f99e59bc5fa197719cfd90216ce9d4e450e26dc045d483d5f26c2e2c574ab28d7145bc627138698c857d53d28ecb59d5d00e3e4272f0ae55e38a7c9211f9167f15492a46b2290389bc802f1eaf5991e29d80328b65cbae20de998e67cea5b760b7d6e83d108fb10870b214b4202d48e2d10240aa851cd66c84778b6eeece8ce05d4d8c632d95b2c24a66f6c488d8d53ce9a34aed1d4ec57a00956fe8a9070e7dc2c601cddf34de69b767462b4fcd36b1ffc20c46e5868d65ba25ab580c2db77e6eafe61acff667f387ec4d1b2ffc3d5dd9a1fb660bd4635ba301c4882bee5170b21127cfa678ebdcc81d0970d6bf1b6ad50d24474bb67c485841a505e3c266f6a85c3122fa36039f0e8231b1cf713af95500e6918f02bff2ab50ed48db647ffff85cefa8e7369028151525fec1f4264cb48188f399ac6d29ee42a0569a17b437c1760902cb2f75c2a554a613370994979f07ba2bfd9bf71c2afd5c5975d8cdaf6c0125e125bdd4f1507783b1f5a4086d94d78c5b48a5cedb83af6e78829a8f254ebaf84d68eca48cb98e49972076f776e2df02337d0f765aec8b92717c7dd2af6be052c9cd4da3402870f2f1ae96dbdb665cd6c4f75036da1d634b333428e15eb011991fdd9aaa4958a6ac53958a49af80a003fd35585914ac307bd540a343a4efd034d6fb420d24e4f5d7b2287f1c482dc40cb3ece7e886201f2b81e031ba4d0f33651c470302f6edaf78456f167e35658bec634b9d66a36fd6983812fbae8b30f23cfed5221e690683386c17e8f99502e74adfa13fc89b5ea8818dfbb0959656be50c0b9d6415d659842a0b34dfd03761e81ec0e7acfd95e5de1e73d7aad94a8e5ee66d10bd5de9ddbcb8ad32420676d94e4fefb079bb96fa807ea3f4442cb7d73c3f29eaf659657c186389c1487626266e3c1dd7382d439d111e63dbb71b839c18c96b05dc5177e537a4d6509374ce8957b4139f9484444f3c8a4d2e322a842aabba4481e815a0079db0431b8485d90e3198c7e4ef2cc1f6d1155da967e6b3bb688610f66e77fce1952a36f1eeb57a2db5f6e305e21e052c9fa50ba35c7bcc87aedfa7a6b7da556f6cf1cf69864e5636f870a839120781321cfee692f4c3e3777c57e1ea6ba741a62844f99e4feb76d98ab51aee996fc0572cd312fb3e48ea3c077e03e0b70f5f023e162533694043defdda78f5f5c5c53dc15ed162128920904b9123a2268622b8ba1cd2f5525e730fceefd63e03683419568f49c4f96d30b66dfff7eaf13615c5fbda0aba838ab2bdd334cc0c4314160778fa85d9a7d896d9cf188e0ec39a22701ccd20e83f634e57884a2635aae59bc3728d722b2e67feeaa7ac561617dcfa4c8b528b9bef17f396acb0a5d91c0a0641d7a74c6b09793d769c4aec99e9ef9ef993c0660abc692b43cf7efb74ea916009c59be9355022fbccbda26a8b74cead43f407e5c77906941977715a07a119044a6a9d1b9dba3ecc898f9904e3a001a7ad4b46882e78abeb26c702dbae37352db50e4b38f9b6c15771a08cbbab58fd96a6dec022b7275286606203bbe4a1b89aaec37aa9e9d1d12f3761111c5c80ca240d61da388f0b9fb9adbc21070e98d990d95586464404f8e0b1eb1f4bb69d39f6ab1b246570cb2c592a7e6eef871f535a7f5f8a2fcadd27bceaee163c9461247ec480957b723801bccd44daea615428e092978dd31fe77dd97df4611ef07abc18bf49cf5fdfd7e8c2ed0e84a7868f29bde13a04f01b941699a63ec73f738e1076e8353e2963cbf0d9fa6c47330f05ec058cd1bf648c5ae5e18fc9f9bdf650e69cdab5e70ee06c8c60ca0251839048b9d11be0cf4adbc6a0e8bdfccbd716022877b6cf261cd571c9874d0a06d6259d9294eac36b59f596926bb29aef82228da28a3103e884e5866a590ca80a1d50c3ca2229471fb6c69edc490a74fa89bb5fa0503682523d112c977e12f66a0186694dc6de5eff76d5c9e438bedd9e27e24c7c9eafbb90dd0126d7ab1075b245c23eeab640e1fe0cee8881ec1ec14875210a64c443d2535c7bc7e487e20d93877756b89bfa9f80aec8202a32f68cb3cce20498f09c74649e3e30d50ccab4d6697ead97b7fe69ca38dbf3c6c5540d4128fbe5c7cc37c9c3d45b4fe8c207769ed278a2f0193d09c7765c967ebee5c0ff7f15a8be7f8c0d302ce0365fa6feaa1719068a9711d21eee28abc17f64c347cea5589651668f1cc7b2d50ea4ef8b88d038294cdfb3eba5714317efdf36daf5fc9497c5081c7354abe4e65a4d11b2206210bb136e1a0f5f723e95d0cd3a779569bd231f7463b3d2312966fbad64853f018bac0044870d05f3919f854f49d7d2fada49bf6dca6bc5b5b8c6e9295c38960a6c0b99f715f7f47e237ae429d13681ab6c31de9ca89ee582c91b700a2d7bcd143159d2b8eed955060e5e6f58f4384e2fe0f54dc8e2f65046b1d2a7cbaf746b6b858a419b5d9fc5df22e26858566e6f26be1e17bc8718bb59438aface25ac11e8a4f2e9ba3edf309b81869aabae753df271d1aab6aaa59192356a4e4ac793448895ea44db14fc7036764ad0fc50bbb84f3ea47e0e070cc4219b6863f67c1cefb5f39d94391b9a57baf6a9e9b27bea0049afcb02d5a0ce50b9e204b8df921788213c23a8676155d4f90f06293248ec962d38ebbde6199d7f856bd8d341266b87780a074199997658f85ee6ca2e389925136f83f90bfb04c6fd3df784dac6378f9af85c1644ae75a51e894cec5522e9d39c3e531ab72fb87b886345b8d00840c2544fce3d4e219a133bbe88c0d211f553b6f8b0cc4c59ec856f2cf4eb57f133db38dfb9cb60246e69abadd23a77d5a00687f19363e95a1f2c07c70464c5ab52ce927ee110e4d1a381260f37c1e701fe458f5e38d4db79b3c857b26735b8c904fdbda53a728ee51f30b42af2ab66cd51a5b1b44c05e31e27fd4d872e1a0c07b1b171eab137954c4fdbb39e56d56f2429904d2c5fa97c9b4cebba0ca03e0e6d2f63ae3725aaa87f790fba86905ba42abaa26bc59542a69e66333d8bb654e149eaf31706c323fd035822a2750d5f6b1f7f88b301b8b2e3a8d7dde6d67168053b19ec92009c8fc6163af35f9c60543b0697b25fe7b482578655e976f35f343ebb19a140a2f693ad012902e9fa861549f248f92508cf78405bd6185e6d9c165617221724e7fb8c67df2647d08171fce76193e78045dc16a44e38c858fc8430ff290fc875a70ac62456980711d5a4c57f71ef54258e7439c79c430b80027216a75273e96935f9e17cc0a51763cdebaf5bc981c42f5298ffe1ed7911f90a1ca5d0a9b89a9cec404db418d392799c26aaf6d36689138437dd58ff41683480a95f5450b5de395142d9deb5fa6f6c665fa7fd393628b2f82b19b70e5f1d651d2493fc558f8f626d50c7c2304627eb5a4f31c6e82318ecd168f37d355ab26aacd2f18ca3a60ff7dc713e661846ab97006c7a7c41f7aa4fbc71ce8cd8cb322a3768b3eb3227e7f5fc415c0770dc19d00ac3bac0b2bb2f3141a8f120c8c34df2b642fcde8d72f7e0f6f5e094430f35f1cdf825d2adfc55abd8ce16cd07eaf82d4fd7ae7e6ec3b4db682559d562bfd53ab37d5dbf4f6f524297ace8ddcd4c90b6977af51abaa59b7ce975c21c2ad54e4dc3dadb7d2f59021f822352079b8ecb1cd772c5a9b9c04fa60e5ecc367c7f896d11ad01ebc3597a023ffc257d7faf255bddb7338fa958b17950d3f42604504dc39bd22659400c083707a5c4721214203d6e74146e21ca9e71aa59d96df289a74c8a0e7b9e71303fd6e218bf5c96112b04bc9b079ab13b8fb39ea88fe6c58957f324fe255571261f0b8ac566b50e051354ddb19a388ad35248784ae4d1eee036a036a6487298b85c80c401c4be212fd9d083c4fd6d4ada704d24ff6165e4e7960cd3421513d18ffa664d31a5bee4c9c15e7866051fa43e9a8e4511a071be921664013a6bbe3b663257d135aa125fdb58b0f18d2be74650e538b83c3eeef139e9e7d4bc2033532d32fff5fe0972bf8f6461aeb611e935803690d78dbd332ad23de5b2e0b9e52ed48a2f465eb817d4b69eea8cabfc0421dca1b2217aedc7aa7a92d43fdf4994fd7ac30a5f6c30cfa84496fe7b40154fef30f57e42c93aa0370794e6200ed79ec824a184e8858a24262fc188c7d41f4bf20f55565e471777c3a920bb07e5863b0fa6a5f166b5742a1c4826a69290cccd489b74a5ee0cad2aaff8084efa9d7726e38216cdf71f6d620d8e56aab491db0c6f286f6bf9d66999111224050b8a36aff7f5f2d1ae4b4e045349e14d9f0c9e1085b285d9d146a42e7b91a92350b4cf5db9937bc8a7e8af16e1a306c6a1f5643329a25728775cc158db9ff7cf91371e9a6e3720e24ba756989ae804c5b91baca43681e04eabe9fb8e6fa08f3ece1ba8b90d7546affa5886ebaf314f1650bc190cc2053490dd264dbffc1cf4f1fac20116d4502d430b61dc50ae7e525193f910d12a76029eb5e2b54b929ba7ad7b5ba6a62cc2d93a360b8493b9f0161da3b941765bf3968183e959cabe1fe1c9597a8a3c951e62319bafa4ff6f01dbfd938baa86611c3cdae8497a8400345230d7a7f92b21021ea4eb1554754b771a8f79b112a657cd817fa85271976c199260474489282eb1f33b2798b372d67a6d188f87ff8fcc232ed996f933403aa7aff8268f14232b138b9ec55a830db192fa1797e3cb6fceb68c6bc2169000cd750ac3b7bb46ffee9c92b86583645beb074b68258a2c76f1b0c80f9cea84a50f9d369aa086c9daf225da6e0c0026cb5ed0670aeed739d3a970fe029f83140b2516b3bb69f8c042b1a2a4755f6202ac1dadb05f40d76b28be78b114276c1cc27e9ec8d5bf2357924f77643baa99cd8fcb56a65d78df3f6aa66830d1f70365abb3ae81cc96ae1468888c01e033b0d48844fd58c7079ace85d9b3d189f93dd0521985f49f7638380b1cda7aebfd8c3d9eee289fab29af07106727cde626420c883ca291b293f72b8ebe254ae96d97873833536cf258e7443737cf60d866b26d72fb39537d2ff17ce6ce0ac45271592e45707deea9a08593bec32104a391598d8ac8fd9832204bfcd9b0414729179f91978f1b182e4b3e31bcef8123a9c6dd9f219df51f3eae4b46198590f2a4853462ed5eb3ab2150b0918376e38a1ff38a3d33bd631e5be644b90ea35213b8f48a6c2762d67a6ed0532fde8715177137d0b635adf9b09409d38119be2556a5c8cceb66c20b7002355163c54d642c3dce5a12c2591ef1c7635e9d78efd3b93d9ccf8a0d1c669afe39443f84e7207d886d7cce3094aa464645966ac7db09be3db3a58e590c933b271ecef47f27378a74ecd5b5a887a2ce1721fe0f6fbb395f7ec57924abc4f7fb62a519a9d1bae1996488fb4abe9019c4d944fa0ac564c7be41c356576039d2538c333b9bc86dd498abf76cbe7386c416710525080f5cc11b803f88780f35c5b1af2d026f6aec15a01dd03fd7de9de3bf9991fc847954445741ddfcb0ba5720bce30dc3b98a0d1c1aa4d633c3b76c98b65b4b4754154f278d14f3a81b1986bf1cd5c2caea55794a9ccf0ae894aaffc0ddcf39a97a96dabba0b8bd6a7e58727474ad5e7f53fff341ac360ee39d7f94fb2041cea7003f84d133625cf38c4c953df5c8e34986e554ffdfe4386c6a412a6ff42629dfcae3bb6803ff4560728442ba08219d2f52be61cd05350dbb41c9db7157e5a8ab8e0922895d0fb112067cead6bf98f50e75b59f4baa0d61d32f652a1f77e840ed80ae9801a7a012e56cc65e3418648d947ea6df5e40ef958f28fbe53ae01f2df62c607edb535ce16013675f24fd7eb19c37289e9304f0f95a66f430bc171b513573a17c097f52a3300273522bad19222acc07931749a8d28943723f58c11c914443b7311437c242a4301718dfe28beff227369ae26a3d11cd6c0f4f0d29346f98322cf4f1480c13209aba04df490d9f73bed630ade59ff0bd3c06c4b5bb13435764910b96f898c23c1366ef504f12b64149958cfb1c9a2ef00a67b2f55f24ff6eb7dc15ccf2d754f5f59a518081e3d2401f259c9e6281bf532bc046d29fc114af973f3283a3a9657e555df266121bdeae8449c6eff8847e89bd5504ee147286cabcd8d31280a48caf14fb16466b99e90bc24fc7d65da6a1cd65b61374386aeb2635a9a7471edffa265a1e4abecf3f5cd942b52dcb6a91e1c9ccc3eeaa7b1c1fa877d1f90a40b85e22db524c03aa5521f5a5175c810bce986056849ebd809370bc10e765e3f92e01ba50e3e6cc9fc0f552a2d1a04aebf8566330001f9b3579d87542762a7e86a58ec8ce1398a26d95a20f4f505fa0c89bc2261f93475bfb97c2f50220a520509e998affbda6f018eeaa45e4e224342e3797fc0cfd235e571c819cf5a387754f2a9a5a61249091ae6819124d355b306aace578064f654f74aae3d712926f050b366728f012ec719ecd1504177f4ba5238db6f27af066970bba1f29f2df3a3844dd5ee6631f0f34d39fe48360bfc6d57634a65ba5c450c321942e2faa7617dc2a48fea49b8ca9c15c236310090561cc46ce3f740ed92389694d939402ef2120120d81ebdf93ac33fbd6defa15ca5800258732451d8b83896efaeb05101aa6e3e6adc549f5ac1677552088699a6005fe46dc487af3274af92b637e6a93de79d0356fcf912dfa599cdb997c4ad5e8aee77cb15a0644cc42a2bc47868c022ad03ab8ac75880196fa092ef6cd9b7ebd83592348f43d4cd8ef2571e88a72d270892ec23554d774e8f90926637eb7b6a0d2276a0baa6452e83a211d59663253805421868333660e5725a3866b5269fbd614b8e288cd4453b3736938f5bdc923665a1969ed5b9a7cda06c3adf7b1341f40af67340a707302b18196341d258592502f8cf81c6ce2c91b3a6746ae7e009046fc9e4cb4fdc2d3e0a20cdaf1b7782d0ae486c01562d27edb0dc166c98090fb984fe18a8daf60b8c61507d44cacc64f2422558d735ae40c56f4927e8aa2a0c866344d1fa2959b04cdaf9bd15e7c3f2f31cd5420aa086a1eaf08c77f8ddeeb3315822483b0f500f61094cd0ccce8a4d0bc0450454e724d4d940c9b62b0f10e48b590116e73c23f5373d33144d02280df5c658e2646dcff0f8173de590a385a07329a0a8c102f45083d9596c734b7d281ef2c7e4beea73d048f5216377c6efb92ecffbc45a298b3fd551c12d404102f867dd62994469dc0e9015f750c130e78cbbab0693c6cbf0cdaa8c5a4f33f5d64b9690ebd247c597f204b47740d8709a25f138edb07aafcf2aad65cd2685742b36bcd002bba78ab0e813d1804bfac8f69b413baef0f188054398724fdce4c8e97746f00e05298439e8dc6b1471d9bcad42d528088e269d6ab627e33a22fc71c934b11e3aaf55e5238f133f7521a1c6b09ceed2aba8905dfc5347d7c384d8f6c95dab7a54594acc356af47dba7175df76250290c2e5dc380e895ac8d5b6425720cbbf336eaac5521be624522ef92f8bb5be824afd61e3678c7926acb60929cae7a9231bfe21f94ec172a8a90c13c852a3d500103153e8a37ce41284e41491a32b31aebb8fe4f6d20883be6f7abd8a6cb5d2c5a4440ea0feb06bff5a14424f522c004352428182ba9f6fe15e2f46991096a52d0da14923c11352e8a20b71b1e5b35e2d8d79fd490d3a70298c09e53bc53ccca03cd40893cf03ea977b7c076e30ba92ceb19fc3b1c50704e026e59376d2884396267cdb4f49cb0e5ed6bed1ba592af3a96d4d808dd064f931435d82e23a37c9fe656846da83449e8873b2a206dc01fac9669175c128fd151fe68748e40150ad1eac0b945dea8ccd4a01da1c5749da9653a5e89c2f3552b24bc13279bcc2cf2a9fd05af7db9a8305704feb1fd0403ce5071fda416453d3951a63ea9c5038a7f50cc8c82bd2858a2a9ca724c652cf0cd2fec2c0a8aef0f83f1e319dbefd8afdee561bb5831f02a10ca1927938094e3bca12f1f51f35c9977a366c5400422ae7e51e7c9efff0e252a21c7cfb34497ec6c0a4ef461cd6a7a4adf96d1cda0b643fcd1f34f7d52decee6192f487f939b5db5b00545332e76a12ad8dcf18e89bb9e2179711e28a830f24458208323ad5ed3ee6c2b019422dbd0f96879c25e4bf2874df9b11ef0847284088f17ee557f9cb487ed648f38b44582d624b69eec37d366c6ffec33e1703fa9c59f03d738bbc7b281409439493a418b83da91c2419e033c213f8f225745435735f43251beea83968ae69f313460989dacce4567f0d1439f6c481239c23d636d0e182078c1e13fbee987597dcbc6a3a8a745179784d1422ea22872b3285a807256d99513c0d8acb60be194c8fe949d6397077afc76d1ace235f0a44181ad9aca302895f14fe74965c79161a221a02c36413c1c30bd5abc4f27de13c62b9947dd4962012388497029a08fc8f294f3d3fca3c88cde0238668331884124bdfa667b251288431ae0120f77e12cefff604bf1a23bd692b404ed1ef684269ff2ccc95a17c8ea275c2e15bc137906bad08490eec3c4e136c9ea2278ca0e9e0b13da944bca055fd454d513c3cedc95366597ad489bd244ff3e52e72723cbdce195d6362e50edad7a7773a3e0cf42d070cd2d8b3ab395fa26578df439275ac64793c5d19d3a5ec041cbd42ea1004f66db4d272a651ce001a24a24a245c4bc70af1cbe52f13f0c594e129002e83862cc0cf954ecafdd0be9301bddef55ee95e5970d6b369c3ceae343e1196e3243d87fe5ebe47e139919f9a2199ef745931563815cf4bbbdca76350b30b4b7fca47bc73f4de459a591357bf177d9f5514ea8605fccad2efa1e9f0830cdaf06ce13ff9dd22e541ccc3f982f1fca3012ff8ac1bf692cc98dc20162ac8a81bcbe9f14dd4b5e842703ed782ba096338bdcc679e6ad8befbf72d91d1e9aeaa269b54cc255731bd7cf0bce9297db40f19649a5b3b0a61271e0b6612fc56890dfc33e40239b3428ffd7ae36d1e813b2b81e4df511a22fc71584b64f3a4ed67528daa662dbeb2f3ed57b6293c4324c2c4241e91f912545bdeb79d725ca4df18c80a3be369c881821faa06a39932280413e2efb5eb9f7e2da73f613103cf9e7028e8652741179a1f11f2ab5e78bb832fe904e361bac634ad852c34f706cfded83d6dd3afe009894d3367576b754f3caa90291ed7fc5ad8b68f679ed2b6a8445617912c9ad1c9f91b9b3dc10b2e712a14809e446d5a1e2598c9b62e147580be4f478dd2f6c909e0df9954d947e8aa50e97df639e15b84ee1a910a9f75eb337dc0ddbb194974f85dc9ae2cbe6d27bc2017de0799288fe463b5f2655d4248b7c4c9239d47566d5b7aeee3aba3231282278261deadb1e04597f9c4a57840bdd0cddc901e315a44e51beb8a9ac8ed104b4b1212dc0902f73d7d60a7710ed99fde2c8a119c710481f5fb6c14f71d5240705181f4dc789fa5f179966320a5c4ff40e20017b706273968d570433cde67b08c3ba7ab8628fc48dba83d32507d75193dd28974b938aacb4d8b14c1a1cfaa65bd8b6e11e2e3ee632d91a990732c8284eb046a1fcc9846d1b85f0caae0e6c19a75aa061ee4098705b234745ffa3eb3245ed3026e6d2373c807230102dafc52d41690d47d82c2ab9a206871d71dce6376a8aecc8f27f02e20b4e79536d7e3a7d8c12d660720b1f60efb1cbbf4523c31dea865f9e26b532860625119d80bc3296a7d8d41625faa8f2fb103462dd8281ea24ce0bc9ea9dfa27905e143b6496e096960f854e69e88df20792a30089fb7d9d99080385c574c6419f9dc836072e37c68e13303ebcab32c61fac8bdb0c09357c0dd847472589fbdd7d505c02549e1a65e62a33462e21ff4a8ce6c207c3810195561aadeecce8666136388ca09c3f6bffeb6707bd7229402f7bc526e147f4871dd60e2c658931db13657beebff01aa8897f886746a0ba656767b9f5db77b3ff546734235310cd66bd6707888d1d2b9c78e1db7fc640f0550c38f27653e8d97c9c33fae303d570d48e12d1a411b1095a91e26e55acd3ec4fade69fe3fe0b1f2ab2649991d93288cdec4d16ddc2840227ce50470207e0aefab94e967149dbf8e8e1c22283c3ef845205154f10937fb9ee222387eb65c5502e2ee587a45c64c558814bce824f6e231f38b4d581603d54e0d7b8db86c94419750e1017cdcaf2516198d9517df36a4e0102b12424cf7527baaab16ce0177350a9c6e0c97a7c1a8c5aef0336529e587101de1386db8827d715e0955c68d58d4d16e9688cf64777f944b86a99ebe514cc7e3e64081e4eea23a0eafb8dfcca787424f0959cee262b5fbf36991c471b91295d29333f1f1d3f996b8ca5dbac642184ca8939088f8039a1a5d607834cfb7d63940362ec90741ef763820c5fd15688bf8165b9b3b3f6e4d5c9fa8fbde2900b980cc7d5c01174156fe02fbff7358a71fdbd6268d719999c630bce25e3d546fba413be6afb1d1ffba9e4ef6eb99492bb5370eb95ae9ce03cee10ac5d62ea9b6f8fba46e1bea162f888ac1808e2973fe90ac9451440172b57047ddf0b25f2e3fc18ae7406d265822acd8489609b36bbaadc3b24b57fb344e73690b3dd2004513444a0514b4ed40ddb3f4500322100f4e844a9e488dd4f7bf6e516699674e6175b7fbff9b1d6e03812233fb3404bcf2101d1b57d99170b2d12cd5b1d58efe479235a42d74432051f392fd16e34c88d4bb7f40a408573225590ee44b0f8182e8f4305fd7e80df03ba0618ce2bcc97b9e9a9dca65e53d74cd7de7eb25d8f4b5ba52b438111880afc2905b5338e97450acaf15d659ff1d493b3e2505b5b7d665243ccf7f7ce7dbd885e173be3a9708c2d39563fbdbd15cf1f1d3df99295b1345f3692710ec8914166447fe3fc6f28c7ee9ce4de01b1ba5d71b48f15fc483e26873dd27a261c91f41044e40db9224ad8b7413313c68bb70ecce9e27b976caaf78b346bbca6a15e92a0bd3cdcaa69084fa01446e76ea90f4aeb203d5e788e566570935509c9b0f38d138f7876f29fdd3dbd8d2ccf420ed572f28dc80333af4e621a08372fcd740103cca17f7efdae42258801ca3d652a3edd91e4c2ac67d9507df921ffcdd3a09666a78d3a2093df08408b3987d4615185be117c275cd0f2d6c21c8dac80016d08d2dde7aa5f95346681e3824d52319f98d69cbaaf96d00a00748d45578baf6eadf0626363ddb9c26f1f9e2b2b82d2aa10600cc0d456fe59018ae2e0d99578221cb49d75a1fecf7d94a01768303d69a3b9c9792986d899ca22f7993d995f29e8a80fbbe0a6fb17b1a81639e58b31ef7960d38587cbb5466ee458de34700733b6d5f2fabadde88ded6f1f09de3a60e6390d00d3950bd6a6e9c0a7f9c809f1b1ba0e876b53493cac442a97dc310f9b6dc2c0c54cbb914484ffbf42a4a6f4cbc532ec2819942153c58c81a97cb4cda369926bdc0a0c41580b61c7fb1eeb7059d81e49b3363baf3ca391a0eb5083c980097015419116ee55fc6d9df2213707c13a133828c71d9e1c3e31fec8dcba404536bb3a984da56146163fcae31e300f825361b07d64891de3017dd67cf01b4e9a5f340060b38998a3d09ca1f95d9cd2798f731900e71413b5ef7e46e467735ae6a851380b2b8e2dc38e8a0cd60d80d4747702429418dc8f8b21e1f6ca58e0e76ce2d175d85c2f667ac7c41a4dae68a6fa25a5970ec8b084d153d710fbaf1f25ddc83889bcd4015156aac105dd4709c2331615090a33eae418fa392ecb5d53d97941770e49f7b12c24a1a10456207f3fd5675afb941dc5ab940034394a7d681c0771f6159fe74216053c0822b748a589e5a6d73b688196a7ee281bdaa048404f76691f05c12040a16478783132e15b8543b977485836f91865ffeff9896b58569ec8329f999c7726887daa547f9fd23f21dd189fb55e6113388eb392561c78480915b0a4c389e57f8935e26de176ee107c93341b33c821b184e347b8ca48c54f81bc4f578492a1d9b7845e9b5f109a36c89d561b0a675a85ee4d09e4eb98d9f48abb3d4d1eb5bc2c241a9691272101b550112c058692b18818714d60e04a4747256a00efdf738d63c028a7c8f559f17e7d3768289f1f295a394f08aa2e3575a2d6b367234e7567c8591e5447943fa0d0c4e6a5ab07c93ecc3118c54c6ec57cd49ac992c6eeb5adeb4180d16fcaf6ff238c4daa4802e0c769acf9994c16032abb4b6759dd86d69a9f8a8a006f193b5ad2adec412f41035c2494dc44bb3a94a1e3b48ddb2ff2580789a62da161bdf987bffddde156c8eb99399955b6c6bca34f1b2e98c7f6563651a01b5f08af7a59d7bd357dff378da75f9d9094caacf6cdba2b6fff65f2ca3630d9fa78fd25f13312381eade03ed0f6dc4dcc7a0472d1beab1abce79c7b33113fec511f2402de7facc08444062338679d07bf1a7db3dd66f198a3870c99313bc206818716f0f32c51e70c9307b640f684b5475f3a5e2f27546e154755b0db8cd9b3bcce48c9d3f0f503137143288850a1a755264d745cc34b5811a4f5d2972c69d2bd830fee4c2ee700c7c28b60960168a1d5222d94ebe4902a670c9c3b241085262a5ea4a0c6eaf6e21ce31e041a751f666e11bd9d977ab871775ba917d7090edf8a11fd5469f2823a84364a8e41dacbf8cb30b8a7f93dab154c3a3e4830f8ebab7d11a1b333cf8b641d6fb961bb270ee1ff84b0630b79556c103e4572cca413affe510657714f27212b2966c04ca17f5e9e21864b71a1bb6cbf616bdd5182330cbaf8fcb7c3f821a2ce9a9159ec469216f565cf7e6c07b3cb4440ae797179769a9104d8338bf32ced8cfbc2a996ddcde7cb44d23c139d48da292ccc94640e56a1f38bff6169d4dd3fad3616be92de44c83cb6e451a2ca3bd1d879e6a1a9ccea1a11ed72c13197af3e8bdb07c5e729fa9610e8dbc4b093fca502e5ac3be1530c2935b5eb8570d57686a7dcac343d8520596eeef5fe3906519b4c03e35f035edf9460a861715dd9a040bdefc6a52603e4e10313a7980110b2c5574aeccb55016a25981ec5ff5c08f433782fafe4fdcd534b392e17c3265b46d1630d6501c4a3ddd6f16c83016150ddfa27ba1b76a247ab44039d032da87dc5c4ce516d6f3b8812707a1c8f43d1a11b33b4df325c1af65444b6b9822d6b8af97042d6f2a6c80a57aae1fe38e49fc00c29b22e5fcc43370928ca64a4a168243a546f06e88ea2486bda6b9359cea202c9ed1b06b19137426de7e26f5d9e40474ab818f8ff06a3be7573524dbeb2da148c267c705d34e6e1d40c1243a547aade079a35d48330b5b897611fca335d37902bdeff2a86c78712fcd905faf086d4d0c1b0fec4b4ea9ba024603d2c2aa7ea3433a081af5f002b7c72d8013154ad84582bebdd2a2c90684697b9c7b4a5eaa19981a7148dc27f34d242ab0145d7d76ff5185f0439907531703a9008666ecbe77a94c1201931fa3ba985de9c43d618950f02deff1bf9fc6152ca752a1fd4ae120adf26c291f5871c57c9d27c252c633d70c1d290b0e7195de7e31a2b9c603726346914dd8f45c35678535b62e9b8dcf2c6b07531c614e778b32decb4d38c976dedbd1b40d2cadc6ca7336fefe8f37fa083b76b0b4f5f7f03112f4f88775a37fbf37c8059ee3be5941bfef74be3b114b12650657375ffb222d63e21c7dfc1d7f73c75f57b5c65cdefe079f4ed7f027a8c8516b91dc30b10951580e041043bf6cae5c55d08da5351bfffae31c0222327603920c829d4de9093bfa4221b23f97eb0e66c3edc36d9490a1ce1b6015623456a7fdef9f5fec2d3b241f4e29be82b8d0822ad69f11fdc105c45c58e20fc549a450a339266fe70554a588a0fe6f1c7b7be5f3b9d3fbe93c7bfab4193f6970cfc52c984468be33b506674e3346108b93482987a5e47791ffa50af10ddb63e786c6bbe229784d8d80aa20046e0fd7005b4432081a91716804339ab62081ac82a0aae3869ea00c1f4ce504effe56ffd2471d5483604252be71cfb442b3bfd96db399eadadd8ef43e0ed737713187e4128e7d1f202163c80a9eae728507b72b052faf4ebf7f0217af940755365a9c874b0e32edfe6f2a4e18b0b79adf89a5bb1141bfbb5ac9183022ebc5f97ba3ac1a8950fcc771c3d460d3757f40cca68245415796b7736065ea743ed8095420cdd230135145714b6be9a6380e60064e82b291596555b890526ba3559c8ae6d8a61b414c50f8867c013ce36f1711dd7699c04e5d75c4e3f1a7a0175728669f888f5a24630f0d3942b64f37f0a4ab70dd57a6a515db139531bb6980aa041abf6d1a202509d7cf3d84dd608083509d0f7258ea38eb21cd2665f00821f5f964ca8acaa76f7434ceeeda7fe007431a4b77203e0ac6f982c30052bdbbca88063d125b14cdef4e6f64b629684434e60f6ef0626b622acb1efe20c04fcbc8952c27fea67db09c50b5f7166357462d818b670669ecfaf80a88c78133673d44bfe0b6ee40976f12370e76cbe687caa9ac34aabd6e58dd4a2cf14436851ec40fa9565c957897e93021b9367ce3622b3de51b17b61d2c4f82a67302fe4af19e017acb13cc66400dbf253ac370bf245ac8906c8daf757b9cc286a54669ffaa8005889abac86afcb82bbfc67ef9170716def09539634e44439f1e59822ee0c28864f5451c508603bcfae1d2b8b9b4373fd9fa2b913f74e0117634ec3bee992b5740f970d8e86492c5fc27dce33edee4c1c26f2d537003c177958eb3beda52b4f45e25112b8cc6929d9818ace8876c114f80d4fcfc23e6d75e8bbc280445a8d561f1612cbe478e03c1c8610c3d570105e4e65828aadeee3bd7a9c9af90190d301383b85c4a762792079d21a74644f2b71685b8616b401017b8d81c09b69cec94b7f53a962d342e8415030522b89cddb10de426df456dca55ec2b98dd6a47af56e5dd0372cba68d40a86bd05ca4090a69326b185d5d349a6e3529bdc7672d1f5e21f688efde6231a73572c6cb541900118faf22bd88500624ef09397c1cd4c57b7d52d9b45966b54b0877b7d32b546e0050695269ede9d989fbfc698a35d8a01e60f2f05d88f109afead5ab6e26c2d45ebbba50400eadff874512b7a6f1cb3560a7254af60e0604d45fce424f510547c3ee15fcbfbfabb667b5ba575b416ec853d2dc75c6b458f360380c4932f060a937b31bcf828740fac31fddf829287848164c0a59482c87def5b6983033e27b4e896017113cc1b8dd4564c2b10e40058608f36138ab1ca0a6e518b346f8e4bee4e1ccce07f6b1e5b16cf56365c6fede8d8724f9240aaff5a89d69cdf4ece3ff0326e02d2a67ec99c4d561c371dd126d13e3b865d744804d08fafd368c21e0079484966a3d74e92f355cb9380b7fadf82431f6ca28ce620ac8f1378bd13b8aa042ade212e2ed2df4709a0a5e62f0bfa8d73701875bbb06a2f6b3830d4ec03ed789a6973e37aacbe613acc7a27d7cb275fc631135d4563af3b1b81f3dfbe9ffa8212db7a7e7beb82d50d55d1de690265bdb6fd0e9f342e69904dcfe2eb141a5c8bb571436911b586e8636836cd47def272c4288ef1c5fdc736b314a4edf45ac9e041f0d5ad67b9d8b77961d98fcc97a2919c2da7803304b9b4a9846e5b217a06739b0190ab5988d478d52e8eb14326e805de4a2a7cf72d46a459e657b2fc39b8484f8b9bee9846703945c035d3f89ed22aa3eb5c468ddcdbd3a80d05908b353902a2875e8f014af88b29e914af2783879cc14cf2b18d026260cfb11342b6aec033c3ca375d95f3c12bee1972d12d815617559aea6485fd3e5cebaa069d065fccee591300614aa85aaa77478e6da749d8c89f3d7a68106f336fbf2f52ab83f4f1f2f3eda2f8c00bc6e57378ff9a3db057e0b5a30b8de11026bccd0251a4393d5a2677dbbeb76d30394a89c7587e5d118131ae28792e17548aaf0798c97c1f626f0c2d4b91331729ee332ab0b30d211fabae3e5e0ce12f6b41500f5adb74dfec7a3efddd9557359d683909724c6a505043aa9aab4fb255ce998a27261de5feb4093b3434d3f9725cc1ac962e1a9f2db6eb57903d9a85bb8d456d63879ebcb9ba4ed818a5df255185528bc92e0e32f59e98474632500a7cc634f703daf02abaea647d73ab58651389efec841b3e5ad3f104736f455c56bade54ed960f967ccf316c2bd5a3e9477e1f63cfd8c690c5e63d429279daf13c4db5978ec64ef3c731ec22f2ea6f8d7c1d6d311c93a3e58ca850336c6fe90fd52a0a11d60bee7657789e849f7b801c001dd095517ff1442dd03b715f61f5035cfef0d4169839e00e74713a396713eb634a48321c041622a9447cf6a00322dc2c5da9a0a7e017df708cc7b79eff917a53d34dc627878cb545c8308a51cbbf183bbec10e7792141d42758c8c520068e70d370eb29cdd6521c8b646bea6b11641c4543c41e643799e580c8db5f9178d2bbc97facfcf47f63185c77e55853a8e03b26fd4611b86a5bcfece7787e73c20a393affdb7941dac8c896cf9a5db631b2d147fc1fe38cdc3027a601cb26cc2e2515bcc06002fd31b1ea3e3fcc02fe91ef0855ae3b29c5e386abe197dc864838aaa6ae452e30c2b92c5d3dd176b0ca30216bea55e421a53c648f7a27e6830743a75b098f1c790afc93ab290d54a1cae7352f349bd8b7a365980895aeb9d8591e2cc1203ae57172d61303233017519c5b2298f5c932d2381167e7e22af0f548375252d6c0fd0807209be74e9865dd31bfc8c2e5de5a3208f49a9c90de80570ae4db0eca29359d9218594f65f699a7a2b1d9d8160418abe13421b1b3b07bbd8fe738dfa42b827b6231a0b7d2a3913bcb82b842be5f1ee99c9ad1ce2e54908cb337cb9749a33d798a4cc1319ffbf1c217980740acce3f3398fce00659a14847b14522f72b51b6424497160e8e516a560f47903ffb16c1ddadd99f7e986b16b1b79c63ccae5a2ba117311984ac9cb1c1c8cf0ba4b5f019a61518a12d5d1f28f819c468dd350a78bc99174d1502f94d7662e8c8fbd55954a59e38e7b23e6e7983fde4cc40f41db5b1eeee25ff1f5f4d3ad037a82c43a7f175157f838b2b68bb2b5b320df7a216d959c88888fe0ac649c4ca8bc1e1cae68db9251cfe84a032e72e6d674079c13dae9e12e1f6644b9c46e70f0ee2a2d9c80d3c8824888fa048c1df9df58df4105d913e7fa209427bd8e3ef38f9ef1ae48697e97ea78f24d26308b32e426d8969558426fc4b4343254d34ce54a77ba9d61ad53559362176fbc4d3456a79994a5f0a901690c2435dd2307b8b0568bf53d7a8017120cafd11b9fbdb05f763da5a50989faa4ea2c739bd5f962367dd2590d529e4f40ae1d05010ab893d50e202921f78bb8bbcac985448a32024bd8010ee19d289d6ebb4d9a39627a14411e7528ab9bc99547713d3a5bfab3ba8bcd275c95734f97ccb9821b907caab67afef0b78545f90be00bec5cb0468d31537b6472bb85d2ce0e38a91bc614a50697842fd82eda1d1db3dbf0e7aa7e541d24326aeb4f1335500b3816e0c1c8b859abc756b7e2cdfd3ac48714b2c0f6dbc0acdffd74e5cc274cffa08e1e60340b892c57848435d1cbb3076f83e30de1b3904bfdf0e237b1350d706082b7f913c7ca7a9aa9eed8576e5a26dce11f7a060a185259e503fa543b7042ae312a5c6a9cd9295be67a6a97f38cd124ab007622b9abbed0d1dd5aa6b20c6fd57b5251ec825e8be30a426de8882e30ba552924966bc3baa7d62ce499a6a46d843df7c9a0028fc0276334a7868a656603a7ff447db82ff7630f54b2385e461d430b333b874c06a20a7208f524c9b181e50590617be92d3f433945bb81400b56120f4b5f462fafbda8ee5cfc7edfb7632329570340320525ea290ba70fb061645e1120263fa91fb9f4bcefea641d0a4ce8fdd84439fcf566f2de35c5efe7e48154fe7f94bd29307c7e346a93dc45d9bda2a402e181ba3be0c445038e8f75ac13a122e28d648432e318a0b54d3b75d43352568ee5edef87ca6d7f1833988028bec69db59af07a306783fe28bf8c54373398b8dc6873150014f1e8566d54eda2dae84f4a0245d7a21d55b1f87d3a1e7dbbb91c960e5fceec61f8c3fde61cd7da8397d0cfc81b2c3bfa21591da523f1fdff4dd0112dbddc43c6135977ae610a5b7bee191fd8d8d1204c0ecb870622e858fb9a9be3fc6bf0b479df9320624ec1d64b9afc113e13495c74d2bf5ae80882bbbdf46591346a32bb8110907f93746d4ec2f7fd174bb79218d8dd969b5c9e37fefa2a07d26d01f309912d1eb83ccb3939c320e5439ce1f8ba747468aa8c9486b7169ae01c99832c4acb6114d30af093cae8b0b9bec649f853afac3ded269c589930f2e6f18fcb8b625cfa6bd86ebbef813111ee954fc35b9da6038cd973a1b995c96832d8194d0ae1467c32816eb99b1b83fa55d76be5c17a422f8e388f2e8c80684ffb61b143ef442b73c02fde8976e1227927a7e63c418b813cced7eb76ed32d341a9f04e9d9a6cd6d160e3d169a18aa29f647777f1b0832462c0db26c4626d1180f60a5da3a86804c537dd9f51612356f967827eb264128888d47a6a9f3bdbb2a2f75815811ce4c4fc2a71fbc3814bfa19cbbacfaab2e0df121c5ba5de24b2e3879e0e479c17ad43b0914ef1551534e9c40cf69250384e98b8b18e4b4d23107653bbc1a2a4f4173d44bcdbfb879760dc74ede9f60ecd34cc9132262d596fb7e8e3441351c4ec9337444ba4b908ff4f82a56cbe25d7d179ee5d1b6505fb736ffa9a203972cea074eb332f58f7f665147dab964846637859495f0b7230b72235880d8863ff297ff21aaf1c571ad55cce70aa336a9e1575cfe2576bb8fd82e4c2a5d1b221f90e028f7838da3e255c47a49edb0a1bb8eacf192a62db1f2a087c47bc1cc19412706b91e3f4d03143939257679290d71e62043fdb80c2ad585ef6a704e04b85f7d98ce71456f11bf49c6613212de9a78631c012dec750b62ca5624bfbe4d36a483a30e85f4b8ef2a4f519d43d595d73c9c925e6cfc6c47ed961075c5574622057bb2de6b7cd57d7e70d42268c9cfada90df0015c2571a57c82bd54ddccbbb4a72d14235f76ed0f96c377e4ec039ecb8cc8b6499d70bf385e7042c4817775ec31529cfb1f3e23d0f8c9737fa237e1557dba48f8cd0ff63e23e8265551f7fafd3373e3a2fe19f858ee2f0920914a4ce3df71f83121f1ec5275e0d6bc415f7c8fe34cd3c323654578715d04714a23cf334f24e7a94fbbb53e1378d425d7b0b8bcaef5c884453496dba4d51d7e092516c98a501ff98bb372b45480b2c4485c2c008430c4822b3ba2871513e24d7230bb94b157b29cc3d510d27f3f5eb061e04cd2aa69abf4c9576d6ce424782a81bfbffb5ce249b230bcec4f48b40383de51e0d29f9b0073ffe3c51a313f6025dc52b4a1f58673c2c99e532f8d0fe49cbd37e0cb2e3bafdc87105a3f659e77e20df79ec3e03741764fc19dbc8682c43239ed932d936b4d02de4d10ff4634b120cac41b82b7686de6c17a1c80f0472af410eb5e47698157ad041ea41e1c00b84dc65ab0170bcbec08391e0f043c500cb101a3346c5d9a9805918da7b816bac78a687b7efeb89c7f610072183fc59a07980ce3b34189a7d693c9e0264a9352d0b1734a2195d8533ed7567454bff7be9ea8fcb8247f100f0d8afe6319d9d44af9c16181a25508f454598ffa5f9c52f03955933cf70bd81ffe77f0d78248bdc669e98ef35e1ca9a2859b5dbf0bd454fd11bcb82bbf0418d8e414f80c28f8e91a7492d63cef57da6816e7aff59ab1f5f8afaec016dc616f3feffcb570b14e713038340bc452ff61cda6702e6cc90a9e419305e1297525af5decb4b1f5e323f7a7fc723eaf8b893dc9578c5e2e66987fd9836571fd1b0d098252b934331be62e078c9047e53da580753a04a435ec8a8842e2fdc6ae16fbc2ac6d25a5570379fa663ed21f0c915ca533e6905acc1f5964fd0ae503b76116665cd488bafa483b284ce705af62ab5493cb1148a77b852ba8af96920b0556e92d4ce18f2465636856d3271286239733d227b4600cd44e69b2ffa64ea1d1d313750e7502fe4f17e5d8bb283b5d1f69c0341e0d66738d6108ce9faba75f7f469184f2753c3c8385e6b60ea5f200bdf0680f9a4680957f0b8411994d17229a795b2f9aa5f422cd388351a44e0523fe372d0b13de883ba34074af9338a70574925c6e4d27154380adbf1ce00c62fec75fde94cc5b1b69bb7039fa08d957a7bbeaedbf2bb0713fa182c5a3044c3b90809a7e488285985ea5ad52c492668b3daf61d831984b6f46eddf2a398d4a2da33ca9050c86daf0ba94da8e2e974299c8515f4a356ea107ee35d646ad14fe812fede8c38f5930072fae5991f05dec9c32f2533e951eaccd41bfacb955cef61a775c8155a63acf1cdbdc4481cc1abf3e33452f6d6750184185775bfdad9bc19948ec75ac6ea1544f7efc0d2b369b8a74c2f635635e157d2b875c7b6ab8333a596bd4597902f3fafa71fb31b015a931ee105476e1c98a0037ee9eb01c4291caab62f8f0c4546b922c8a890c55d267552544766deb608620240ffccd5f570601ed1150dfba10b187ffd8d072319037440e96a77a82cd0807c969ca7d7217e81e4fbb378fe468afd9de823f439ec17b41c34951d579ab568fb645cac849e53ef1f55897984b53ca1426eefe6e6bf6687b665121812be5832f44e289fc7c0d82e856a71a4502b73f450004eee6e37dfe89ca85a161bd2997daafbef66d985c1b1608c1cc4e88885ba4f8eba4ff84ecdfd3c2ef2eaabcc11c06a26d8f44f3e78bb9a9b3dee060d63f6feb869487be9d2255f119ed3b39e0d9de5c42be0084ff46c809e3be106664aa12048c377926789ae78939489821839ef4b36ff9e0579ecdc30da65f6d111c288a95b4dbf9a8e9e4d951555c6f6f8a9b349f195bf1f4cc29a497c2e338a87ed3cee0d63f157cb151ee69bbacec99d1bdd3a68f21c8dfd40ae16efab35f259f0c6c24875cdd71dc24e164834adfb2a795d7628507216cdd0a21a55d4610dcee636d011ad7e2e984be831b5d635362991d1b0ab1a505a91cf251422c65f749df18783badbf943cf577d91eb1c2645f2aacd36c8dc156bd2d373808875f8574ffa4b5c9547e3d5811bbd772374c123fe674b2bb476304a910e6b1723c6288fb48f4c731a2c7bc387cab829f05b616ce9c273a7b28bc8bdd1ca296d448e38c4b3917a5fe80643367bc7846a436e2aefbe1822a5e65e4d198731f520bc27c5e6234edd27dcbdb7521428bb407bd1b5ce6fdb07eecae17df85a5815c72ef6fd9a0dd25f79e239081525f2a4b48d164479ef51343b141337d49dd510f49e4fa37f5ca233aba47fb7214bd919d9c8b3108396c848cc184bbb2eb695394879a843a56be9189b22d831709af6d0984e2e4f49e54aef81aebedca8f46d19f96dc725e68ebd29eddf1ac16f2d01167c645f2527ac061e8f48b82f1d394b27ae20845dbe670421de9b52efb649b3aada2474fd9f808ff7388fb7db723723f8e4789874854ab82e30ef7e6f2ec424e442e3418c509734035f066b3ef82e2341c129575b96657f984957de8adc965b40eb567582450377e0ba2caf7aee6a6e705d953cc6faae227f4b8bd344789f02c2ad6839fbeaa48be360f979d4adb6806d83da437b8df0423b7366a0451483dde019b44750ce8cb33eb5930595d0f1740ad3e56efa629cee1c11264d1f44af057e0b6ba7e134ebd0c5d53828c2b6f757dedfaf2f5eadc630a4f9b3da5eb8fa02cc59f98c9ddd94695e99400e950dbf43016e562ea12c0579f3a8b6c7a13cdb6379818d2e99a025ca2a6832988204ffcc6e8fa9ab969a48c66c82084cbb9168fe902dfd105c61ce1400de5ad777c06318f870771d5959c470813167ec0976fbf96db8653a15c4e87b6c66fcf39e7d44b119a332579c495e0337aa18138214eb0e72dfc26244cd2d260135e944926f2283f7e5e8e034d9de168294a4ecd61eb5b54681c02e35a926177ebf69d10bc76f4e164b21b25eac26cc1fef47ed6aa544f3e3c7178f3ade660de11a03fdaf053ab83a0c3efa318c5e351a6a324813b90708f65fde0a88ba4ea1586f02281f83a45ecc1cb971b500a167b3896ba41aab1fa78c4c133ee05f4c36bfc07a0bec10bc109c59f4ee6b1a3d2b7b7cc1e94fefb71ab8e2c802df18ab40e5ac630ab494ab1da014e3be51555f2e9bb8a836d6fbb1a5e95b15bef3aab8fbadfaae8a43626079d8fd3c22ac35c78cd67d3c679e9e085406eeb54dac82a4220a08505111016e229dbf39fe71f31e77cdc1fce7c3bae7953e55b32228c693f9dfb5862119231bace6e721daf4f2a8c30bb824a8ad6240ac06d59b5733eb6ed9719bf6136c9afd11899c912e605dfa0963f47325b122e9da62020b78dabdcd2ca8bd7b3d3b8a75a51e498bf179b00fa82e7945aac47b662ae85d1e6f20b1a50746412c92c9fe4245e708d70785afc292d4a6b23e8eae26951ebab0dc7a6cd9bb9db33c22c2b1ac87e47498fe5be631ff696a38de9b96c48b86744a293a1dd66f37c257f32b5a6a242712ae351bae47c479840142f89024f13889813c45364ef540f101798967822f0993fe988a1851e6ce5643f01ac899477c8a88d3fbbb9f0baeffbe2829948feb9e51f7deba0f05e3cfa5e01dab7e51ad224e4e03507ba128d08f5d73e00a3f51f7df8f1a2fec790014e8fd672adc1b057a5ef6b1d1d0b90ce27c549681bc90c38c5e18cd5ed0a905a7977bf8e9c0499a513074d396694ba13c4931165dd5769f539a3c820dfb867689120487e2a2ee2c6a25f78ea2bb2f401b3e32f7872fef4246720e3cb16a84ef1447cb9469b7965dfb4d9f837166aa675267798ffa91f47b318f1e324872dcb5f9a4d3e386c3a2679434ea27c533831c14c5f2404491ab27f7c0ebde500d8d772fd1f519d1204dcd4cc31d9fb74d8f273acd760e5fc7b8ac63884459068fc12d8ffc94e6aa327f8b480ca0d872e6b7bba35fc05828404f7d29a07a0e96951105d0e39c5f87fd04265cfa206d52612319adaa6eddd1cfe55a830eed9be61fbd0472f79dc5bb99eec19fb4c79150a45ca648d6f7f1646d0a9642576273b5db8f8c6df318d7453c598f0f389a998a3dffe0484c78defa9ff7e28030b197910f75ecf070d1e4dae9ef460beacf7773d7ba36d8173981e3a73c7ed18f10698a0afd0c09945c881bb1801309f8be9b94369221619cf2f48e5dbb3831806a5b19d3d2e5868e1dd6093d28ee58c21116ed2be31877cc9a978eeaa33b9120c014cdd1033b262804b271324f4fde601345565d99ee0923a69357a0df5918399f7dc90a8d37f02cea3a7eb2739f423470582fbbf90a4ec1b0fa8fd542f03f9f84f4015bcefb456996436b81981f7ee0c13d6830a6f1f71092a981393805f132414ca4bf030a262e1d0e3712416f4e2cae9718351dd3817e8696a968f7ba930f3069f4d74aeef8590dd95de7c39a5d7c51facfe45dd68dcb573c198bf19fd22de38b4589100093b0233e5a8b4f3316c8418dc17dfe3ec197cad649157e2014595428694784899f5dd9727e78895dc150d4883b9bdc13daf3f013953fafeb37138e988112ed8810d33e8f7521427ee44edd90eaf2dccfaed1ce18dfb5a580e7a6369fba2546cae3a2aa76eed718bb590bc01b53f44034de8b3041794d4f8b27cde24be80dc4f97ec195b660c45dc4a09c92d532733eba56e3fd808f81e6234206371202e9259c154ed323ce53885384b2708f67220751792b6db029f26551b9c267eaa7b69353e8306bdc0511ad3c02ca96374acb3481aee52e6666fafc4a597c2ce0be83dbbaf10611268085475e8a4cdd67ce552de40f466df0394705d30b685d46a66884c971af8cfc8e4606c215d4e0bfa405e9eea73b31f30766a25e20783935ae7981183149e17493855d5348bccee42da5ec316594c321fde373c8c849dae37629e999b56bff49ff0a5d9d869bf3dce3fd53ce5513aefd55ef9376db7a5cf08fc5cc0fa7020c318b0cff79d8285eeb2bb28acbb3132521065bf78658bc77f298eed2e77c5f45ef08f9befe46eaf1920c3a97a05cc54ba2e86844ab47cf9033dbc859e281a7d05ad14086db6ce54918398f17d6756f4894da7b885dde4c3b55ac0ff181cbd34139e122c0dcd12b7200886503b3e5fee48929bb56171b07d7397055be198a745817accc01afba2a6ac173b8c1b545324584dfa688e3b241d15a031b78d6b0ae88ce2fb3801b33c702ed1532fbef5caf02675e2e9e9686315c5a4e70edf0714766323624817bcc6f93052642c99b765e7292c65c9c4239679bcb696ff8ff763767474c4a046da64e2bd94f4aeca5b30bc022087aff042de2bbec7d9c1183e7d925be8a12eb2dfff478b24c11340c0ab5bfe3b20f6a494d8b9c1b6c1f67c54736958fb35f32588180ccf476962f5a11f12e59097d0ba43df0385565b5a181699c409fa3d1e496ee78cee1c72fb3f99d05d52bd0e4a9d27594da52bc82af1f0aa01b2a9ddb4dc4f966ed100e02d2556a54ae3dd02a2241f2e6d4b36e46faa114b415e1b99f0a158e8344d76dff5cc507dce5a0c88545f7aff674e51a51b80c7b3b44c266de5084317a2db102a7441353be2408fd9e2711b5f6e50bd081da5b00a503439868352d715b882bed495478e9c64f3597d7e2ebb1190fe7284c4cde1cf659453623e340a484d7afeb10e26e0010bc73779a161e0648de31d3b48d9ff6fe343310f5a3d9b797f4404e74ec624911aea35b91caf117f756ffce9ecac639f4c10438d062fe40b2c23e25fce8eaa93951a28ec6bef63d75a5a1adbf3492939ccf25bb9c729e403bf75c44876ade07ac689d154630aa3d44f25a4070c0251730304d707d04d61f7240bb25d38b81da5040ed143dbde29e5de2b8c7a4ab74186b4e4663bbbdc5a6deb71a252175de7717da94ce2c28831bb866b222a39ad49906a6487c729d41a1d23e1d54d2fdc884258b66b2bdef31ca68129efc826928b531021eb043ff9fb2e3ee50743d529a137a0060f817da9a37069768211fbdca12400e6ee95519f49b197bc39e0a22966c998a44c9f646c317576e563dc71b2b56972e309ec0b4f22e37b4696b4c43779c88bec9effa554a4de2671f3053e92a83f90bc74472223a84d06fdda5b0a402d11e9ab047e13d986bd4758ee10166c881a5184dc6b7b77efe1cc1c66e06c582f465b610fcc303478767be366096aab7210c0c20f2e22c0c8c74100a16ef953b7f4b50341ac6aff4d3148d033591e7cde43df2a984768be628da7b806bef4ca78d0193a0e1a17c2517b14e8497738b532f2a298ce2f480eaf34289e3a757c11be54663708a7f512363fc64461c68f323310b118311af10a05c8acd6de8e50aaf8d2ef8f251c39cb9222489b3153f200cf946f45a6d65ecd58803e23227fa09500897087d864acc433999981b2785bc995c517431a6dee8518b4c986d146085ce14480ce943665c7e3ce1c17a494762f0ee5ce37e1e258d7b7a850be50074f38e3629645ebbbaf7fd1edc431f27889108ab78144f009dc5a3864a025c67a679811fa6d47207dd2d02b2eb7015f85a29c2708bb529cf04f72c48aca8360b610b73fa74cf810d559ca23b50ead6da318141fa1148e58e179c9a6a6fc51721057f87d196caa16302b984de32f2f5445c0809701a9cbb38fe0085374f5b56d93deb3f526f03a646cbd71cb2b0b93cebca67884a3334827fd40ee70f504799594586e0066cc0adff943a38210046e4f1794cf67d77896cee25bd872958dd14f99584c5a16ecef2c702e0350d0cc8ca25278abbbbe4d439eee05390373bc4166a57cd29899e23f287296ea2cc2b053a895a110425274d891a768fa9cc05b1d62418b868b46c769ab7ad532aae71cb96340b0f85e4d6cde883c2b3a72ade3a57b40ad796770953b4cbec544a6dee2384b8fa833de82af697ab78e63adf41a0ff762d93c5ac949bed3bd0810d0138f0b3388c38b3e8f3aef860c9ad795f50da07a5aa2c31505d8cd98c20c0374cf4a2af7b91c9850506fe2182553c8d4a076669d8362b0ed36913efa07da564e31185d67151940dffff62a6b552d03cc176b407343a8ec71c5936f9cb8aacea3cae8ceb45c6182dc55433cdabba63c319d347064663a9634004436e77676a54ecd3f801f439b5c9cc531bb7eb7b88f06463e324a4776f6012738286ad83e35949cff4e2d1e3fcf39b9c673abbb4f2a8b906b78bf0ff02f994b92f1d6abd8ebdb5d154c618dac823dc71ae78a63ee6a6fd98462d77af1c1b92697abfd8c2802d1723562ea04c60ad4577e90adafdfb7c641974d787604a8739abd58245c90a89fecb793138c7c76341d147969c651c180d01f0fe7e28b5f347d0d4dc09d072a9a6623c79e28be20b98b1da42efddbe9a0ca679a9594a258c5cab2e2bd8bde84d55d7080377c6320c5525b91b4863d1ca4b13ef85a2918d8acfa9a565be74c9ac857171b0b7dd11647796eaaf30c6cab365afed8f812bed812591488f9188e3f88eca4f7a92cb36b607f12feaed63c74dac7a3d22d7de1b6e25fd88f389b1b8179eaa36f1b5bf6c833ee94ca2932fe7f08cfd11e51224a7647f8238989231fe6a13ecb9361d54963059948c2404c7ce5cf785b1658d64ad0baa448a6c2243873f5a934921a097887fcbf15e52001eb03c8e9e60bc3e6e926e1a96bb553a818c7cdbda092445541e727c0f00ac415f68b785c6fee7ca971e96fbce26060d9a02724be93fa79753332589254efceac83124c424bf862064c6e38bd3a4e25fb3530e84c9d8e63723d44cdaa11bc556acad0bba3311ca52cba46fa510e675f9d2da2924e95b2737faadabc541540836af9dad73ae356adea0b7e5bc7fc97d4bd16298c928ac0a1d6e16add6061d14494e5aeeb31d29683417b8a1b2a57c87d01207db2e592f1307f3a08edecff9395f2895e81a350bc8e55bea01b8badbcf99f712b9efd1c4d70a93f993610e551347cd7d51df884a843e0dba612ea5ea8dd687631bbdd15590235306d371e51a433cba2988de5bddf7ce53de4c1c7870a3df8050604665c2e08a052d3284f0d78db53ac5c1efe9c89b54df120f7fad547820078a13d682657916871c2588fb57ca247a7d1a1f06be97f5abeaafa4236297ade4009f25a5f736f6cd65cce3400395c8e0f5939aa7b37684a03aa0f22e540d6f64d297d2ac8de32655cea31eb8dc3cb26140a1d781cb99f681c80bdeac3a7c976281d98a048848036095925d3b51aa10e5d8ff1a12604912f93ab7674b5f172844fe70c4750a3fe1b96d77895fdfa67bea82f3b3689f33fdaafb0c52ec84ca9a5d9a60568e8ef7d849bfc197876211611b4caa3c60572fe9d43b7b85456fa34e6987b775c5e8482572970f8e92f4a0d899ef625bf9be8f5fdc87755cff1aa917357f8e7870f0989dbd31d7c000fea6e12ddbbb54f501a4ed5ed490ddd5fac9c3707dd338094263c16cdf4e1bd46dbeedfc6ae4fbfe3e690e1b053c5329aa912858e2ad0b112c59d354d1a764420cef89312105a9a94c2c9e7ed8125b2e970343d8204b40efe4cc7c666b47aa782501dcb1f6682e3351111cb31468678a4c78ebab82b10ee0f9bbbfb139cc1ed9530b63f3b0bbc4a5f4b69bcb07e95c0b9464da85ffec6a5af6e3347ab66d97c675b59f317da199d9c4de5d94d1fe7412407f5cc26a38a58c740eeef22b9088fbb62455d3c36fec6b78d5034b1dc00d453b1ddc67e6c293d68fa29b00d454055f7dcd15227da5600c4438aa639b3760e5fa2b6ebf1a63f8b23e2d0c23006561837069ecdcecfcc9443b22f6a313cd059df0a699f178dd305fe009db3ab3c46b99db33f820daceaa11eb20c701a55056fc9ed50d83cfd7c7ab5e7b2b6d42b436d11d02aa8d966317ddd97c4a21ae734bdec10cab438096d4c071a5ab16530b59bc5ef0b501668db83c8f674315c9527be5f094dda51c8debe698aaf2eb3647c59b041b295f78b1d034c166f4bd9d24f9fe77550ada6df16defbbbe5a6952f1e0a011f2f77dd07d6bd1303d6ee626d685cce0d0d033619ad3346f03900cb34de149bf173bc5e3bd6639e2fa235129627c72486986b69ce3b40b5a7ae081d9a29d93a75e09d6e1d328d2374c7ac9cb851502a9c2104769e1bfc71f4a8ce87f698b61d472f6f214213bf6779c35c4f7e4a91d3d9bc4a6439e17721cdcce24164cfaa4a84388a5a538f588867f5510474a3689cf6a26e803d83154eba386e204f4e19aaff701362aedab4eacff750c813995cd61c197467f141e7d1e6be8803a3d97d15bc12b380e4564a891a2dfafed3036574b5a3fa45a41353e57a9d7f7dab8789bbb9cbac6f8e2669f552047e9f0a288945c90aeeda82373a44ca9726d5ff5d26ca2ad8114c8900e02cb889dde09f947a6400e7a5a2ee071ef802f42adcbce449061c99f4b9a0225c35da676353d01a3e228fbe710ebfd38fab7c2446573b3604f7b93ca585dda749c15c2e05fde01035b546d996168e34b33bf2fbd2fed5ba580b1c0abcbbbff50cd86f185dae81b92802c83dbed9e77b3cc35d4600634e5a185aa39beb6161c3f4bca8b1a004d8cbb0669f06a3e1b8b11044a855f823237c3848a880203de94cd1bd12fc6f71faf2d4e7f98e3a272fe51841c9d62d6913a2bed5735d623bf948589041df7be7bc58ffe7e36fc876c4aefd39ddd3c5410daed2e58f75f010e4c2ad8b8d633c0c62b174667898f938babce1ec216646562e60e550ab5cd2c88fe69e63242d1ae3d86e8ca687263c203df9cfbe6983b825d814155ba0688ca6cb94c70e47c0da6fe4e5cbd5e7ece27947ce25d277157480312c2cb903393c08eb28352ad62d90a858e800f4628b10d339c7050d09dafeb5e1e9291253c79b1da6f1df03219eee4e7d5ea5346766a201b5ba4aeac437e863dc509da51974e6ab5db09bbcce7e35b4a376078c1ceb0d2cbaca3d17a44d63aecb89d5ef36dc77f9107246bfc0fcdd0f603a965c6ec7fbd8baafa39470b69d4b3bd01bde8bbb099ca12ed377f56dc161a906ad7539905ab5d0d4d3725f712e915bc9a6b1d5c926c999278ede028d79a8cc712f12bd693d716665f1af68ca4fde4ebc2fc167ef8d2a946e41e593bc514abf48dff67db95a4552cf6b373b7e6dd4835d89f2cd2e9aac6900acfa1351f72e1cfdceb306c72c0c549a88421f8a6b67e027eaf475999d651cfc2176946074cb9f223f4b20d1c1adfe617fdd59639a29724458c1f476cba0989152b3ea89ec6b1c9c02425d3b4f3823a2718a0d1227a0f1c073b38b0d82e89cde31de443e456ec943e20343395a03c4d29baffe4b8e1e94f6677ad25cde1e95c8ad1056272cad50fd9e98a5aaa022fb8c5ffdcc43ed6a3afae0a063501b3d983b3494dafd866104be2a6e65664890c06d66ade2deab948deae7104182fb4dd0946a8ddec8c9233488b9edb4c785af0ba9af8d0d10c7f59a7b163be488e30ebe7e3860e55ae3551f523fe2c9b70f6012299ccfb6e43bdb2d74db984a3bd0dd3cc2d2b31a40c4dce60bc8675b103832aaa4415d99b31c5833552804d53dcc6533507fbfe9568a7360ba01d0d25de3f59d838465975ca730302f4ed7285b0b21214da8aa4d6e2c2b7d7780f253257f85248bbcd6ee077232a9d35829ea1ab2ca3ce069ca35f818d6c7ec87cd541d1a424797fb15b0cea8d93d2a99ee1cbc10306c4e68bea6b528b0b4e5cc15536041151615746eacec152060775710371cdad0ea1d9a63f704262db713572070e378278127cab82bffe6672d0d0de953b20d34d30c962de42fa8ddfac61af0d88ad567a998dea45c11cf60a223ebbdf1c61f83969deff9cd015c84f01fe6e0f9eb62a8c7e883434fa610cf082ad7988dc1c76232787b0f019c69b808985b7494a79a7f0595bb3a0dae1b571e79f8169e78c2f942e5d4b2d7f6cf8d462ee445547af66d5ad005f4bb727ef5542a095b2c1b9e5e598836e0ae9d935190610c885c65b164e84143a13130a3d3820a9af8a65c5134e2e055f19c4c9d73409f3cc0365076e90ed5c51136c50855ec233d4a3165cd685b2998a2ec2a11a65b8f1da6221e1df6d3ca96e39d141ec85182941696bd8bbd87b441e79fa81203428888aab696158786f0e0fa431bf0b1cb266090e48ea48066395a41e9dbc1fe8a86baccb9535354ec57296327b179148033e042b859954f9f036e7eaf39a16cc32f60aad23f2f52f7df4bf6eb77c7c858c4ca4eec9093cb537b9b3ee31304dfb7cd4ff408641270d613527ff97a8f377bf826426ebafde4fc356786149fd7069130941bab9bc213ad659eb67dc3494f9f1f9d983edf96370c45b8e1afa77e767135d730a26d3ae6bb4259096ac3e2691338b7b59ab5bb483a16e7d8094f4adc60a9fa06849ecd8bfab2fe7940a1168f9ae8dbf97fb903349b69b62254c629d590695df8d5b86e5910aaff34ae0db82bada345bcf7ecef7b9efe4d391005d63ba46a53135137e12f027179d7e363799895badd8635fb72c627d1d29dc0db73ad6c0ccd6f8406281b039ad67a3c62d4abe5925e19ad79668b405b59e4c70c23ddf97350bb6962acaea3fe02eb6d6c812285772eadd3c9ca5feaa2c8ab213c1dbc3055c8b76b83f9e37962b0b31a3d6e886f5da12313c699a1fdc66699452a2255a28d4c746a3e7c1a4857c9254bf6398864559e48d56b28b88a65865f6dfdb9abda7d91e2f24533de23c3d888cae4d86b6455f0d3a957197cb796550215bc2146ffe4adbfa35ed306cca26532b85195dd26c5c40df04e2bc57036ad4ad735f67adcec2e0b77bd6db816eb6a6ebce2fad2f8507ab62881a5ec1637b252c23b56ab2d4836748f2191910109294e9bd8a7648879827f48af0d31fa28296c921126d60c08cb39d26b2e5e115e9e437760198931d695d844f62b302717dbf8f07f52e1785531faf767557868026f7dc93e87fab76dce3b979bd7a07e04c7631e13b6b6bfda86f3aff99dd2edafc297cc71aeb08a1d257389555488101f214323a566b18b07ce3025fa4b50bcdb621a381676bd632d211877032032fd526e76029bfa81279a14b246d82ed4c9594a5deb41e99619b261f959bae77d79176d5597e72d53ecd325ea66766404c0fcf37fa7f3e5188396640a4d22c43a51f565151685d6d42410b5d2d632706fbf739fa0c3193dd8a07f9ba21368948338be636fb015657fd386e73371735798b6dfee247fbdbcb763b3d49c96792f5a09a1f2807ecc37a0f1caee73e296cee410d3b580a560d99410f2aafc6eee17c1c9a7389f0330ae23a66e894458c5a65707a00ea3547315a2059bdefb7b9f7af5a1f59fc41e86e3f4a163246818a3614abc1f4a6d736bf938a73a36643b32282f42191d51b2af5813066e8e3d9115ed4d3a8f388e028149be2ade8ea236df724c489075af16f4e379929a238a5a58390495c297a9945586cca4473e13ee063158b409973dd61c1aa541518d9a166ce4b3012e7fb98b6fc9defb1859b75c0e89206f71bdd7bbf924d2cfe2f9a1cc0c4b29da337e43b819292e2b51abd80c31c69cf91d957aa336f464a6e0717012596a3be55bc669cdcc9b039f3d5041857cc4594a24f20f8ddbc6df52457bd1103d6117a7f37ce710c3223cb55d094908f06b2ed99b82add3d6772921593d811dc5a9190bc426a5df5ab9c6afd9b5c8f16d05e0efd6984b6176373f3bbaffd6d549a478ea82356300cd26251533743c0ecdb9a44d2ef5b8b4b083080dba9c93add33b2216d21e0f76aba8e9a638f913995d33ae4688e3b73287b94e0a5982644c45330f622588b0db7cc0c963ccda60dfbc5f82ffda4a5dfecd5f9ad6eab821accaeb9c3fafcca3b50a849035def2ab87196eeed6abd83ed7924bb23c355d239b33ca25445c557655a36d09c80a356786fcf536d0313ff7f42c225cae587d09e4a3924871d86f08bf758468df350e1859493c089bf7e84e99a6a8f051fc74d7c1fbe76efa6bbd1d291e44b09a5d5a8ff73487320f38922e0ae8821f3e6bc18f1b3e7185f6edd2bda24f84fc1da08d69efe94e5e702664cadbfbe8045a703d36902af5375249e27b692c4a2234991466e3b3bda4fb8c995760eab77d36fca5e4617d84c5e57aba74bfe8377b9061e368e50e2d8afbaf32176844784561faf8aef546f7bd4003c882530dddfc63fbf0fd552f428e4c17e2a3222484f2d6fd720b5398cdc5b6cebb5ec307957ec6d57e5b0117f08575d28a27d621c803b42009ee710ed5f43e78f1ca85667f35b04cea3a23790f83be6f235c62434a1e32809cad4e5e20fabf76d7902ddaeef002cae171a945198975113919e11995b1c5e9c95194d0bb5286b52104e2f85107dc3a8f8168dd6e59e54954d2dbf09df24583a69f85f3683cd4ba933907957e9a453afabd4bb3172ebe538715a079c2196ba08bdd234bc7131056e53a0d6a88868e2a099e4ec3511e4b32aa0be056edee5b3f401d5927b4d9f0c9413f25824cd22ba65dba88209754bd58cedff07a480b4ee816e15d2ca20c8a09d8bfe5a7d3017b354a3e3dbe0a8c63f1330588bac165bc57b50b99de9e1e9011d18e28386dcf7637c549ef79ddc304ca0980e41dfb67ef57ec21ff6b0ebf1cfc83a6044710fd23c77a80323acd1431a32ee1656a7ee5b841bec12acd629fc1f7fb859363670b51ef08445164c93e1674f8ddd734305ef57d1494e0a57d80ace88939fcc5242d167ef942b5b4f161b3d76327e7b655a4f8d9229af372a6b6e156b961759603fe00be18d6608dafa07c6124b01641416842c94d32a39431c730777c7160d1c6dcab0dbaf1c30f1f80e425d0264e5ddb3ee6035a34d08cc12463fca0c3f65e4cb3b7eb327b43966602a786a2da7e4d201fdce83730b6d871ae49d68f083dcd74ef457f4ae02cbe8c306ec45314939f62e1d52198adebf9855b6e977c2f6ac0eb564259474e9766ba6fdbfbc8b03502879186b9bfa8a2da1b2a91390ed1afa98a019c23dc089e30556d7349988c00296e9ac050beb9a680d7d9f8498237a9b87d5f0da2ff86a91531777f1a12b97ac044e6de9a2184c4be452592a2a4d1e271c2273d06f5f488355a03937bbc3983a8ced721d19c94fa3e4e00e244eb21a335aec1ff70d3a79b94188144b6f8f44c21736af4a0258a93284b3c61d0f5bf63af7a508fbfcdd24bf0c3698acd0f15cf7904db67e465dd29f35c8d665ff252eec4d353d604f85d41921327b6ffa0502229443a74a493d1d7addc395f34ffda595a5a0a9813e000999641bfe997c25ebdabb83c051867a5941bc1426d3827f9f0cf267e65886c3ac9e825ca68e8670ee438d63c302eaa6b9652c8c134297be9a3724cff8e9c4bbd34376b86821ddfef0e3b4ff6123dea9bee6b7196ecf94040677b8a90aaf946136c4417e996e4a4f57398166c0ea567e361e2dafc89a14b6d3cfc5ebb0cc449473f50a5513cbf2199fc59f1a83387149d8f60f3a231f2c649ce6a169eae5dea6e08821674094a1d829ea28630ac7df5fc4d3a4a2e61804279c5679fa099b19d752d603cdf03f44d3f1c01027f183ca938c0b9607aab217d5e497f924b8335543de3bda163be667aa6a264c79cf1d82f02e6646a8d4d08c676fdf5db0447e38cc1ebcfee7ef543253243fe7f01818a1b49cac45983b528f9f09c173a2fd0e255fbf033065ed1bad8f8a01822f82829880ffab6bb479ae7fbf03ed6863debfc8013998f690d1d13b64d328b857f50dc14c07990ba6e5bb147b75776138e646c1f630358d398f2284a066daffde93c12da0b23e6eeb3eb9bc18def82e4614cc6b4b84522b0c136326382937371468d1ae358ac22228594118004bbd6bae8bc730fda29b9c1c84a8abcddb79017e08c6c1b16bec746ef542e924f6030a4b3d7b2ecc25538169704db036c39287d1e63e0c1c4ad1924bf86999273b2055fd457ded018aa86f156e26170279a7e09a04e865d6247b35e31883b12194e19795797aaf6f1045d8ae54d7229da933f49d6248f0b3808164168b1180d5bc4a5079338c2e8c2c6f8e131b91601c3e734bb35074292b7e65738a48a364f3914ac304611aadc990cd4c84b1433174ca00dc02e85f469517010038f5c7f9d6644c63488f78ebb118aec9bf72c27a156362a8903de6a8654e7cd35fab5f454de67644c6340f5c17380951049232d2b60310c76e2d3766dcc584028a1d05da3ccc768575652e1a064895146d09b8a31214e75fb2b2d7adfbf3420414c9a62c8d5be2e12764d923ab5e60a334714e85fdb8b06bfea0a11f73a3cb6da9296e298d9e97d5e3a24920765e289332211284acc2a729fb8165b1f0396215d9037f46f78cbc529dd66121ff6bdcf37ae8a33f8230471d6375fc8e723f8069956575a99e64aeb714db2574a8597a230be786bed8fe0bb82466a3766c1ebdbd19a01c1c88420df40ca7619b7d479baf07e34cbb4821de699eaa21718d1037f8a2118afe8085cad992301b8899e001972bb1e5698d09599557ecdbfe3eda05bfb98a0fc95591006fabb3b644f46613bc9d6ffcba91b5200f858ed568e158900fbca3c2394fe1f7833b1ccaafd71cb746be3fa711c01a23db713ac835a38bebe1f878623775d8af9ea746bb366e19e14a9e0a08216af7252dfe80ebe1df4c267c0121d1c77107a870eeaade77ed711140a3632c2ba23d255603bbe5d9b005fee4a72d16bd948cb1f12d6bb64ae93bec88c91aecf12006b91f071cb0d13372a52ac9c538ae3ad19f892e873d410c3e89b188e43aafe37cfaa8148979a3fa45e644a77bc941029f5785ada35bf9c0ef8f087ab263f28ef3f07184c7846635c84e8c2964c53e1f1053f94230d9206ec6a853b72d3ef36e5d602dc8a0c1fffdacbbcc6d538da6a1783d3709cb66c6d8547900760b6e9c055ceb98ec0f598860d21b10b1ffcb05bf2bc51b81eaf58fa28eae8bb909dcca6e1deecf81fee667ac98a3a722992db04ce384ff2c08982ada1b8664b8151dc99bbf1486b7735e601a455c11a7566b015898152bebd7929e3a45415183a7bbc52cab110a31fee36473b397b0ebe83c6c793b8d7ac2d3840555d669c76588605dae462b3e52813159132eb940c5f4e8e6f981d564f48acdf77b540e8f5942872c47c8a2ce2e46b2e1800b97526cb98b199242667fe01efe773ae9f539c1165fd4253de9f46d8f9c1ceab5dc8094d6cbd6a8629022cec9ff3778cd4ff1589ff259e7f70fc392d191ee2ee55233a5f3944eed501e624f5e00acf49660ffdd523dc9bc0927ae0c4fc922ce166610ed2dec9511e8b4124625e4fb3051bbe8eee3a46602d6ad791029c7e1fa8b8974eaf1d56dc3b164b32425c0cb75b1946f21bf613402d1d451ac94535d6e30c75bc8761e93de38bb3acce79c65a976d5eb3685e738408ffedcd319e72e9db9c8a934d3181016f48d3f996054494b31db63ebe2952555f4cbea499a020d384ab748a7f6fb6cc2749dcfbf0e18358b6ff3797970849e95bc129721c9f93546791d28bc0e9545815e676c6be17d33927d8ce00852c950359e70424c9c009686eb01914165915934cb3f9fa506bcd7a47ed1f95edc1bd735cd74fa48c36b0b9ffbcfb5d42a97d14f7b0c7bb6b9cd2980b223d7a7605f8e1cf0121144f3151194063eea995463751ea3ffcea6e2cb4838d0d7efa4f06000b7e137b19409e04edf399e0353a777734b2e3a4d7f12e8d4a045ba61ff2a93271b9d3da63af355d5fd0105137a73ad325c5cb214aa8ca46a8ecbd7712e1893a3a5ca013ee14c070504600399d694d41e26f14df1148cf5124a20f1ea40242adee93078ac0ce91261f6e23a3342be648dd43e530dcf83a85d228353e68766f570d1e6338feae57bbb71c07ad781999f00aa04db383b2a97cd2dbe368e684126808fdc07f8fec79b922f8a54a11407966b334e9b303c5631839679793a2706632048a6370e40e8067254aafd41c7cee93bc7ef3c1c6d670043b2471b64ff808c17749e81f359d2ef9cbd457f8755af4d021265613db56e774a9db81db9900d52c27487424468dec9506f3da2f98ea495524f44d9abf44d6ee59199d8c6ef714c50a49b991f77b12a3fc87e7888dbf96744a1d5c6f93bdc5a177b7419b85b676537b312cc31a4bcc3d4e8c477d37be46a9ae28f9cb68b049b6adac223a5df364771e3e152c12562632826d1bcbb27869374e94de01dea5e6f1a287411d31f37fc9581ff5d67f9c50c8486a6cc047010d1266db07d127dd6f9bd7fbf16aec6554660cba61124212c341b97700d679de37372b185d0024764d4231b42e95b9699bdd6512970d32a191304a773e96b63383038a25cd0a9fa520ad079c62ad9bbaed7a95b11d86ec41577c5e687c712a46391db524927fb3b1c5fe7b92f319827116b6148e00b52d5d17d495b62f73f0e68ea02461a587993bcb28280c3b0b942e41befb32b1e90f60b28401b48b79cd7b6d3aeb9c3d7ef67e0a7b3f7e6b09b3a55dd29990304f250b60092dff042afb63a6d8d159d3a092268c55c981ada40557b42634f181380fa4318dcba1eec10be6aa6b06ab0f420711276f05f310bffb97e3225611888b5a177e6b3a9b89527499bae8329d578d393a780e8d674f32eb6b18bc57dc6540b0e3ab2ee541333b29b63cfadcc863ba5ae8357347da0b84d2a2c175f0281f6d9713dd6dc29251e877d6c0eb2312bfdf61f48064dd13d1b63460775e0b6a4881904df0acc82f0fdab72aeaac92b4a097140869b640275bb65d9546c3ba6410767b6a2a467b8bcf1a804f36ed493cbf507b8b19e46a093dbd252c3265701c264c1e653fadf95d77c33e79d4259b4c4aed95c21d0af1c22cf75db9c2e9c6c09a203a436820c3d1e7e300297265b0e3c90048c974914d045610b077eec81cac4b51b8a9cf1c79f7d4f646866420f0af8ba936231e91613e1addd90a0d4c606a0b766449eee2ea86b5ef6e5428365ea3a37f921f08907ff88b707e3b675336f146aadb014b08cbca8daa13b4a351f1f9e632ec3d3554238f13ef9d0ec188357baf46ab35dd5c73f0e0858c02ef9a102be156e94754513ebd58e1d25ee4ceb5c3b870c78c04b3ec34e0ab718fa71c23b66a4c84f9bd3602a36fca9c35e70202cbf597904ec2a3e1f41209223d9a9ee27e0cb473a8eea0f666c72fa6658bc9e140b92b4d3468dbf37bfe5869308bde4d50751b4f2d2158798920aec17614862cda897fcf61c86625ae435aa99c46c516946eb933214f445d84603a53b4035c9deaead75072637a6817141bc5c771ff07bcdcc912b2886c078aacfcd54a43541d61109f4ff47aac71cfb17adc58af04d8afcdb495dea1c4182859a713b679dae871d496987d9b10497262227ff32f26b4d40078a2d4fa7b147d7faf0002458d84876dede577467940149a31009564fae215466cdaaf1f24273a519641474842f8957f4d5c1c769b2312b924a64bde8992039b02a51b54816a9d922b9c9b4cdc14e5758e780180fbe6771cc53ca8469c28ba849fdb7a53189bc0ad75ce66f682b13f4d48b5414ae2e670a1d1df39625206ea8a767dc5b4de3a955ff986cfc217b6ea8207b88dbaa2711a36c8e789a642df1cfe22c9b3b828bb05e878290af309aa075dd2ba1ab3e291137669c7b5629e6f27b1c08f05a6e9fba7c99fa57457b346c778540d1d1067d209e0a0d728cd37f0549b64c40ba778679856b6b44c80c7ee25307806aeb32255e2e06def61a5b1dbdc6eb8fa499d4c51a19641c2e7cfa04ec3e0fbfce16e99c75309f3d030c782e1a3812adf95ad41cf9f00ad129a88dc294c7de98efa4838d8f99a74e9cfae65e4b4188536ceb835ba4f3365f2d56e1d48bbb19a6c7e1ebaf062906c33492e8faa80d8164346aeb8fc1b0159517154537a3bc681ffd7c583d8ce95c08ab634d515c9ed6e28927e7108777f727d03f503f4148306633da7d6def8c1b68469b6c9eb6c933a5fc8eee3fea61a7b5ccdbe03fd4983a2fccaab757ab1848a3ae67f2b3a59ec3a3f7afb114f692f4448bfcc8e4135ea8888f35bf17dd5f5c8f030de39accae1554a983fdee1070efbc7d3701ef1f362df76164f3a73996a461d7c9552b3f6343902290adfb2acd8e774d5fa905279f768813575de045884834acf235b23dd22f174c57ee4b2e557ac91c926a3a7219957b2fd3b5ada031e3787ffea07bc68211dc44e020c890d9a667973d9121c86b5e252ec7d40df6d9d8ce57b615237e7ef818e72d349675f487491600ea9eb39a7afc78cec4aa54cc7fe09ffeb1464529044f45cdf8a0e9f92c11fa1f5beebc8bbf4c9e7c9c8e47c1433fbe8512b841287875ac0a9fadca6f11c55a01da631d51a6868d9fb3ba32b7a21861f4a79dcff895c967ce5d9dbc3c136ed4b1f27af23323d118622e7e2d9ca28edbc5f6812fc7b82f26515cd88ba863bb5ef9b767f5e316509798fef895060b432cee24f34918b553cec5e53061df463348a34c08890b34c6dea4d6632789264d0a5161ccd9713d9e49b1b9acc62471f07089c47398ace9c695c2dfbbdd1c0c512666f97123326eb05f1fa75ff125008050c63a2bfb54dd05b97dff4898500e8e641458a1119512efbcfe65393c7dc104b607559cc13d8249c3c3439a881ffb17a47de62ef9c958991443f2ce9eb8b041d85ae1756fd984b4d228f902b905b1eb60af95a6a968030650664fa8c40d6114df0f27836af2eb579aa758e6160285e2f478ad038f8afbc159f6de107e589ed2be2ffdaafaa0877196fc32b6f3197e3924e8aaac32a1e1defb8b893dfa1ef56dc8aef899b46ee3c0e25c061ac27492b535e5b0dc8f80b572f9c29b66fcea995df1e56fe34174c019c27d9f6c45150332807a8b2fd2c16b7d4e808dd99724ad4f1323128ecd235c13c63ba41c8eedfda45b6daec0f3a43148205350e20e28f1dc2afea0f8f17dbb954b5fbe7d46a9ed1c4ae2cff5bbdd55962a81c701c7a9b443e810328b7f21e944288cfe8ecddf7480ed0b8dfa22260011792368fcbc733a5c64fa81abe2c2a568ec62715d270cc46862455ade449768455687d175a21cdec61e924e7499bc02aae523c1a9477050886e2f02fdeb32964c3b95477fadb92723a019d7cde7359c2f964fec5efc8f6603097951517e08c6e47b87b8cb7e90d8a0e1ea81b888233099dced160d2b680b00e4f7580f59db69dbba69ddd3bcbe1c8a8fa458e7af88f4e4c703ae03d9309676aeaea22d507a8e13367774a0a6aafd6698fb7436bc735f6a0368305171a360e62393be4cf124c12a0f919af4efcd987e55860a8a9dee271eb56b60cbc7f1d6951313ac97d4f31fcb4cbedfbb665907fc580d6baa17c9acf08affdd8335f9493297b08c396e806ad1ffd36a98a40af198d7978ee482b4c45b9e003f56e676c10930c1287dcfdde532a023ec349d2516e755fa3346f92b9448c489fa743212be3ee60fd01d25f14e6b9fbf43eafc3c6ef462b80ece3c24fdafaeb50230fed8015b9a597dffa37bf13bc6026b34333a410b317e44a0b290198d490d857a3080eadcd7d1ae212b88e6a8be36e1b0b079d2b1018e7079643536136eba9c25c09cfd383f561f42a0a2c0ba2bf91744c4fe8960ff1fe29d584d60bcff2903f83dd6108250a93fee774d85eda196dc7e5113d2078f8beeed14d9bf92eed5260c057891e978a72399e383745184d2ccfd0ed35b2cdea19e417eeb5ca86f6ff776bcabe9c7889984b61b03ac270e34bf4c0feeb41c6d5d4fda850759100a5e3ece9a5e9cbdb3c009b72f1d5b337368f602f138883b72a6f1395d65eed5e96ac97d76fc6f1bba3642f6b06a2b6f2d4cb6d80893d934e99383ee9a3b63ec9d1567fdd33db5fd9d031fcee9606025618b10de9ce035d973a729c612afddc61086e826666afd206cdd0e5411eeea95e4f8aab3f433707cdfa11953ff6cbc790502b50a9bcb590acd873e673498c4798f9d707259a40ede742c9e99ffeda80cc0e0fca1a0dd86f164e55b13bb1a5b90c810c3f3fa399231952dff519fcd7ea0d40568ab2f220f7250509125f48466f48c9a03b45b96ccb96af832b481bdc6d90734ca0a191b414670ec2620ca4bf878a34650191dbd1929c12b420299ffa3635389af718056dac2e8571fda5d204b5bb0360dc0bd00460ea7dccd4e088a5109e16c8e8987a2d598901b839ff10a195e8a475714645dc7047be066beed5e8a5a00472e49bb817dda743bb1a871c6f24f2d4f044deac64f8ad49e5edcb1357e60b78e23e1e7a31aee6b3bd80c9db70c1d615b88e817cf19a507eaefe381320383f0f4db9c9127b5d90a1cf737e8bcffd25811be223f04beb960a475cad61f9f2a744bec768cb85539b91db374638939e0222d6ed044a195613a4a5a0c039bce779b886afd14ff08dabdcdb2bfc0ff6f0ef4cc2ed83a8c8cce84eeb17e3f0e196f68b2922386277377b027ad53e3eb118eaf0b245c083cebbbe9e4cee83ce65f5854118c16f444e93033cff09a96159a2db32a254533d8392a5650a3cd950653062c31471e44904178b6906d8c1cb5f53d96a4810b1e16b3486ebccc2dcdb9fc1bd2796311eb9d4e0a292cae4c5f5aa81f73642b331a677a9533fc83e198623ed69cd9281efef273073294cf4b89afd89c76f15141da0eeb83d6d8ed10db7a94e160479e22416123661e4fa453628c31122a4d44ce1efe9ec607dae2a3495fcc74c4cdb45f4bb6aeb9afb61daf925afb8276432ca0ca1089fb47617444c4a829d34556b8d8066d2cb067d42b27f8c797780b98391b17e8ce0f3ddafb43ae33dc31b75df5c432054610031905d34d953224d863ff390d348c8f289306157301d328fc3b640982eaa3c8330ca43414a2f38f67c16a0d3dccc7f80d5b18809d550d6373123c21296a6de680164eae7d62c1d0b95ebf4698ef8b38c22bc29472e4f6e3888f570d72a7ef6a31f7606fe88fcfdaa7e7312c5a67508fefbc55f4fc377181f44280f8664400ad9749742f3aafc4d90c530c38966aaee349f18ea00412d2def86b0c71121b33fdcfec2647ff84073406f49695dc8c96d67781709e4189393dbf74e7709b5127519d8ec6af556c861ae37959da7221bae93ebb094e1d9b1bbdfe85a3de1cd1fbd1cae0c0d9ee7393fcba445027502f983fa8134d6153de417c03a51cec0057455334a32e500186bacae985d7ec1aab26dbd34a74177b6b277fc0724a2d68ca5ff63015fafaca550a33bd7b36f1d181e90a88a7424ec816e271732bdfece1f7b584962fc258fad9c5bdbb1ade995560f915f6ab50922001a509ea3f306f2367ea57690b43c29cda4a21ef7b79dfb5803bf1db6e2fd92f3125682d5dffaeaacd4415e4460f5e6b9f2c19e6c146df6dfd2d70c1abc68a1e958e611d154843520d979a6d046a6b6b911174f4efb2898de42ff991b3b80e22838ad69e433916558e779aaf286c08e2eb9ce0b098516658e923cb7c06cc64393524191cc76cf08f052f4591964617a4299f56c92715356ea073231c0213f59d00c479e3d94c052a3f8fc04278d657a366466804677f2c69d263f678cc49b43eea16bc03eaee7dddf289e77210d6541dbb95827f4479ddb1433b2ee16fa0103fd1bbe635e342c367ded54ea4a7be5c2a374ce381aa0b48882a5254f354688fb478908b7e892b576aaad92fe4e1ccae164785bdab4237f5416d39a5e2dd49e1bf511455bc0b21b198f43c3d0f4ad8cfbe5e8d6fefd0a91aecaaabbae4b5045556c3ced53cc4a4bb0698ce7cb2752794599ab45aaf32cf28a7293566779ec7c231fa176f3c58a4bdb7b54362bc71d9a558a5db333bcb69254c8cbbcea28af6afb42bbff9b7433315497a8ad639066bae8ac1bc317c8efe25eda378bab82bfadfd43325b4dec8872e1fd84d95830a8be8f21ea12fb9f990c1009655eb63df64c5ca752a635577137b03692b22c69ddd43993bc10a2202e83a50b947e57d0b2a24e4e418d990e260a1e4fbf4c842b563cf7062eafae57ddb61cf97d3fc73ff3d59245c11df322868a3636fcb0535dee38bb82fc53a6a6845a9a4fe9fd099ca319f65c066def2c5554cd07c81c01cd4daf1c606803cb587c3bd20649c10d077cf1b0902cbc8d6b7896c1391ebff3355a4d825a3814ffe56d7ee33c3bd0b1fb6d5ea431bf9abda170ef2292afeafc0dbdb8ab278d3b97b81cd0f84081fcb5f867ef0c6b37a4e59ec5772e99f2d2ee06b8910a517fdf75d867406d3ec941bbee66b22072949f4d87110aa5d4ea97591b86db65094fa3d43843399a0c3016390bc314fcede5904cf4bea04135ae1ba8ef5a470baa48f91086ff201fdf1dccb143f73af7b9c8b2165eb1b159077cc3e57af1154cd634dd2999ddd063e83402266e7b0cb1b651bb70b3544c85249301bdd98c50965bcca57e8b4c3786ee40160698bad141e01b773545081596b15be70b051ff19e8cbb1549f2690043880da449b01875a4f97bfd5d191ef122389dca66b01f7ee9d7901bf9f61bb8ceb186ed563b22a257bce4fed884c7223b1f858c98731ef8ddee0144990105751b74eaa8552fdf0b9739a51168cedaea949a6b7d26aebb0cc130019ffe4e5bc34e69c0f3704aaa765fdf6410d75d7b0c47922f9e97179ccd73bc2f1447f8277d993a0a2e6d604e98a1860622bae2d495e03ebacbb2fd50b52be0dbe19b1f52b7deffcc72afee3e897c18f6912342b67499d3136521ca9ab34eaadc383006cc142850f261619c4f29213fca06373f667b4010df561a75304835c27e4463db7003be734ea00cf66d4752ffeba02f4c21c2967bc2046ca6b9e9f0c313274426836ea2f82a89bf4c39691765af43b20da47ae2e2559a651b0dbf518db8d0c9e0c4b5b8b9d7e746717a1064d3416e29a9400013fbf3596728c9623c59fc6d8857d4bfa4e542da3c5653e00062b9a84b2987fa0c40aada508ccf7fc3bbd8b7e8401d2d14c1d107827ee8f509b1e0867fd6f8fc61b0380fa2775513109f5e3d2b63fe4ec375f80278513fdc364268517af7fb6916953cddeaa4579b1448324b4f2e1d1027224fd1940dd03f2e349338818129deb0d2398688512785e41dca30d214d344e04ebebbc59e9b3a45cd4293de43f3138950770345a583ff3224f7fb9946beb821c04e7edce89fee682a40c198f809283837d2a3ca4f5452eeb30e090e9524dc46501ef8e61695cdb94307c0fac528f142489c4d6384298ab91b04526838454c79cf7661384d87fc3683b6b55438dd7bc33f0f9862ba9eb92c62b909d50efba16a385d864efa96f6f7a234fb43163163ecacff737c208075ca39857e0d38bf83488f9907b00d7c973752ea069976400a7722a7968b9410e62e35b983beaee95ce59767110ba1cb78b05168907fd510f838ceb66fa22da77372664d2dd0613ef1ffc3698b9bdd412be02f31b6b5a5c50e286d9da222960ed939606e318f5bffa668a736f90f962cce3015bbc14df993f2995465fb7bf4f36b4e7353c73b72cfd4684921af73921175f2fc6b96c552f275a7ad1212f3a2491a0a8089c98726f15efd0053204b8e28a51bd66cf662c94219fdd2551c12154ef6b12204122e96a25b137018483a996bfb28a3b65119228bc8eed97df72f845e10fc38154ed9d12b42892cf64871aab9d63983fd481db6d501647874001a11f990b6572fbb88f4c4acc2479432f43e8cb90fe3fb734ad4aa424c90909f017f823dab66e50b404938f306a71d05fe5268237cb782fff0a74ed483ef8a5b723da04c5db70ace489fe5733bab0d0dc22817d389b6132d00ff2f95400e2221b1c15836ab4ba6c1c2cc8384bb70d7ef4592f721fee2a2f910190f1ff20add8c92263043c789194c01b14e20ef3647c39990bffde3ad0aa3680aa28d714efe30223b2c814871e5dc75ef1e02948d1e22fa7c4e014a886549e2a7aabddcfac301287bd591ba0982d2a16d0d3917a34735745b795c9033e6a2c67e1cfb1a6692587c68b9d1eb30868dcd3baea108dcf5008f0da547c147a18ff80d3b32aa6d373755e09f654c80a72c2684d2caed208347f054afcf2ecddd8d0a134d66a197ba660b8808669370960d3637727e4324a798f1eb06946629ffc5e3a45065d8116e31e7e4b8176dce35c4a4d3e324e2173d692f33501a6b9cb15d9a1c6687141dcd06c80663a89694205a200063d71c477118f17139909fa9b50d65ab2c4c1839b850362d9ccf975d3b6af81b6755f31ebe445a5d26aea25e49c73bebfec1021d2e592f59e95447fa6fe5a66d670a95427b05c32f8db4967767bd893ec362e7e6953a0a452421321a960059505e296c0e06c069f17e59755ef899a276b51e190a8fbb992684d33d569df463440cfeda17c6539008aa6dd1b810afc349c0d0643d79ebe39ea3f40a0b12f7b54fe344765814ffd9a3cdab1e706f93918db53ef9821eddd8085caf80ac293e9f27d8e3a3778c66d96c1927f3a30182c241f69c5cb5f07cf84cd5a10d1e8ad57fdc9b3ec04def9a2caeee0ce93a6d8e5c73fd0469f37f09feb7ef07201912e5c3a3d434cdc906ebb5a9f103d83793f4a0319a007319ffac7c39030bb74a73db88bb64c387353bbe78f7eb44ee63fc500c75f271189031484e2459f502aa7d7e71830a9ec5f819fda188912c1959d14505251a2e9a99e147cb16958720b0eede03200025baaada34eb7bcd680768c2f8de33769557d45e4078dc34afea70613d2e24731f194d18099afd71206d8007e3c44a91caf91e764e82132757bd9e53de39b9f357e0f13eb3f72e3569b787f79de0863fc6d7dc24adae061d826086d16af139985ffc2a0fc185f3aed13c28f4fc65fb6dcbcc9fc41ba40a816185a89b6517b0ae46b9f38d26ec3988b66f566b8a8d2bb26fb5309270e86e61283335845814777044ec2422f4ce03d225a0241ecf0e07c1421ac8d3b17a8c3ca762e65cdc3f19a40e7a6680fc2dd6b03f05f4aaca05ea08b9bc8562284b47f23ed257607ec0436e2167d460dd3f67b045481ffeadb186965f0836d9abb7414738b553574d76ed5b156626fa34a671d0767c96c4185688ca1ad8d67071eeadcb735d27273877d4dd54c122a09e6c2b5a90fcf7f865e4ad6c6fe356ca780b40a23dc1bf36be7a1f124a29a1554385ce148a570ea882aeb9b037f0f4856a958be8468f0e0271131986c3137ff0683adcf358aab99e495a242a8542bae91147f635dcdcd4257cf923738c2549496ed87424638cc0db3d34090ef39a9aeb29d26439bf72a95bdb4b9672c3b0078df688b2a428cbd282466495040b27a2bc12190f238622ea60be64d1cf3e1a63c1ea89c67de641172d6ef42970629ef8113357fdcaf5761c87d44597fb4e6220b370abe2ae35bae640afc0b5683f27d87116455651b739758b2aa76b0a5808157b6a7356ff7579c2f4e06f8988d7aa34cc5546f25fd73e2158a75ebaa206160178165f91ad063961fc8f6aa605f90ca652a8965c349d934eb4445d9d8126e205cdd87a53f808946f975b9b22326339d5d98b0b0591aaa97f8aad401dc232ed6697c39ef0d380351ae8416e3710a0d456da03da60a3dbb36875cf099e5162e3d18cb3d8bc30224a75514983066340e26db52618752bd0b134efe155fa46c61c814f14d213972ffa81440ecc9bf6ae9ed2a9aecb52e9f962f0e8de93b1fe0c45998b86465f57e96ede66bbb018806d7362af8c4bd784b7f69da762db5bd68b54213694a303716cd62fdb6bc591ebc1ad0bb5d30d0c8ceef2899c3b8bcd1a9f80cd77bd26ad56071288836b7a07ea387b3cec9a1d766dc31bb552ab6dfcd0541a5e41f62005579225df963f54584e449d88341f82e48b6298e8ee973bfc7bc26a8c812374ea2776df2e9a76b7f288d9808ace711508c2f996e511eec9f8895bda1e5c7b23ea76f2aef810f1d48573447195ccd4e332435d31639e0fe9d6fa2a8b522c69e6d6b7ea4ebe4c410a7d0af2296831051348e9d319fc014c4a5c3e66e8fd7443ba9d2076dbdc3dc885ac85e75699c6c06d6e23b0c9d4b28d518a744418d8986380af0d67428bfd945b0daabcfbc2e9022d32bf508aac73d148a1ba29e614cceb4bcc609514a9ba1f4e6bb6619ad1b043d20a7bae6d7b305cbe3cc21bfed07fbfcb55f030f898137f365f875bd09904aed491b78c020d3b72fdcafd63dacd2e39830984a932c5f2ccf64c5b7a8cd03abbac3afb3990c67ea881edc8a93a919f55aee3a036c52afb868547a57be7054eeb8928db2084d8d84353160ba39d5ee61370d5e5e133424769ddae53cd6aa7be8ae4da898c83a5a221f55c6d33e183de31211f3cc20be28c544b60e28f088d0351c8ecd646afaf1f8fec84cfee1d98c22590265983804fabd5c2d9077f4c2d275cffac3ce5171cdd1b5e45d381f26f139b4e0ddf73fd216fa05293fdcf62a49a026fb024e8acd725bf099e595d9f16e593a571588b78f489b99afa24f4c1020a936c22093e9db051c740a374f6467ba6efeee17cbb6aff496c79d2050d423fbf3a44dd912919c558d21d3624a1fcb6ca41eaa6f743382179c0b0bfd3c4ac2a177aae386667aeefe0cfce8ba89de739b45ce0a67ff358d15740e6c431acc61281f7973e0a12817d61a5f83f98d77c71759cd0e08ba365b4d1dac257cbe4c7a8779a445b43dfbc592a723b7fd23899a0862728a092259da8c430031614ecb37211dfff739b7141728e3a41f735d539cc25ee15b42024899144e79c41a3403ed0d9214c650f5a4b8efc04ece61754e202d998084187061bfc2aa678f872624b3dd54d156ac29f79b7c087b54115ab4f562dd6221f4d7444747da06a4866c82ebf76284f17b14a774f8992aa6644f0f01b9b2e6991bef48dc1820e3beb98968eec24666778962e9205023ebb7b7df15d301d2f0b2a95c8e761f94f6c66e549f7d0a0c61855a3e55dbeb566cc198b72962f6d3d99d2b22dc35604faa344031228b077a382db823f1304f9b89ed806eda0257b555908f03b3a9b2d44fc19e5d0d0eed642e9456cfa779e0c5ab9f8b5cd571de86d606f565f4d2c8f0dec807a65979a567857571d51fc88674765bdf3ee51a2a873564ef3199512a78e76b751252587457ccb39c552f98b3d4a6272881e2632720acda166337b0e4b0d0a23ede38cec6fc532f4bdb3d6b136a24161aa91d972c2df933c45084b3077951c5841e9b9339b7268eb368e1c242d058d353a03b9a5010bc2bc017dbd2c566dc43337c97b3d6f63a9ec97b7ccf3c8f6c3cdb82e2ffb231d23ff6485f9a366419174f1a45307d49a44bd569b091b0fc60723100bd488160c223b410d75c0c9ad287b4b2f5531fb06252738eba7b29b535f905958c7a376ab60add57ac3a2c4a4a239550912a6ffd1dd30c7c82552e1d48a57a743d8cb161377a09ed38f11b7bca5bc26dea396ac6a7f0b1ec98c5ddc6e054a8b90ba8004b42e5bb5d776ba72511403472f43200c29fa38069daefd65bb531037aa34677c1dd7c7bb5a54162caf6472cd4679079a3cd0e6eccb47c322afd678ab8e90d7386d7d836be5254ad1de087b831d15ea5c19859acd7f7a58fcbc3e66537872463805a0e88e48af056cb4b479118983835b9530a503b7e1276cb0cd516f0abec296adaab84006cec09376eb97cb51eb84ea90c806f1d0334fcada4ae4b50b58db0ef28c84b558a42e8cb671ba1f9af7735be00f067807e2e49a82ee27c8ff5054575a9b68626696e029cda03047838fc8adc20dd85394cec83332a8210f0ad70a09eb34a2c61349b6361c9d4b68f0f4ddedd9f7e8ae18ac1ed5c6a64b59653fbb9bec60f7523bc1e080e800199c017d4e6dfa05eacdb49823dcfeaf2b0d2c7bc5842b810a333b7a705d3658d3036e6b27c4592819e06c8d771ca571996b2470584be56df4ac796b6db87d0557750661dab6274dd9c33afd3a9274fad87c952206024722558e2504dc62ab697ac4125ee36e193cc680f435c5a8bd537e100363120eda940220ce7f398d2ea4592da8006741fbc1ba12790c0a9cea8016e8c2d9d98d319bd9acca18107f74e1eac1a2fe00938642ec0166583932829fd3e65bfadebf1b41133ea0d38096983448aea66e261538df34b062b3c783ce43abe378b1d57849e3b82e0386eb32489cbced492171f33ed894804a01ca1ba35d0645f4b542a7bd8f26113cdcdc36b7e2da77db44a42a259c995f6bbe04e48878dc8dda8d9923314003c771b2aa17bd49d43c9d942b87b078de4d03efb5f3330736ce75fa50331a04bcb559f125b75083ef0d87b35124db442d300e3cc9e9b935a3bc2a981e4f7ef69c37a8a929af303fa19514993796d387e544271536804e7094c77f3cd4d1b8ccb3a8913f4393ac3db92c908ed309bd87e93f7114d85be6817eac8c96af56df9d87cb16c0d498a86db71aff9ca5d6d56739dc8757619ad70fd80745df39122c18dc79b589b5280fba0152195bfdcf1d19e56e5c0206277c08aa3ccb04a2b68d2d4b5aef71b11d14a8a03b6271566a7ff380b3cc1caa3b26cc9f86626b59c75120473753409f1c20a050824d13b11f0b9d4969b2a71c6f86d811326f382dd24062a0548be9d1f691413bf2a7d2e24be51fff24257b632a35ce7ac08e8551391cf4a5272e3e0cc452339e5439db39f9aaa60c400a55b63133b19be912e32d6336a6eef35203ce421015081edab8be682d6608fe8f97cf1d29eb7f629363dfe326b5f45aa0200d7915e34b4e8e404f21d636b9d76881327d90bc1a402604939afb2d12130a84bd2dac7c7e4d33dab08dd34ca2b08cd2359c9cdafe7e1ae6a11c71b8c93810a076e3255f95e51bb45d6af4f31b13741b38bb2ab07523de96ebae4fcb328dbee19cb3a53d737c50874e57babefe76307a735c192d46a14b72ccf22741d318915766141200558d6214e0a2ba28298d7d8465999997e3c98c9920b7efe9ddae0a26fd9d5f5a25b8612ea63cae89562a71c0ef0a74df556f09ac41533d40869edb703c1fa59b1da386a99d26c712ab1a4504db4f4a705bdb5b61b9598fec7f9da5a5a4ab94ac10cf93dd0685291e0bc089558ccfb7e2eba8b9b609aa1e9ae665eedcb74aa75f5441f1799f23f9677dc23f68c52ab47610ee14c9576d32c5b12a039fa09dd1de0c080b9df7e52bd58612d5ca660589df105965cd8ecc1303a906ebc9bec6d8e63038b63d679211401f14e20f6274ecbbc76b38b8b2db5202e073b10937572c9616f9626c83aa3d50d83363e4a0693bcbd1a9a76ded24f7aa86389a790613296d7995b111e59570d3ece05798a43635e9029152a9484c9da094cf7ab063dc102276bad1af295150f6cc7508d21cef020fa8e97f15f3ae7323c16c4aac92a26acb4298f45f7d1502fa66951ffb00fb1b37caa50f0b49aadcc51dedf0576557e05850c53d2dec07656b53e898f12d21372de3aa815c165bfe8bcd11c023dccbac8486137229b68c50fbd73ef2e635da790a221d5c2616c20d8b32d57cee0c431c82619300fbfc722861790dc3fe714b09fdb40c69b5e0f43e3fc025d1718118c6397cf07a862ea259c90746dedd117d0497072ed9dec72190cc3c8c46aeefbdd16baa1bd183f417838252da250681c32c4fec2eedb3d38b7b6182013cab6e2d6b743a14c68cb533c3508095de2c70124d1a4a2006877f90832926505ad654a569d9057589baa6de3ef4200fba04ee7d6f54b57a190a4a1f4a648d8f57fea24836e0578336c805ded18013fdbfa12ff8678767935d38fa9a5da460d435ec5075f2aa1cee2b1a34319323f7014e830b9283cc82f768bb6624c1bd4c7a950737d456fd59d8da85f9fa44575026f303eae9c341babddae22181017da153baabc63f4824fdbd07a02a2affa01c3132002cab438c5d6b1a90c32929ed2854b5c9933c8217ac9532f15bd3eceebcd76d3bbb1b35db1012b2de702c9a34f82542e7b33ca6684c45abe7f0beb9868b6b210f075aab7e0156ea3702c4904b373cb9a1b0a431f181ace5896e23cfcc571de4565a9e97fa78195aacc9d315adab158b843c45e52c8d5fe351b07dd4aa44103db0f0a4c21e974253ad5ad87af63ca8e4abdb2693c282b87a2e551b1ed12a2c3d9bb810d600d1c89e51815735</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>Java学习路线</title>
    <url>/2020/08/04/blog_markdown/Java%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
    <content><![CDATA[<h1 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h1><ul>
<li><a href="https://mp.weixin.qq.com/s/rAoamIey7cARMES7kfIaLw">Java后端开发学习路线</a></li>
</ul>
<p align="center">
    <a href="https://mp.weixin.qq.com/s/ePhaYezFblgt0NgbvtWqww" target="_blank">
        <img src="https://codesheep.oss-cn-hangzhou.aliyuncs.com/blog/javaroadmappic.jpg" width=""/>
    </a>
</p>

<ul>
<li><a href="https://mp.weixin.qq.com/s/tXilzUzN7cDhnc3ztw4Vlw">C语言/C++开发学习路线（偏后台）</a></li>
<li>Linux学习路线</li>
<li><a href="https://mp.weixin.qq.com/s/Y50BZPXfWhQw5xYl7WgEZw">前端开发学习路线</a></li>
</ul>
<hr>
<h1 id="项目推荐"><a href="#项目推荐" class="headerlink" title="项目推荐"></a>项目推荐</h1><ul>
<li><a href="https://mp.weixin.qq.com/s/5Ar5B9Ah2BdO8i9YjMQ7Qg">看完这篇，别人的开源项目结构应该能看懂了</a></li>
<li><a href="https://mp.weixin.qq.com/s/y59hmDbQj1QglVj90viZqw">上次谁说要Java开源项目来着？来！</a></li>
<li><a href="https://mp.weixin.qq.com/s/bRNiqhZZXaoRwPEt8GIpLg">分享几款适合初学者的C语言/C++开源项目</a></li>
<li><a href="https://mp.weixin.qq.com/s/I9lr_SEg70OO_v-GOIUgjQ">吵着要学AI的小伙伴，可以看看这些牛批的开源项目</a></li>
<li><a href="https://mp.weixin.qq.com/s/jjugnXIr3G0u7i9krbmmqg">再整理几个开源项目：练手/毕设/私活都不愁了</a></li>
<li><a href="https://mp.weixin.qq.com/s/fNgOqKlITKa4yTbULO2Atw">C/C++领域的练手开源项目，小伙伴们接好</a></li>
<li><a href="https://mp.weixin.qq.com/s/PmxVlkI9LUmnqqSk0Frqeg">5个值得学习和练手的企业级开源项目!</a></li>
<li><a href="https://mp.weixin.qq.com/s/2cXCyl9rLNhFY1dDurkEMA">互联网开发十大顶级开源项目巡礼！</a></li>
<li><a href="https://mp.weixin.qq.com/s/Fu4OMojTJK0MrZohsLOx4w">推荐几个炫酷的Python开源项目</a></li>
</ul>
<hr>
<h1 id="书籍推荐"><a href="#书籍推荐" class="headerlink" title="书籍推荐"></a>书籍推荐</h1><ul>
<li><a href="https://mp.weixin.qq.com/s/voNG467kSVfR-yjwelQhow">我的Java后端开发小书架分享</a></li>
<li><a href="https://www.bilibili.com/video/BV1kJ411W7pi">必读计算机编程好书推荐！程序员小伙搬出了他的书架！</a></li>
<li><a href="https://www.bilibili.com/video/BV1ob411m76i">自学C/C++书籍推荐（自学C/C++看书路线推荐）</a></li>
</ul>
<hr>
<h1 id="自学编程"><a href="#自学编程" class="headerlink" title="自学编程"></a>自学编程</h1><hr>
<h3 id="编程基础！"><a href="#编程基础！" class="headerlink" title="编程基础！"></a>编程基础！</h3><ul>
<li><p>基本功趣味学习</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/UyYDt3HB8IO_AoSDLndhxA">老大说：谁要再用double定义商品金额，就自己收拾东西走</a></li>
<li><a href="https://mp.weixin.qq.com/s/Dg9LcKJBrabcnvC_6wga-A">为什么我们要面向接口编程？！</a></li>
<li><a href="https://mp.weixin.qq.com/s/DgOr7cat8SP0zoY7Ke3toQ">恕我直言，我怀疑你没怎么用过枚举</a></li>
<li><a href="https://mp.weixin.qq.com/s/0EfIUB9E-0Oh_Clwuxswuw">一文详解序列化和反序列化</a></li>
<li><a href="https://mp.weixin.qq.com/s/kNMQp-vjVK6Fq07xalZkng">对不起我拖后腿了！我才刚用上Java 11</a></li>
<li><a href="https://mp.weixin.qq.com/s/ufRf8DQQRYQI0q2VxG3hQg">答应我，别再if/else走天下了可以吗</a></li>
<li><a href="https://mp.weixin.qq.com/s/iGqAZM7Ja_OzjH5AgS8geA">答应我，别再if/else走天下了可以吗「C++ 版」</a></li>
<li><a href="https://mp.weixin.qq.com/s/gdYysBB3aD_HmPyvEThFXw">听说你只会用注解，不会自己写注解？</a></li>
<li><a href="https://mp.weixin.qq.com/s/dVgDv1bNH8ivO0Ft0FtmZg">从一个面试题看程序员的几项基本功</a></li>
<li><a href="https://mp.weixin.qq.com/s/RsC7peRsFaJAEcG2eTJb0Q">只因少写一个判空，我的代码上线后炸了!</a></li>
<li><a href="https://mp.weixin.qq.com/s/yI82juBiirJ56BZfGJezLw">以后要是再写for循环，我就捶自己</a></li>
<li><a href="https://mp.weixin.qq.com/s/v-Va_GuSUGr9HVAW84kloQ">什么？你项目还在用Date表示时间？！</a></li>
<li><a href="https://mp.weixin.qq.com/s/QZPezSruj0qvBUJEM4jB0g">面试官：为什么要重写hashcode和equals方法？</a></li>
<li><a href="https://mp.weixin.qq.com/s/ttncekujB82g88GRx3a6lQ">这才是学编程要懂的基础！</a></li>
<li><a href="https://mp.weixin.qq.com/s/LVpvmBO0GY6TC4gwL_12Yw">真有小伙伴不知道浮点数如何转二进制吗？</a></li>
<li><a href="https://mp.weixin.qq.com/s/9bw2-pkuYSKEnstb4KGsqQ">List使用踩坑记录</a></li>
<li><a href="https://mp.weixin.qq.com/s/D21mcfI4cxNf4D9ukjESog">Map使用踩坑记录</a></li>
</ul>
</li>
<li><p>多线程/并发</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/ND-nUCGvXTHkEClKqN1qrQ">ThreadLocal源码剖析</a></li>
<li>线程池详解</li>
<li>各种“锁”大科普</li>
<li>JUC工具类解析</li>
</ul>
</li>
<li><p>JVM</p>
<ul>
<li>JVM内存模型剖析</li>
<li>JVM垃圾回收详解</li>
<li>类加载机制</li>
<li>性能调优和问题排查</li>
</ul>
</li>
<li><p>数据结构和算法</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/ZVwIUN-xf9FuxOFXW8H3Nw">24张图，九大数据结构安排得明明白白！</a></li>
<li><a href="https://mp.weixin.qq.com/s/za_MJY3-r9Gfiu3BJfej7Q">诸葛亮vs司马懿，排序算法大战谁能笑到最后？</a></li>
<li><a href="https://mp.weixin.qq.com/s/ekGdneZrMa23ALxt5mvKpQ">十大经典排序算法大梳理 (动图+代码)</a></li>
<li><a href="https://mp.weixin.qq.com/s/k4-RaW4ROlo6chSXsO_4AA">数据结构里各种难啃的“树”，一文搞懂它</a></li>
<li><a href="https://mp.weixin.qq.com/s/-V0jBkPoZHYC2jLfSnQ6-g">一篇文章彻底学会递归思路解题！</a></li>
<li>哈希算法详解</li>
</ul>
</li>
</ul>
<ul>
<li><p>计算机网络（TCP/IP协议栈）</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/21Tk-8gxpDoH9DNWNYCWmA">计网 IP 知识全家桶，45 张图一套带走</a></li>
<li><a href="https://mp.weixin.qq.com/s/55bbQX2-SUNe6PEI9My5fA">ping命令用得这么6，原理知道不？图解一波！</a></li>
<li><a href="https://mp.weixin.qq.com/s/07zloKKMUl-RHN6tWqZIJQ">探究：一个数据包在网络中到底是怎么游走的？</a></li>
<li><a href="https://mp.weixin.qq.com/s/lFnyBaaP3f0eNcKGW5RtCg">硬不硬你说了算！全图解被问千百遍的TCP三次握手和四次挥手面试题</a></li>
<li><a href="https://mp.weixin.qq.com/s/FJGKObVnU61ve_ioejLrtw">硬核！30 张图解 HTTP 常见的面试题</a></li>
<li><a href="https://mp.weixin.qq.com/s/BraxnIUJF4JGtIep0YiovA">如果面试再问GET和POST区别，就把这篇甩给他</a></li>
<li><a href="https://mp.weixin.qq.com/s/SZ8XcOzZCVJG_P1_O4OtWQ">计网 TCP/UDP 部分高频面试题大集合</a></li>
</ul>
</li>
<li><p>操作系统</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/VsQ7IpP-jnXSjJhOAzl-ew">硬核科普：程序员必知的 89 个操作系统核心概念</a></li>
</ul>
</li>
<li><p>数据库/SQL</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/o150rmPOgzUeafVTh-ESmQ">left join、right join和join，傻傻分不清？</a></li>
<li><a href="https://mp.weixin.qq.com/s/WMuxdG3ymNMWWDk1XhLwZQ">数据库索引到底是什么</a></li>
<li><a href="https://mp.weixin.qq.com/s/4K3borSZXt-yc5t5UJnJpQ">数据库索引的原理和使用准则</a></li>
<li>数据库锁机制</li>
<li>数据库事务特性与隔离级别详解</li>
<li>SQL优化详解</li>
<li>基于代理的数据库分库分表框架 Mycat实践</li>
</ul>
</li>
<li><p>其他</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/o1P4z3u2Xphu_IyTUFT-2g">UML大科普：一文梳理清 14种 UML图</a></li>
</ul>
</li>
</ul>
<hr>
<h3 id="工具和软件"><a href="#工具和软件" class="headerlink" title="工具和软件"></a>工具和软件</h3><p><a href="https://mp.weixin.qq.com/s/YNOZSQ5smo1uGE5ZttUZ_w">【】熬10天夜，肝出了这个PDF版「软件安装手册」</a></p>
<p><a href="https://mp.weixin.qq.com/s/JUJ6qu_ec3s1JmTxQt_V3g">【】再肝两夜，写了个「服务器项目部署」实战PDF手册</a></p>
<ul>
<li><p>Linux系统</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/x8rwsIOzYEPXmEVXmWJ4Tg">常用 Linux 发行版操作系统大盘点</a></li>
<li><a href="https://mp.weixin.qq.com/s/WeZLtfrMdnISpX3v5WpJfA">人手一套Linux环境搭建之：macOS版本教程</a></li>
<li><a href="https://mp.weixin.qq.com/s/onVwwEQ1DAwbvK7qS2YNxg">人手一套Linux环境之：Windows版本教程</a></li>
<li><a href="https://mp.weixin.qq.com/s/3NI4FWuOfYMJBiKqqnpqMA">面试常问的20个Linux命令</a></li>
<li><a href="https://mp.weixin.qq.com/s/YpWp-b3vcAtb_jBwCM7wtg">废柴电脑拯救计划：搭个云服务器它不香嘛</a></li>
</ul>
</li>
<li><p>Git/SVN</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/SYR4zvjhAH1mX9fxdp8cbA">一招搞定GitHub下载加速！</a></li>
<li><a href="https://mp.weixin.qq.com/s/bUYz9JwqAYH_Fn6nHPSmTg">为什么 Git把 SVN拍在了沙滩上！</a></li>
<li><a href="https://mp.weixin.qq.com/s/VvpjFUXd6jcatACHyFPHfg">Git的由来、数据模型以及基础命令</a></li>
<li><a href="https://mp.weixin.qq.com/s/swnwBiuyVmhs5iPqv3H6BQ">Git操作与命令看这篇足矣！</a></li>
</ul>
</li>
<li><p>开发软件</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/Ua4TYlcNntLr-x9WQirHyg">船新 IDEA 2020.1 真香体验！</a></li>
<li><a href="https://mp.weixin.qq.com/s/xMwGAL_7sGkmnFvWZroVPw">没用过这些IDEA插件？怪不得写代码头疼</a></li>
<li><a href="https://mp.weixin.qq.com/s/RK_ygHgMjayL5-qTnlHbeg">试水JetBrains官方新编程字体，真香！</a></li>
</ul>
</li>
<li><p>持续集成</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/Y2gxBmBK2HPvr1uKUUxRYA">Jenkins长大了，Pipeline该用起来了！</a></li>
<li><a href="https://mp.weixin.qq.com/s/PgoXJcJX_sm5132VGQoZ1w">如何让自己少写点bug？</a></li>
</ul>
</li>
<li><p>文档管理</p>
<ul>
<li>Dash</li>
<li>Zeal</li>
</ul>
</li>
<li><p>其他软件和工具</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/ONx6wjGjQSvOOIgnEBTNJQ">我的常用软件大公开！</a></li>
<li><a href="https://mp.weixin.qq.com/s/L9lbKUJHTThCoOC8d6FGpg">这么多编程学习网站，总有一个适合你吧</a></li>
<li><a href="https://mp.weixin.qq.com/s/Ahs6fnIfFVVPOn3NZpIsNA">前后端都分离了，该搞个好用的API管理系统了！</a></li>
<li><a href="https://mp.weixin.qq.com/s/J1XjIwtEKjaltqWH-0qmgw">服务器软件大盘点！</a></li>
<li><a href="https://mp.weixin.qq.com/s/HZRz_A8bLcOTuzcezYEFZg">几款提升效率和B格的软件神器</a></li>
<li><a href="https://mp.weixin.qq.com/s/oMAJaKDfr_bmgCVD0CX1oA">我的常用在线工具网站</a></li>
</ul>
</li>
</ul>
<hr>
<h3 id="应用框架"><a href="#应用框架" class="headerlink" title="应用框架"></a>应用框架</h3><ul>
<li><p>Spring系列框架</p>
<ul>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483867&idx=1&sn=319afaf4a53a659aa2e513732e0deee2&chksm=fdded71fcaa95e09ed14f1608cc6809d321897b2c7bcafb72873eaa672fcc9fe233038ebc21c&scene=21#wechat_redirect">Spring Boot 应用程序启动过程探秘</a></li>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483829&idx=1&sn=e0fd1b9154e687f367e850ca0251c073&chksm=fdded771caa95e67180b6ac76e03f506b6325c3a81cf1ddbe4d8cacbf1a8fb0cb6ebc276d50a&scene=21#wechat_redirect">SpringBoot 中 @SpringBootApplication注解背后的三体结构探秘</a></li>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483822&idx=1&sn=0302e3d40ca827a37d135707ea944769&chksm=fdded76acaa95e7ccb18bdc857e21dbac962c32ebe661df15b7019caba50619d14e3cebdbd53&scene=21#wechat_redirect">Spring Boot日志框架实践</a></li>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483994&idx=1&sn=0df1d378f66122803d894b9d10b8a264&chksm=fdded49ecaa95d88fad4a1a92ac6338e53f6fc42f0324537b8e24973a7dc0e5db5b361e24dd4&scene=21#wechat_redirect">利用神器BTrace 追踪线上 Spring Boot应用运行时信息</a></li>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483908&idx=1&sn=bb43028457c590eeac1e43fcfc6cf2ba&chksm=fdded4c0caa95dd67a29c79526dd0947fe7134f0a2cdfb72bb5b057f9976464f8b1534a846e9&scene=21#wechat_redirect">Spring Boot工程集成全局唯一ID生成器 UidGenerator</a></li>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483816&idx=1&sn=c7a3581bfa9f8853961446db28e3904b&chksm=fdded76ccaa95e7a5a884e1d6079556f2f89b9b6fdce31bb962e8c4e21579bef8fc4f4ef146e&scene=21#wechat_redirect">Spring Boot Admin 2.0开箱体验</a></li>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247484161&idx=1&sn=6378dbce60394dc71877dd890b52309d&chksm=fdded5c5caa95cd39f81a39863dd56cb4f4787bd69b9795b050552de70b255d4187808ed5e16&scene=21#wechat_redirect">基于Spring Security Oauth2的SSO单点登录+JWT权限控制实践</a><a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247484330&idx=1&sn=0dc2690c5398f345e4d9ac61ee4f62dd&chksm=fdded56ecaa95c78d39499728f9a5227e4499eb60bdbc90599cd1d2693aa808bd5001d9403fd&scene=21#wechat_redirect"></a></li>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247484330&idx=1&sn=0dc2690c5398f345e4d9ac61ee4f62dd&chksm=fdded56ecaa95c78d39499728f9a5227e4499eb60bdbc90599cd1d2693aa808bd5001d9403fd&scene=21#wechat_redirect">封装一个流水号ID生成器：id-spring-boot-starter</a></li>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247484014&idx=1&sn=b04b0530921877e733b1fd606714096d&chksm=fdded4aacaa95dbc36245635484d1fb53f926c7c85436745126818d308c6eae8eae4a2a71a61&scene=21#wechat_redirect">自制一个 elasticsearch-spring-boot-starter</a></li>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247484035&idx=1&sn=e92e92c550279e6c0484c39daa2a4361&chksm=fdded447caa95d514dd3dc299b8168945422a466829981a0841ab826d7de26f4474d810ecaf0&scene=21#wechat_redirect">基于Spring Security和 JWT的权限系统设计</a></li>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483949&idx=1&sn=25ce8750d7ce3de823c28c36cd0a8a19&chksm=fdded4e9caa95dff078f62b6d365fff87d0b41aefb1de6f18c241d4757cc3c5e31fc515d4dc3&scene=21#wechat_redirect">Spring Boot 工程集成全局唯一ID生成器 Vesta</a></li>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247484119&idx=1&sn=96f980fb364c3a1cbdca802ca6477eb3&chksm=fdded413caa95d0534bfa137fac7820075ccb9699fc5dca6400ab06f3d4cc3894f7c3b9aa2ea&scene=21#wechat_redirect">Mybatis-Plus 真好用（乡村爱情加持）</a></li>
</ul>
<ul>
<li><a href="https://mp.weixin.qq.com/s/WQ-2fPOxk0GvSHiRR5-kQw">啥？听说你还在手写复杂的参数校验？</a> </li>
</ul>
<ul>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483999&idx=1&sn=388b301f8bee2376ec8d791d7eb565bf&chksm=fdded49bcaa95d8daa7026876e189f7e8e740b8d50f1d64cbddd054430a55005947cd516144a&scene=21#wechat_redirect">如何自制一个Spring Boot Starter并推送到远端公服</a></li>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483893&idx=1&sn=dbfc63f98c1f22c58db40b0de3b126cf&chksm=fdded731caa95e27f0f12f1a8f7be55bf74886ac59170052cc6c2035ddd82373126c50b95f7d&scene=21#wechat_redirect">Spring Boot应用缓存实践之：Ehcache加持</a></li>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483917&idx=1&sn=10501a9d725b9ea7be4c873a14871214&chksm=fdded4c9caa95ddf2edbfadbc448a32396a9ba97bea6f67764eb0aade88d32786e77fcb5a1b8&scene=21#wechat_redirect">自然语言处理工具包 HanLP在 Spring Boot中的应用</a><a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483940&idx=1&sn=da510a926fe8a772a06bc9c4ca527c2c&chksm=fdded4e0caa95df6131b89caa4de55db4ccc54f839883ee71926790e2f06d853648e30f2ac32&scene=21#wechat_redirect"></a></li>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483940&idx=1&sn=da510a926fe8a772a06bc9c4ca527c2c&chksm=fdded4e0caa95df6131b89caa4de55db4ccc54f839883ee71926790e2f06d853648e30f2ac32&scene=21#wechat_redirect">基于Spring Boot实现图片上传/加水印一把梭操作</a></li>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483958&idx=1&sn=4d6c9e99827a0bd2357a7724c00045a1&chksm=fdded4f2caa95de45e330427a8392de52fb473b0d9ec7cafda699ffc6f1a80b3f632250d1405&scene=21#wechat_redirect">EVCache缓存在 Spring Boot中的实战</a></li>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483990&idx=1&sn=67991fd14de685dad94e930f29f7b721&chksm=fdded492caa95d84439bc32303709d0b0c871f3a87ea948dfe81c8e3a60d90718e3d1411d036&scene=21#wechat_redirect">Guava Cache本地缓存在 Spring Boot应用中的实践</a><a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247484010&idx=1&sn=f2d722b6681d14b11d6aa399f1613e52&chksm=fdded4aecaa95db83868737f30e950205510492729a189f378c7326146e057b2e82267ac7dd9&scene=21#wechat_redirect"></a></li>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247484010&idx=1&sn=f2d722b6681d14b11d6aa399f1613e52&chksm=fdded4aecaa95db83868737f30e950205510492729a189f378c7326146e057b2e82267ac7dd9&scene=21#wechat_redirect">Spring Boot项目利用MyBatis Generator进行数据层代码自动生成</a></li>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247484900&idx=2&sn=45df41412575afb244f75de08b6bbe7f&chksm=fdded320caa95a36e85c510a1a72951b97a579511db7bd58aba2270020434b5579b8c3ce578f&scene=21#wechat_redirect">初探Kotlin+SpringBoot联合编程</a></li>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247485020&idx=1&sn=3c3405807f96a597398f513c48bb094e&chksm=fdded098caa9598e6159bd7315180e149e6a789a3ee75d42b4acaaae96669504e08378eeddae&scene=21#wechat_redirect">Spring Boot优雅编码之：Lombok加持</a></li>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483771&idx=1&sn=7c5f103a816c16e453e04141d7433bf9&chksm=fdded7bfcaa95ea9a5dbe81114d32c1908bf8da0b3366bfbfcbe2473445cdba73c5e2060d5f3&scene=21#wechat_redirect">Spring Boot应用监控实战</a></li>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483792&idx=1&sn=fde72633b86c7f951cd2a25f0c270121&chksm=fdded754caa95e420516178ff70b67b42271c4c68bc4644b4671925bf3c0b8383242432318a5&scene=21#wechat_redirect">Spring Boot应用部署于外置Tomcat容器</a></li>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483804&idx=1&sn=ac5860655be99dea94aa12cc393669f6&chksm=fdded758caa95e4efc39d9d4bcbafdc4c491b7894b951bedd37f884bb846f757757e0ff4cbd0&scene=21#wechat_redirect">Spring Boot热部署加持</a></li>
</ul>
<ul>
<li><a href="https://mp.weixin.qq.com/s/CTDEFxTKdk0qxK9VNSEIqw">数据库密码配置项都不加密？心也太大了！</a></li>
<li><a href="https://mp.weixin.qq.com/s/AdtUX9davFH-C60gBypnoA">谁要是再敢用Map传参，我过去就是一JIO</a></li>
</ul>
</li>
<li><p>前后端分离</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/Y0z-3r_Mdm-etCwa0GmQmQ">这次要讲不清前后端分离，我都怎么地！</a></li>
<li><a href="https://mp.weixin.qq.com/s/zAOYAcR-6DEJU_s0qXe91g">前后端分离的接口规范，我们是这样做的！</a></li>
<li><a href="https://mp.weixin.qq.com/s/niYHlrCDIkA1NqPVI_VJ8w">前后端分离式开发：高效协作10板斧</a></li>
<li><a href="https://mp.weixin.qq.com/s/Ahs6fnIfFVVPOn3NZpIsNA">前后端都分离了，该搞个好用的API管理系统了！</a></li>
</ul>
</li>
<li><p>微服务</p>
<ul>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483777&idx=1&sn=f15f86fd0cde1855fec1f6ad2098b331&chksm=fdded745caa95e53bbcc8ccaf495dc1a4abb64412cc6ea60989c8cafd138d475fae073b87011&scene=21#wechat_redirect">RPC框架实践之：Apache Thrift</a></li>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483780&idx=1&sn=e04264df80209244f8e263ef0931d134&chksm=fdded740caa95e56190918108985795439a277a88e054c119b3cb63a92a8e0899943d9f3e02b&scene=21#wechat_redirect">RPC框架实践之：Google gRPC</a></li>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483764&idx=1&sn=964629a4e1d42d84047986529376eb28&chksm=fdded7b0caa95ea6a038c623f8813c239e3c6cf87a6cd3818277369f6c287a6833d7826b9bdd&scene=21#wechat_redirect">微服务调用链追踪中心搭建</a></li>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483774&idx=1&sn=18b144913d593af54f5e60a5a1353897&chksm=fdded7bacaa95eac39e1d29152a32a57e876bb227c37465c39672418d0cb392da6f9ed48cf7c&scene=21#wechat_redirect">利用Zipkin追踪Mysql数据库调用链</a></li>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483887&idx=1&sn=6d4b191dc992ea27bf8602eefd323383&chksm=fdded72bcaa95e3ddbe74c3c1cebd524d17dd6e58c01e387ce04d3994bac694b40c505732441&scene=21#wechat_redirect">Spring Cloud Feign的两种使用姿势</a></li>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483902&idx=1&sn=9b3a26473bda9ac4a109f844e3644aea&chksm=fdded73acaa95e2c25b68f638eb174108b1d53c2944f28ba82588142065af477ce4262ac09db&scene=21#wechat_redirect">Spring Cloud Eureka Server高可用之：在线扩容</a></li>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483954&idx=1&sn=feb4559a3b3f44915fadd18090e491a0&chksm=fdded4f6caa95de08eb0b4e0006abc1a6c1be1f50d56567f223717a0de667a9dd10f3d7655eb&scene=21#wechat_redirect">Eureka Server 开启Spring Security Basic认证</a><a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483973&idx=1&sn=e022ca0c0962c07d4de1ca9770713cb9&chksm=fdded481caa95d97c4cb055f7bb692199a5bee8ccc1dfd9f787990f8cbc09a25a5ec9a1b2964&scene=21#wechat_redirect"></a></li>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483973&idx=1&sn=e022ca0c0962c07d4de1ca9770713cb9&chksm=fdded481caa95d97c4cb055f7bb692199a5bee8ccc1dfd9f787990f8cbc09a25a5ec9a1b2964&scene=21#wechat_redirect">Eureka Server启用 https服务指北</a></li>
</ul>
</li>
<li><p>Docker容器/集群</p>
<ul>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247484928&idx=2&sn=4db40348f22f82b1106122cafbd77c33&chksm=fdded0c4caa959d25f914c79849cdef56045ce53ce18256c26fad0b9d967b575e4e9902da211&scene=21#wechat_redirect">利用ELK搭建Docker容器化应用日志中心</a></li>
<li>  <a href="https://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483763&idx=1&sn=6ceb9e73540b5016dadfb212636b3855&scene=21#wechat_redirect">Docker容器可视化监控中心搭建</a></li>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483798&idx=1&sn=fd8f78d60d1dc6e4da3359dbf6a14753&chksm=fdded752caa95e44e1cf62f5dc373a49d93426c9800a5343b1959a12a5b1fdb4958b2ee746c1&scene=21#wechat_redirect">Docker容器跨主机通信之：直接路由方式</a></li>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483810&idx=1&sn=51a4cdb03e54348e7736ea47fae04a96&chksm=fdded766caa95e70e14dba33a51224c319219852e1618bbefb380f1b9406b1d19f8563a66bf8&scene=21#wechat_redirect">利用TICK搭建Docker容器可视化监控中心</a></li>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483813&idx=1&sn=b0b87a7ec8816f53fd19142424682de0&chksm=fdded761caa95e775957e59ed0eccd913162d776f917f44711e4833d541c9c24d1db616f1334&scene=21#wechat_redirect">编写高效Dockerfile的几条准则</a></li>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483982&idx=1&sn=3af0acac7cc213ff34a5710b21efef15&chksm=fdded48acaa95d9c6b3fd8b3d030890fa45c7be9bcdf44595dbfc2d3421c815deceadd1764f8&scene=21#wechat_redirect">利用 Kubeadm部署 Kubernetes 1.13.1 集群实践录</a></li>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483801&idx=1&sn=6e482b69f46ee620c17309d7d88e4cd9&chksm=fdded75dcaa95e4b2bd4fc7a72bff0008f55c4f8d69003c6924b6b573a76a41c90b311596c51&scene=21#wechat_redirect">Docker Swarm的前世今生</a></li>
<li>  <a href="">Docker Swarm集群初探</a></li>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483699&idx=1&sn=57b84f4ec72c8a578934cdb4225e6fe7&chksm=fdded7f7caa95ee198652c295b48b74565fd244afc4dccc0551b036c8216caab0397a1342d99&scene=21#wechat_redirect">利用K8S技术栈打造个人私有云（连载之：初章）</a></li>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483755&idx=1&sn=92a547c579aeacf1db9a8f0e56601b52&chksm=fdded7afcaa95eb9d6aa6cf323bff1df46692fc6a6672e0a483105f091ddf9670fb06d034e2a&scene=21#wechat_redirect">利用K8S技术栈打造个人私有云（连载之：K8S集群搭建）</a></li>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483758&idx=1&sn=629b6219a06374b2050703b9549037fa&chksm=fdded7aacaa95ebc9a3e88e839515b13109752c26c586032ae60219d2c3b24e13385e1bcd37c&scene=21#wechat_redirect">利用K8S技术栈打造个人私有云（连载之：K8S环境理解和练手）</a></li>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483759&idx=1&sn=8403d42fe1769a252f9ee2997fc2f561&chksm=fdded7abcaa95ebd8cdae86f4d692f1f6e92daab74dbbd8c56c6db8fe6aa2a3616ccce1eebb1&scene=21#wechat_redirect">利用K8S技术栈打造个人私有云（连载之：基础镜像制作与实验）</a></li>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483760&idx=1&sn=d44f2c744ccdc965fb6c7e4d9efe9f92&chksm=fdded7b4caa95ea278d7363b4b4788d84914b915422a9cc98e7936c3bce0c7ce1197abfac13f&scene=21#wechat_redirect">利用K8S技术栈打造个人私有云（连载之：K8S资源控制）</a></li>
</ul>
</li>
<li><p>缓存/中间件/运维</p>
<ul>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483838&idx=1&sn=d8dd3eff36d1323811362a01c272c667&chksm=fdded77acaa95e6c8119ed796dd9f2e0f085b7a00f2f38872df8ca45f8bc0d1becfa487b93b8&scene=21#wechat_redirect">Redis字符串类型内部编码剖析</a></li>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483862&idx=1&sn=63effdf595d75bceef4bb9a1cb766d5c&chksm=fdded712caa95e04c36d8555f249fecd1a860f3ac50823c1054ee2b4cacb9f9f06740c48651b&scene=21#wechat_redirect">Redis 哈希结构内存模型剖析</a></li>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483819&idx=1&sn=e7a5dc93a94ea6e9ce297ca7a1a187dc&chksm=fdded76fcaa95e79a907517c83f6f1d9475a6c87e8ab1a2995e05e75ca823009044eb1d253f4&scene=21#wechat_redirect">你可能没有细究过的TCP/IP</a></li>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483783&idx=1&sn=1e552ee01b50cde1df32c07db8e7b4ea&chksm=fdded743caa95e55a62c5b216795be61785265daf6a23d803e4566ba50253c240544b87971e3&scene=21#wechat_redirect">Nginx服务器开箱体验</a></li>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483807&idx=1&sn=e3a164701c2f6e0f3cf91bd25d595479&chksm=fdded75bcaa95e4d857e5f4e040f37b7c3d8f3b301856493419498b6e54d8a43addfc25e7505&scene=21#wechat_redirect">从一份配置清单详解Nginx服务器配置</a></li>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483977&idx=1&sn=c739684c8a97ef3ec222e4fc76b2a2c1&chksm=fdded48dcaa95d9b1e47a8851262a81472ffe80e3f91d1d327e1dd71e11349defeb34a8726b8&scene=21#wechat_redirect">基于代理的数据库分库分表框架 Mycat实践</a></li>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247484886&idx=2&sn=46d651172e2426760c7fe1675f1ed73a&chksm=fdded312caa95a04430b2caaf6b73e09ca963109d91224c4d7fdb544c6ae72bf90dad3b72ab7&scene=21#wechat_redirect">Jenkins长大了，Pipeline该用起来了！</a></li>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483877&idx=1&sn=113867c83c0cecf5781a9e1a7f91bdd1&chksm=fdded721caa95e37f757660e7f14775ac55e4a72f9c24b119af7ef83ca7587ceb53f22298c99&scene=21#wechat_redirect">一文详解Linux系统常用监控工具</a></li>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483913&idx=1&sn=254e99832da662cd5dc7af57bfb0081b&chksm=fdded4cdcaa95ddbf867ce83b2a4c48aa497d6b61b087ba9111b040dfcfaab1f8c9aa34f2d53&scene=21#wechat_redirect">一文上手 Elasticsearch常用可视化管理工具</a></li>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483825&idx=1&sn=51bfd85095f7ba287fea388294169f0e&chksm=fdded775caa95e63e34796dcc26326d3c88fe1def3a4df62d5bf7711de9b0aaba2a773233567&scene=21#wechat_redirect">从一份定义文件详解ELK中Logstash插件结构</a></li>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483844&idx=1&sn=77e4651389efebcad361467e4dc995e4&chksm=fdded700caa95e163ed9e86e96d8bb5e467e8e6c36cdb905d6eb291c6e49ebd084ec51ce36cf&scene=21#wechat_redirect">Elasticsearch 索引的映射配置详解</a></li>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483921&idx=1&sn=3b29a77f6dd9faa8ed4410dec7705289&chksm=fdded4d5caa95dc3a4cd5ab040a1de5ef21c8e77dd15c9554d1e88ffa19a96d286c3f526627e&scene=21#wechat_redirect">CentOS7 上搭建多节点 Elasticsearch集群</a></li>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247483945&idx=1&sn=00633aed7adecf6fc71289758226caed&chksm=fdded4edcaa95dfbe771cf97b6056c725e5c7a2d835b41589f52b97f261d63f807ff06e26091&scene=21#wechat_redirect">轻量级 memcached缓存代理 twemproxy实践</a></li>
<li>  <a href="http://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&mid=2247484489&idx=1&sn=8d59a12d27de5c50776d1a9967890a7e&chksm=fdded28dcaa95b9b1798009f7b9df7f0381573ad52d7903361687796ca4a7b071024e0085e1e&scene=21#wechat_redirect">前后端都分离了，该搞个好用的API管理系统了！</a></li>
</ul>
</li>
</ul>
<hr>
<h2 id="看源码"><a href="#看源码" class="headerlink" title="看源码"></a>看源码</h2><ul>
<li><a href="https://mp.weixin.qq.com/s/K0ehqbxrzSz07nqnqRvn5A">Java(JDK)源码阅读环境搭建</a></li>
<li>Spring Boot源码阅读调试环境搭建</li>
<li>Redis源码阅读调试环境搭建</li>
</ul>
<hr>
<h1 id="面试相关"><a href="#面试相关" class="headerlink" title="面试相关"></a>面试相关</h1><hr>
<h3 id="面试题分享"><a href="#面试题分享" class="headerlink" title="面试题分享"></a>面试题分享</h3><ul>
<li><a href="https://mp.weixin.qq.com/s/f-qIQGbzwHcW5Ur51rCqgg">Java基础知识面试题大集合</a></li>
<li><a href="https://mp.weixin.qq.com/s/T2DqgJ9-0QiRZQYUeR3c8w">Java虚拟机（JVM）面试题大集合</a></li>
<li><a href="https://mp.weixin.qq.com/s/pIVf97W4DuAPNxq6zgRvsQ">Java并发和多线程基础面试题大集合</a></li>
<li><a href="https://mp.weixin.qq.com/s/SZ8XcOzZCVJG_P1_O4OtWQ">计网 TCP/UDP 部分高频面试题大集合</a></li>
<li><a href="https://mp.weixin.qq.com/s/3NI4FWuOfYMJBiKqqnpqMA">面试常问的20个Linux命令</a></li>
<li><a href="https://mp.weixin.qq.com/s/q4CajkpSUC8TCgv55VK5aQ">Spring 经典面试题大集合</a></li>
<li><a href="https://mp.weixin.qq.com/s/cLh9xCDkVG0KV-uaX8PkNw">Spring Boot基础面试题大集合</a></li>
<li><a href="https://mp.weixin.qq.com/s/g0br3PfTmm8C_nkKbzE_ig">Spring Cloud基础面试题大集合</a></li>
<li><a href="https://mp.weixin.qq.com/s/7mx58Idw1pL0MjPIFBUB1Q">C语言/C++基础面试知识大集合</a></li>
</ul>
<h3 id="面经分享"><a href="#面经分享" class="headerlink" title="面经分享"></a>面经分享</h3><ul>
<li><a href="https://mp.weixin.qq.com/s/joFBDntI9PmyVRiKPHwpRg">小伙伴现身说法：Linux后台开发该如何准备</a></li>
<li><a href="https://mp.weixin.qq.com/s/V0nRwXQlkNBnBneERZQURQ">二本无实习上岸滴滴京东58复盘(上)</a></li>
<li><a href="https://mp.weixin.qq.com/s/BnbBQGL-S2sGdRtNh7DN1A">二本无实习上岸滴滴京东58·复盘(中)</a></li>
<li><a href="https://mp.weixin.qq.com/s/3YfKHo2lW-NC1tEA_u-mlQ">小伙伴面经分享(一)：深信服(含答案)</a></li>
<li><a href="https://mp.weixin.qq.com/s/sc-7rc6obYZNFcc1mjNPAg">小伙伴面经分享(二)：京东(含答案)</a></li>
<li><a href="https://mp.weixin.qq.com/s/jAPYcMULqQl6AE_Vv7BZhQ">一位程序媛的秋招软件开发岗面试经历</a></li>
<li><a href="https://mp.weixin.qq.com/s/0RoFVAezxW8cl3bjlAHbQg">写简历→面试→谈薪：一绿向北</a></li>
</ul>
<hr>
<h3 id="简历模板"><a href="#简历模板" class="headerlink" title="简历模板"></a>简历模板</h3><ul>
<li><a href="https://mp.weixin.qq.com/s/-qlU2-a-vvXWOHXzKHRm6A">简历模板分享</a></li>
</ul>
<h3 id="城市-公司选择"><a href="#城市-公司选择" class="headerlink" title="城市/公司选择"></a>城市/公司选择</h3><ul>
<li><a href="https://mp.weixin.qq.com/s/VFocc914mGTrDzodI-MF1A">一二线城市知名IT互联网公司名单</a></li>
</ul>
<hr>
<h1 id="资源推荐"><a href="#资源推荐" class="headerlink" title="资源推荐"></a>资源推荐</h1><ul>
<li><a href="https://mp.weixin.qq.com/s/voNG467kSVfR-yjwelQhow">我的Java后端开发小书架分享</a></li>
<li><a href="https://mp.weixin.qq.com/s/L9lbKUJHTThCoOC8d6FGpg">这么多编程学习网站，总有一个适合你吧</a></li>
<li><a href="https://mp.weixin.qq.com/s/yncEfIOxWeNj7asCLPwrUw">阿里巴巴Java开发手册分享</a></li>
<li><a href="https://mp.weixin.qq.com/s/-qlU2-a-vvXWOHXzKHRm6A">简历模板分享</a></li>
</ul>
<hr>
<h1 id="其他技术文章"><a href="#其他技术文章" class="headerlink" title="其他技术文章"></a>其他技术文章</h1><ul>
<li><a href="https://mp.weixin.qq.com/s/RjVLsAhiMIYzsMhXJiReNg">扫码付款背后的原理居然是这样</a></li>
</ul>
<hr>
<h1 id="闲聊"><a href="#闲聊" class="headerlink" title="闲聊"></a>闲聊</h1><ul>
<li><p><a href="https://mp.weixin.qq.com/s/gbIGNXIkOpw8tQ5aIoJMtw">如何优雅地向老师表达：我这周任务没啥进展？</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/ltcfVu__ajU_i9wq77OnJg">C语言为什么不会过时</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/OkxMe3Eaywx-KF9tBmjf-Q">好不容易读个研，遇到放羊的导师可咋整？</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/1dJO8VJ6GaZykv33IUslkw">程序员小猪队友行为大赏</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/MvZFLDHItPR7InzrtYRL5w">研究生/专升本都扩招，我们没有理由放弃！</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/gJBlu5gXL5vqYWG6ggisRw">实不相瞒，在家远程办公15天，我有点自闭</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/fW-xZ2vJTaZa6XgF_LlMDA">2020开年，C语言重回巅峰王座！</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/xYG355L4YXRkKnOvv23umw">嗯，用了一下Kotlin编程语言，真香！</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/vI7EGqo7YbljRdZn2nUSMQ">程序员竟也会玩浪漫？【非程序员勿进】</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/wd9QkLsrygO8ADW6heJg8w">真实IT领域2/8法则，扎心了！</a></p>
</li>
</ul>
<h2 id="本文来自CoodSheep-非原创"><a href="#本文来自CoodSheep-非原创" class="headerlink" title="本文来自CoodSheep,非原创"></a>本文来自CoodSheep,非原创</h2>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Object类、常用API</title>
    <url>/2020/08/06/Java%20%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/(%E6%97%A0%E5%9B%BE)Object%E7%B1%BB%E3%80%81%E5%B8%B8%E7%94%A8API/day01%E3%80%90Object%E7%B1%BB%E3%80%81%E5%B8%B8%E7%94%A8API%E3%80%91-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="day01【Object类、常用API】"><a href="#day01【Object类、常用API】" class="headerlink" title="day01【Object类、常用API】"></a>day01【Object类、常用API】</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li>Object类</li>
<li>Date类</li>
<li>DateFormat类</li>
<li>Calendar类</li>
<li>System类</li>
<li>StringBuilder类</li>
<li>包装类</li>
</ul>
<h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><p>-[ ] 能够说出Object类的特点<br>-[ ] 能够重写Object类的toString方法<br>-[ ] 能够重写Object类的equals方法<br>-[ ] 能够使用日期类输出当前日期<br>-[ ] 能够使用将日期格式化为字符串的方法<br>-[ ] 能够使用将字符串转换成日期的方法<br>-[ ] 能够使用System类的数组复制方法<br>-[ ] 能够使用System类获取当前毫秒时刻值<br>-[ ] 能够说出使用StringBuilder类可以解决的问题<br>-[ ] 能够使用StringBuilder进行字符串拼接操作<br>-[ ] 能够说出8种基本类型对应的包装类名称<br>-[ ] 能够说出自动装箱、自动拆箱的概念<br>-[ ] 能够将字符串转换为对应的基本类型<br>-[ ] 能够将基本类型转换为对应的字符串</p>
<h1 id="第一章-Object类"><a href="#第一章-Object类" class="headerlink" title="第一章 Object类"></a>第一章 Object类</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p><code>java.lang.Object</code>类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是Object。</p>
<p>如果一个类没有特别指定父类，    那么默认则继承自Object类。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> /*<span class="keyword">extends</span> <span class="title">Object</span>*/ </span>&#123;</span><br><span class="line">  	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据JDK源代码及Object类的API文档，Object类当中包含的方法有11个。今天我们主要学习其中的2个：</p>
<ul>
<li><code>public String toString()</code>：返回该对象的字符串表示。</li>
<li><code>public boolean equals(Object obj)</code>：指示其他某个对象是否与此对象“相等”。</li>
</ul>
<h2 id="1-2-toString方法"><a href="#1-2-toString方法" class="headerlink" title="1.2 toString方法"></a>1.2 toString方法</h2><h3 id="方法摘要"><a href="#方法摘要" class="headerlink" title="方法摘要"></a>方法摘要</h3><ul>
<li><code>public String toString()</code>：返回该对象的字符串表示。</li>
</ul>
<p>toString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值。</p>
<p>由于toString方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。</p>
<h3 id="覆盖重写"><a href="#覆盖重写" class="headerlink" title="覆盖重写"></a>覆盖重写</h3><p>如果不希望使用toString方法的默认行为，则可以对它进行覆盖重写。例如自定义的Person类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> + <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略构造器与Getter Setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在IntelliJ IDEA中，可以点击<code>Code</code>菜单中的<code>Generate...</code>，也可以使用快捷键<code>alt+insert</code>，点击<code>toString()</code>选项。选择需要包含的成员变量并确定。如下图所示：</p>
<p><img src="/img%5CtoString%E6%96%B9%E6%B3%95%E7%9A%84%E8%87%AA%E5%8A%A8%E9%87%8D%E5%86%99.bmp" alt="toString方法的自动重写"></p>
<blockquote>
<p>小贴士： 在我们直接使用输出语句输出对象名的时候,其实通过该对象调用了其toString()方法。</p>
</blockquote>
<h2 id="1-3-equals方法"><a href="#1-3-equals方法" class="headerlink" title="1.3 equals方法"></a>1.3 equals方法</h2><h3 id="方法摘要-1"><a href="#方法摘要-1" class="headerlink" title="方法摘要"></a>方法摘要</h3><ul>
<li><code>public boolean equals(Object obj)</code>：指示其他某个对象是否与此对象“相等”。</li>
</ul>
<p>调用成员方法equals并指定参数为另一个对象，则可以判断这两个对象是否是相同的。这里的“相同”有默认和自定义两种方式。</p>
<h3 id="默认地址比较"><a href="#默认地址比较" class="headerlink" title="默认地址比较"></a>默认地址比较</h3><p>如果没有覆盖重写equals方法，那么Object类中默认进行<code>==</code>运算符的对象地址比较，只要不是同一个对象，结果必然为false。</p>
<h3 id="对象内容比较"><a href="#对象内容比较" class="headerlink" title="对象内容比较"></a>对象内容比较</h3><p>如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以覆盖重写equals方法。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;	</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果对象地址一样，则认为相同</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 如果参数为空，或者类型信息不一样，则认为不同</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 转换为当前类型</span></span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        <span class="comment">// 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果</span></span><br><span class="line">        <span class="keyword">return</span> age == person.age &amp;&amp; Objects.equals(name, person.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码充分考虑了对象为空、类型一致等问题，但方法内容并不唯一。大多数IDE都可以自动生成equals方法的代码内容。在IntelliJ IDEA中，可以使用<code>Code</code>菜单中的<code>Generate…</code>选项，也可以使用快捷键<code>alt+insert</code>，并选择<code>equals() and hashCode()</code>进行自动代码生成。如下图所示：</p>
<p><img src="/img%5Cequals%E6%96%B9%E6%B3%951.png"></p>
<p><img src="/img%5Cequals%E6%96%B9%E6%B3%952.png"></p>
<p><img src="/img%5Cequals%E6%96%B9%E6%B3%953.png"></p>
<blockquote>
<p>tips：Object类当中的hashCode等其他方法，今后学习。</p>
</blockquote>
<h2 id="1-4-Objects类"><a href="#1-4-Objects类" class="headerlink" title="1.4 Objects类"></a>1.4 Objects类</h2><p>在刚才IDEA自动重写equals代码中，使用到了<code>java.util.Objects</code>类，那么这个类是什么呢？</p>
<p>在<strong>JDK7</strong>添加了一个Objects工具类，它提供了一些方法来操作对象，它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），用于计算对象的hashcode、返回对象的字符串表示形式、比较两个对象。</p>
<p>在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。方法如下：</p>
<ul>
<li><code>public static boolean equals(Object a, Object b)</code>:判断两个对象是否相等。</li>
</ul>
<p>我们可以查看一下源码，学习一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object a, Object b)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> (a == b) || (a != <span class="keyword">null</span> &amp;&amp; a.equals(b));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第二章-日期时间类"><a href="#第二章-日期时间类" class="headerlink" title="第二章 日期时间类"></a>第二章 日期时间类</h1><h2 id="2-1-Date类"><a href="#2-1-Date类" class="headerlink" title="2.1 Date类"></a>2.1 Date类</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><code> java.util.Date</code>类 表示特定的瞬间，精确到毫秒。</p>
<p>继续查阅Date类的描述，发现Date拥有多个构造函数，只是部分已经过时，但是其中有未过时的构造函数可以把毫秒值转成日期对象。</p>
<ul>
<li><code>public Date()</code>：分配Date对象并初始化此对象，以表示分配它的时间（精确到毫秒）。</li>
<li><code>public Date(long date)</code>：分配Date对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。</li>
</ul>
<blockquote>
<p>tips: 由于我们处于东八区，所以我们的基准时间为1970年1月1日8时0分0秒。</p>
</blockquote>
<p>简单来说：使用无参构造，可以自动设置当前系统时间的毫秒时刻；指定long类型的构造参数，可以自定义毫秒时刻。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Date</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建日期对象，把当前的时间</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> Date()); <span class="comment">// Tue Jan 16 14:37:35 CST 2018</span></span><br><span class="line">        <span class="comment">// 创建日期对象，把当前的毫秒值转成日期对象</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> Date(<span class="number">0L</span>)); <span class="comment">// Thu Jan 01 08:00:00 CST 1970</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips:在使用println方法时，会自动调用Date类中的toString方法。Date类对Object类中的toString方法进行了覆盖重写，所以结果为指定格式的字符串。</p>
</blockquote>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>Date类中的多数方法已经过时，常用的方法有：</p>
<ul>
<li><code>public long getTime()</code> 把日期对象转换成对应的时间毫秒值。</li>
</ul>
<h2 id="2-2-DateFormat类"><a href="#2-2-DateFormat类" class="headerlink" title="2.2 DateFormat类"></a>2.2 DateFormat类</h2><p><code>java.text.DateFormat</code> 是日期/时间格式化子类的抽象类，我们通过这个类可以帮我们完成日期和文本之间的转换,也就是可以在Date对象与String对象之间进行来回转换。</p>
<ul>
<li><strong>格式化</strong>：按照指定的格式，从Date对象转换为String对象。</li>
<li><strong>解析</strong>：按照指定的格式，从String对象转换为Date对象。</li>
</ul>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>由于DateFormat为抽象类，不能直接使用，所以需要常用的子类<code>java.text.SimpleDateFormat</code>。这个类需要一个模式（格式）来指定格式化或解析的标准。构造方法为：</p>
<ul>
<li><code>public SimpleDateFormat(String pattern)</code>：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。</li>
</ul>
<p>参数pattern是一个字符串，代表日期时间的自定义格式。</p>
<h3 id="格式规则"><a href="#格式规则" class="headerlink" title="格式规则"></a>格式规则</h3><p>常用的格式规则为：</p>
<table>
<thead>
<tr>
<th>标识字母（区分大小写）</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>y</td>
<td>年</td>
</tr>
<tr>
<td>M</td>
<td>月</td>
</tr>
<tr>
<td>d</td>
<td>日</td>
</tr>
<tr>
<td>H</td>
<td>时</td>
</tr>
<tr>
<td>m</td>
<td>分</td>
</tr>
<tr>
<td>s</td>
<td>秒</td>
</tr>
</tbody></table>
<blockquote>
<p>备注：更详细的格式规则，可以参考SimpleDateFormat类的API文档0。</p>
</blockquote>
<p>创建SimpleDateFormat对象的代码如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02SimpleDateFormat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对应的日期格式如：2018-01-16 15:06:38</span></span><br><span class="line">        DateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><p>DateFormat类的常用方法有：</p>
<ul>
<li><code>public String format(Date date)</code>：将Date对象格式化为字符串。</li>
<li><code>public Date parse(String source)</code>：将字符串解析为Date对象。</li>
</ul>
<h4 id="format方法"><a href="#format方法" class="headerlink" title="format方法"></a>format方法</h4><p>使用format方法的代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 把Date对象转换成String</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03DateFormatMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="comment">// 创建日期格式化对象,在获取格式化对象时可以指定风格</span></span><br><span class="line">        DateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年MM月dd日&quot;</span>);</span><br><span class="line">        String str = df.format(date);</span><br><span class="line">        System.out.println(str); <span class="comment">// 2008年1月23日</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="parse方法"><a href="#parse方法" class="headerlink" title="parse方法"></a>parse方法</h4><p>使用parse方法的代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 把String转换成Date对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04DateFormatMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        DateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年MM月dd日&quot;</span>);</span><br><span class="line">        String str = <span class="string">&quot;2018年12月11日&quot;</span>;</span><br><span class="line">        Date date = df.parse(str);</span><br><span class="line">        System.out.println(date); <span class="comment">// Tue Dec 11 00:00:00 CST 2018</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-练习"><a href="#2-3-练习" class="headerlink" title="2.3 练习"></a>2.3 练习</h2><p>请使用日期时间相关的API，计算出一个人已经出生了多少天。</p>
<p><strong>思路：</strong></p>
<p>1.获取当前时间对应的毫秒值</p>
<p>2.获取自己出生日期对应的毫秒值</p>
<p>3.两个时间相减（当前时间– 出生日期）</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;请输入出生日期 格式 YYYY-MM-dd&quot;</span>);</span><br><span class="line">	<span class="comment">// 获取出生日期,键盘输入</span></span><br><span class="line">	String birthdayString = <span class="keyword">new</span> Scanner(System.in).next();</span><br><span class="line">	<span class="comment">// 将字符串日期,转成Date对象</span></span><br><span class="line">	<span class="comment">// 创建SimpleDateFormat对象,写日期模式</span></span><br><span class="line">	SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">	<span class="comment">// 调用方法parse,字符串转成日期对象</span></span><br><span class="line">	Date birthdayDate = sdf.parse(birthdayString);	</span><br><span class="line">	<span class="comment">// 获取今天的日期对象</span></span><br><span class="line">	Date todayDate = <span class="keyword">new</span> Date();	</span><br><span class="line">	<span class="comment">// 将两个日期转成毫秒值,Date类的方法getTime</span></span><br><span class="line">	<span class="keyword">long</span> birthdaySecond = birthdayDate.getTime();</span><br><span class="line">	<span class="keyword">long</span> todaySecond = todayDate.getTime();</span><br><span class="line">	<span class="keyword">long</span> secone = todaySecond-birthdaySecond;	</span><br><span class="line">	<span class="keyword">if</span> (secone &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;还没出生呢&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		System.out.println(secone/<span class="number">1000</span>/<span class="number">60</span>/<span class="number">60</span>/<span class="number">24</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-Calendar类"><a href="#2-4-Calendar类" class="headerlink" title="2.4 Calendar类"></a>2.4 Calendar类</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>日历我们都见过</p>
<p><img src="/img%5C%E6%97%A5%E5%8E%86.jpg"></p>
<p><code>java.util.Calendar</code>是日历类，在Date后出现，替换掉了许多Date的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。日历类就是方便获取各个时间属性的。</p>
<h3 id="获取方式"><a href="#获取方式" class="headerlink" title="获取方式"></a>获取方式</h3><p>Calendar为抽象类，由于语言敏感性，Calendar类在创建对象时并非直接创建，而是通过静态方法创建，返回子类对象，如下：</p>
<p>Calendar静态方法</p>
<ul>
<li><code>public static Calendar getInstance()</code>：使用默认时区和语言环境获得一个日历</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo06CalendarInit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h3><p>根据Calendar类的API文档，常用方法有：</p>
<ul>
<li><code>public int get(int field)</code>：返回给定日历字段的值。</li>
<li><code>public void set(int field, int value)</code>：将给定的日历字段设置为给定值。</li>
<li><code>public abstract void add(int field, int amount)</code>：根据日历的规则，为给定的日历字段添加或减去指定的时间量。</li>
<li><code>public Date getTime()</code>：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。</li>
</ul>
<p>Calendar类中提供很多成员常量，代表给定的日历字段：</p>
<table>
<thead>
<tr>
<th>字段值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>YEAR</td>
<td>年</td>
</tr>
<tr>
<td>MONTH</td>
<td>月（从0开始，可以+1使用）</td>
</tr>
<tr>
<td>DAY_OF_MONTH</td>
<td>月中的天（几号）</td>
</tr>
<tr>
<td>HOUR</td>
<td>时（12小时制）</td>
</tr>
<tr>
<td>HOUR_OF_DAY</td>
<td>时（24小时制）</td>
</tr>
<tr>
<td>MINUTE</td>
<td>分</td>
</tr>
<tr>
<td>SECOND</td>
<td>秒</td>
</tr>
<tr>
<td>DAY_OF_WEEK</td>
<td>周中的天（周几，周日为1，可以-1使用）</td>
</tr>
</tbody></table>
<h4 id="get-set方法"><a href="#get-set方法" class="headerlink" title="get/set方法"></a>get/set方法</h4><p>get方法用来获取指定字段的值，set方法用来设置指定字段的值，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalendarUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建Calendar对象</span></span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">        <span class="comment">// 设置年 </span></span><br><span class="line">        <span class="keyword">int</span> year = cal.get(Calendar.YEAR);</span><br><span class="line">        <span class="comment">// 设置月</span></span><br><span class="line">        <span class="keyword">int</span> month = cal.get(Calendar.MONTH) + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 设置日</span></span><br><span class="line">        <span class="keyword">int</span> dayOfMonth = cal.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        System.out.print(year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + dayOfMonth + <span class="string">&quot;日&quot;</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo07CalendarMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">        cal.set(Calendar.YEAR, <span class="number">2020</span>);</span><br><span class="line">        System.out.print(year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + dayOfMonth + <span class="string">&quot;日&quot;</span>); <span class="comment">// 2020年1月17日</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h4><p>add方法可以对指定日历字段的值进行加减操作，如果第二个参数为正数则加上偏移量，如果为负数则减去偏移量。代码如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo08CalendarMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">        System.out.print(year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + dayOfMonth + <span class="string">&quot;日&quot;</span>); <span class="comment">// 2018年1月17日</span></span><br><span class="line">        <span class="comment">// 使用add方法</span></span><br><span class="line">        cal.add(Calendar.DAY_OF_MONTH, <span class="number">2</span>); <span class="comment">// 加2天</span></span><br><span class="line">        cal.add(Calendar.YEAR, -<span class="number">3</span>); <span class="comment">// 减3年</span></span><br><span class="line">        System.out.print(year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + dayOfMonth + <span class="string">&quot;日&quot;</span>); <span class="comment">// 2015年1月18日; </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="getTime方法"><a href="#getTime方法" class="headerlink" title="getTime方法"></a>getTime方法</h4><p>Calendar中的getTime方法并不是获取毫秒时刻，而是拿到对应的Date对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo09CalendarMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">        Date date = cal.getTime();</span><br><span class="line">        System.out.println(date); <span class="comment">// Tue Jan 16 16:03:09 CST 2018</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：</p>
<p>​     西方星期的开始为周日，中国为周一。</p>
<p>​     在Calendar类中，月份的表示是以0-11代表1-12月。</p>
<p>​     日期是有大小关系的，时间靠后，时间越大。</p>
</blockquote>
<h1 id="第三章-System类"><a href="#第三章-System类" class="headerlink" title="第三章 System类"></a>第三章 System类</h1><p><code>java.lang.System</code>类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作，在System类的API文档中，常用的方法有：</p>
<ul>
<li><code>public static long currentTimeMillis()</code>：返回以毫秒为单位的当前时间。</li>
<li><code>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code>：将数组中指定的数据拷贝到另一个数组中。</li>
</ul>
<h2 id="3-1-currentTimeMillis方法"><a href="#3-1-currentTimeMillis方法" class="headerlink" title="3.1 currentTimeMillis方法"></a>3.1 currentTimeMillis方法</h2><p>实际上，currentTimeMillis方法就是 获取当前系统时间与1970年01月01日00:00点之间的毫秒差值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       	<span class="comment">//获取当前时间毫秒值</span></span><br><span class="line">        System.out.println(System.currentTimeMillis()); <span class="comment">// 1516090531144</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>验证for循环打印数字1-9999所需要使用的时间（毫秒）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;共耗时毫秒：&quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-arraycopy方法"><a href="#3-2-arraycopy方法" class="headerlink" title="3.2 arraycopy方法"></a>3.2 arraycopy方法</h2><ul>
<li><code>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code>：将数组中指定的数据拷贝到另一个数组中。</li>
</ul>
<p>数组的拷贝动作是系统级的，性能很高。System.arraycopy方法具有5个参数，含义分别为：</p>
<table>
<thead>
<tr>
<th>参数序号</th>
<th>参数名称</th>
<th>参数类型</th>
<th>参数含义</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>src</td>
<td>Object</td>
<td>源数组</td>
</tr>
<tr>
<td>2</td>
<td>srcPos</td>
<td>int</td>
<td>源数组索引起始位置</td>
</tr>
<tr>
<td>3</td>
<td>dest</td>
<td>Object</td>
<td>目标数组</td>
</tr>
<tr>
<td>4</td>
<td>destPos</td>
<td>int</td>
<td>目标数组索引起始位置</td>
</tr>
<tr>
<td>5</td>
<td>length</td>
<td>int</td>
<td>复制元素个数</td>
</tr>
</tbody></table>
<h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3><p>将src数组中前3个元素，复制到dest数组的前3个位置上复制元素前：src数组元素[1,2,3,4,5]，dest数组元素[6,7,8,9,10]复制元素后：src数组元素[1,2,3,4,5]，dest数组元素[1,2,3,9,10]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo11SystemArrayCopy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] src = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] dest = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        System.arraycopy( src, <span class="number">0</span>, dest, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">/*代码运行后：两个数组中的元素发生了变化</span></span><br><span class="line"><span class="comment">         src数组元素[1,2,3,4,5]</span></span><br><span class="line"><span class="comment">         dest数组元素[1,2,3,9,10]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第四章-StringBuilder类"><a href="#第四章-StringBuilder类" class="headerlink" title="第四章 StringBuilder类"></a>第四章 StringBuilder类</h1><h2 id="4-1-字符串拼接问题"><a href="#4-1-字符串拼接问题" class="headerlink" title="4.1 字符串拼接问题"></a>4.1 字符串拼接问题</h2><p>由于String类的对象内容不可改变，所以每当进行字符串拼接时，总是会在内存中创建一个新的对象。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        s += <span class="string">&quot;World&quot;</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在API中对String类有这样的描述：字符串是常量，它们的值在创建后不能被更改。</p>
<p>根据这句话分析我们的代码，其实总共产生了三个字符串，即<code>&quot;Hello&quot;</code>、<code>&quot;World&quot;</code>和<code>&quot;HelloWorld&quot;</code>。引用变量s首先指向<code>Hello</code>对象，最终指向拼接出来的新字符串对象，即<code>HelloWord</code> 。</p>
<p><img src="/img%5CString%E6%8B%BC%E6%8E%A5%E9%97%AE%E9%A2%98.bmp"></p>
<p>由此可知，如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。为了解决这一问题，可以使用<code>java.lang.StringBuilder</code>类。</p>
<h2 id="4-2-StringBuilder概述"><a href="#4-2-StringBuilder概述" class="headerlink" title="4.2 StringBuilder概述"></a>4.2 StringBuilder概述</h2><p>查阅<code>java.lang.StringBuilder</code>的API，StringBuilder又称为可变字符序列，它是一个类似于 String 的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。</p>
<p>原来StringBuilder是个字符串的缓冲区，即它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。</p>
<p>它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。StringBuilder会自动维护数组的扩容。原理如下图所示：(默认16字符空间，超过自动扩充)</p>
<p><img src="/img%5C06-StringBuilder%E7%9A%84%E5%8E%9F%E7%90%86.png" alt="06-StringBuilder的原理"></p>
<h2 id="4-3-构造方法"><a href="#4-3-构造方法" class="headerlink" title="4.3 构造方法"></a>4.3 构造方法</h2><p>根据StringBuilder的API文档，常用构造方法有2个：</p>
<ul>
<li><code>public StringBuilder()</code>：构造一个空的StringBuilder容器。</li>
<li><code>public StringBuilder(String str)</code>：构造一个StringBuilder容器，并将字符串添加进去。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb1 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        System.out.println(sb1); <span class="comment">// (空白)</span></span><br><span class="line">        <span class="comment">// 使用带参构造</span></span><br><span class="line">        StringBuilder sb2 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">        System.out.println(sb2); <span class="comment">// itcast</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-4-常用方法"><a href="#4-4-常用方法" class="headerlink" title="4.4 常用方法"></a>4.4 常用方法</h2><p>StringBuilder常用的方法有2个：</p>
<ul>
<li><code>public StringBuilder append(...)</code>：添加任意类型数据的字符串形式，并返回当前对象自身。</li>
<li><code>public String toString()</code>：将当前StringBuilder对象转换为String对象。</li>
</ul>
<h3 id="append方法"><a href="#append方法" class="headerlink" title="append方法"></a>append方法</h3><p>append方法具有多种重载形式，可以接收任意类型的参数。任何数据作为参数都会将对应的字符串内容添加到StringBuilder中。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02StringBuilder</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建对象</span></span><br><span class="line">		StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="comment">//public StringBuilder append(任意类型)</span></span><br><span class="line">		StringBuilder builder2 = builder.append(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">		<span class="comment">//对比一下</span></span><br><span class="line">		System.out.println(<span class="string">&quot;builder:&quot;</span>+builder);</span><br><span class="line">		System.out.println(<span class="string">&quot;builder2:&quot;</span>+builder2);</span><br><span class="line">		System.out.println(builder == builder2); <span class="comment">//true</span></span><br><span class="line">	    <span class="comment">// 可以添加 任何类型</span></span><br><span class="line">		builder.append(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">		builder.append(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">		builder.append(<span class="keyword">true</span>);</span><br><span class="line">		builder.append(<span class="number">100</span>);</span><br><span class="line">		<span class="comment">// 在我们开发中，会遇到调用一个方法后，返回一个对象的情况。然后使用返回的对象继续调用方法。</span></span><br><span class="line">        <span class="comment">// 这种时候，我们就可以把代码现在一起，如append方法一样，代码如下</span></span><br><span class="line">		<span class="comment">//链式编程</span></span><br><span class="line">		builder.append(<span class="string">&quot;hello&quot;</span>).append(<span class="string">&quot;world&quot;</span>).append(<span class="keyword">true</span>).append(<span class="number">100</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;builder:&quot;</span>+builder);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>备注：StringBuilder已经覆盖重写了Object当中的toString方法。</p>
</blockquote>
<h3 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h3><p>通过toString方法，StringBuilder对象将会转换为不可变的String对象。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo16StringBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 链式创建</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;Hello&quot;</span>).append(<span class="string">&quot;World&quot;</span>).append(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用方法</span></span><br><span class="line">        String str = sb.toString();</span><br><span class="line">        System.out.println(str); <span class="comment">// HelloWorldJava</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第五章-包装类"><a href="#第五章-包装类" class="headerlink" title="第五章 包装类"></a>第五章 包装类</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p>Java提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下：</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>对应的包装类（位于java.lang包中）</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td><strong>Integer</strong></td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>char</td>
<td><strong>Character</strong></td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody></table>
<h2 id="5-2-装箱与拆箱"><a href="#5-2-装箱与拆箱" class="headerlink" title="5.2 装箱与拆箱"></a>5.2 装箱与拆箱</h2><p>基本类型与对应的包装类对象之间，来回转换的过程称为”装箱“与”拆箱“：</p>
<ul>
<li><p><strong>装箱</strong>：从基本类型转换为对应的包装类对象。</p>
</li>
<li><p><strong>拆箱</strong>：从包装类对象转换为对应的基本类型。</p>
</li>
</ul>
<p>用Integer与 int为例：（看懂代码即可）</p>
<p>基本数值—-&gt;包装对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">4</span>);<span class="comment">//使用构造函数函数</span></span><br><span class="line">Integer iii = Integer.valueOf(<span class="number">4</span>);<span class="comment">//使用包装类中的valueOf方法</span></span><br></pre></td></tr></table></figure>

<p>包装对象—-&gt;基本数值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = i.intValue();</span><br></pre></td></tr></table></figure>
<h2 id="5-3自动装箱与自动拆箱"><a href="#5-3自动装箱与自动拆箱" class="headerlink" title="5.3自动装箱与自动拆箱"></a>5.3自动装箱与自动拆箱</h2><p>由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i = <span class="number">4</span>;<span class="comment">//自动装箱。相当于Integer i = Integer.valueOf(4);</span></span><br><span class="line">i = i + <span class="number">5</span>;<span class="comment">//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;</span></span><br><span class="line"><span class="comment">//加法运算完成后，再次装箱，把基本数值转成对象。</span></span><br></pre></td></tr></table></figure>

<h2 id="5-3-基本类型与字符串之间的转换"><a href="#5-3-基本类型与字符串之间的转换" class="headerlink" title="5.3 基本类型与字符串之间的转换"></a>5.3 基本类型与字符串之间的转换</h2><h3 id="基本类型转换为String"><a href="#基本类型转换为String" class="headerlink" title="基本类型转换为String"></a>基本类型转换为String</h3><p>   基本类型转换String总共有三种方式，查看课后资料可以得知，这里只讲最简单的一种方式： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">基本类型直接与””相连接即可；如：34+&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>String转换成对应的基本类型 </p>
<p>除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型：</p>
<ul>
<li><code>public static byte parseByte(String s)</code>：将字符串参数转换为对应的byte基本类型。</li>
<li><code>public static short parseShort(String s)</code>：将字符串参数转换为对应的short基本类型。</li>
<li><code>public static int parseInt(String s)</code>：将字符串参数转换为对应的int基本类型。</li>
<li><code>public static long parseLong(String s)</code>：将字符串参数转换为对应的long基本类型。</li>
<li><code>public static float parseFloat(String s)</code>：将字符串参数转换为对应的float基本类型。</li>
<li><code>public static double parseDouble(String s)</code>：将字符串参数转换为对应的double基本类型。</li>
<li><code>public static boolean parseBoolean(String s)</code>：将字符串参数转换为对应的boolean基本类型。</li>
</ul>
<p>代码使用（仅以Integer类的静态方法parseXxx为例）如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo18WrapperParse</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = Integer.parseInt(<span class="string">&quot;100&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出<code>java.lang.NumberFormatException</code>异常。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Object类</tag>
      </tags>
  </entry>
  <entry>
    <title>Collection、泛型</title>
    <url>/2020/08/06/Java%20%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/Collection%E3%80%81%E6%B3%9B%E5%9E%8B/day02%E3%80%90Collection%E3%80%81%E6%B3%9B%E5%9E%8B%E3%80%91-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="day02【Collection、泛型】"><a href="#day02【Collection、泛型】" class="headerlink" title="day02【Collection、泛型】"></a>day02【Collection、泛型】</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li>Collection集合</li>
<li>迭代器</li>
<li>增强for</li>
<li>泛型</li>
</ul>
<h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><ul>
<li><input disabled="" type="checkbox"> 能够说出集合与数组的区别</li>
<li><input disabled="" type="checkbox"> 说出Collection集合的常用功能</li>
<li><input disabled="" type="checkbox"> 能够使用迭代器对集合进行取元素</li>
<li><input disabled="" type="checkbox"> 能够说出集合的使用细节</li>
<li><input disabled="" type="checkbox"> 能够使用集合存储自定义类型</li>
<li><input disabled="" type="checkbox"> 能够使用foreach循环遍历集合</li>
<li><input disabled="" type="checkbox"> 能够使用泛型定义集合对象</li>
<li><input disabled="" type="checkbox"> 能够理解泛型上下限</li>
<li><input disabled="" type="checkbox"> 能够阐述泛型通配符的作用</li>
</ul>
<h1 id="第一章-Collection集合"><a href="#第一章-Collection集合" class="headerlink" title="第一章 Collection集合"></a>第一章 Collection集合</h1><h2 id="1-1-集合概述"><a href="#1-1-集合概述" class="headerlink" title="1.1 集合概述"></a>1.1 集合概述</h2><p>在前面基础班我们已经学习过并使用过集合ArrayList<E> ,那么集合到底是什么呢?</p>
<ul>
<li><strong>集合</strong>：集合是java中提供的一种容器，可以用来存储多个数据。</li>
</ul>
<p>集合和数组既然都是容器，它们有啥区别呢？</p>
<ul>
<li>数组的长度是固定的。集合的长度是可变的。</li>
<li>数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。</li>
</ul>
<h2 id="1-2-集合框架"><a href="#1-2-集合框架" class="headerlink" title="1.2  集合框架"></a>1.2  集合框架</h2><p>JAVASE提供了满足各种需求的API，在使用这些API前，先了解其继承与接口操作架构，才能了解何时采用哪个类，以及类之间如何彼此合作，从而达到灵活应用。</p>
<p>集合按照其存储结构可以分为两大类，分别是单列集合<code>java.util.Collection</code>和双列集合<code>java.util.Map</code>，今天我们主要学习<code>Collection</code>集合，在day04时讲解<code>Map</code>集合。</p>
<ul>
<li><strong>Collection</strong>：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是<code>java.util.List</code>和<code>java.util.Set</code>。其中，<code>List</code>的特点是元素有序、元素可重复。<code>Set</code>的特点是元素无序，而且不可重复。<code>List</code>接口的主要实现类有<code>java.util.ArrayList</code>和<code>java.util.LinkedList</code>，<code>Set</code>接口的主要实现类有<code>java.util.HashSet</code>和<code>java.util.TreeSet</code>。</li>
</ul>
<p>从上面的描述可以看出JDK中提供了丰富的集合类库，为了便于初学者进行系统地学习，接下来通过一张图来描述整个集合类的继承体系。</p>
<p><img src="/img%5CCollection%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB%E5%9B%BE.png"></p>
<p>其中，橙色框里填写的都是接口类型，而蓝色框里填写的都是具体的实现类。这几天将针对图中所列举的集合类进行逐一地讲解。</p>
<p>集合本身是一个工具，它存放在java.util包中。在<code>Collection</code>接口定义着单列集合框架中最最共性的内容。</p>
<h2 id="1-3-Collection-常用功能"><a href="#1-3-Collection-常用功能" class="headerlink" title="1.3 Collection 常用功能"></a>1.3 Collection 常用功能</h2><p>Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下：</p>
<ul>
<li><code>public boolean add(E e)</code>：  把给定的对象添加到当前集合中 。</li>
<li><code>public void clear()</code> :清空集合中所有的元素。</li>
<li><code>public boolean remove(E e)</code>: 把给定的对象在当前集合中删除。</li>
<li><code>public boolean contains(E e)</code>: 判断当前集合中是否包含给定的对象。</li>
<li><code>public boolean isEmpty()</code>: 判断当前集合是否为空。</li>
<li><code>public int size()</code>: 返回集合中元素的个数。</li>
<li><code>public Object[] toArray()</code>: 把集合中的元素，存储到数组中。</li>
</ul>
<p>方法演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1Collection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 创建集合对象 </span></span><br><span class="line">    	<span class="comment">// 使用多态形式</span></span><br><span class="line">    	Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    	<span class="comment">// 使用方法</span></span><br><span class="line">    	<span class="comment">// 添加功能  boolean  add(String s)</span></span><br><span class="line">    	coll.add(<span class="string">&quot;小李广&quot;</span>);</span><br><span class="line">    	coll.add(<span class="string">&quot;扫地僧&quot;</span>);</span><br><span class="line">    	coll.add(<span class="string">&quot;石破天&quot;</span>);</span><br><span class="line">    	System.out.println(coll);</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// boolean contains(E e) 判断o是否在集合中存在</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;判断  扫地僧 是否在集合中&quot;</span>+coll.contains(<span class="string">&quot;扫地僧&quot;</span>));</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//boolean remove(E e) 删除在集合中的o元素</span></span><br><span class="line">    	System.out.println(<span class="string">&quot;删除石破天：&quot;</span>+coll.remove(<span class="string">&quot;石破天&quot;</span>));</span><br><span class="line">    	System.out.println(<span class="string">&quot;操作之后集合中元素:&quot;</span>+coll);</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// size() 集合中有几个元素</span></span><br><span class="line">		System.out.println(<span class="string">&quot;集合中有&quot;</span>+coll.size()+<span class="string">&quot;个元素&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Object[] toArray()转换成一个Object数组</span></span><br><span class="line">    	Object[] objects = coll.toArray();</span><br><span class="line">    	<span class="comment">// 遍历数组</span></span><br><span class="line">    	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objects.length; i++) &#123;</span><br><span class="line">			System.out.println(objects[i]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// void  clear() 清空集合</span></span><br><span class="line">		coll.clear();</span><br><span class="line">		System.out.println(<span class="string">&quot;集合中内容为：&quot;</span>+coll);</span><br><span class="line">		<span class="comment">// boolean  isEmpty()  判断是否为空</span></span><br><span class="line">		System.out.println(coll.isEmpty());  	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips: 有关Collection中的方法可不止上面这些，其他方法可以自行查看API学习。</p>
</blockquote>
<h2 id="第二章-Iterator迭代器"><a href="#第二章-Iterator迭代器" class="headerlink" title="第二章 Iterator迭代器"></a>第二章 Iterator迭代器</h2><h2 id="2-1-Iterator接口"><a href="#2-1-Iterator接口" class="headerlink" title="2.1 Iterator接口"></a>2.1 Iterator接口</h2><p>在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口<code>java.util.Iterator</code>。<code>Iterator</code>接口也是Java集合中的一员，但它与<code>Collection</code>、<code>Map</code>接口有所不同，<code>Collection</code>接口与<code>Map</code>接口主要用于存储元素，而<code>Iterator</code>主要用于迭代访问（即遍历）<code>Collection</code>中的元素，因此<code>Iterator</code>对象也被称为迭代器。</p>
<p>想要遍历Collection集合，那么就要获取该集合迭代器完成迭代操作，下面介绍一下获取迭代器的方法：</p>
<ul>
<li><code>public Iterator iterator()</code>: 获取集合对应的迭代器，用来遍历集合中的元素的。</li>
</ul>
<p>下面介绍一下迭代的概念：</p>
<ul>
<li><strong>迭代</strong>：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。</li>
</ul>
<p>Iterator接口的常用方法如下：</p>
<ul>
<li><code>public E next()</code>:返回迭代的下一个元素。</li>
<li><code>public boolean hasNext()</code>:如果仍有元素可以迭代，则返回 true。</li>
</ul>
<p>接下来我们通过案例学习如何使用Iterator迭代集合中元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorDemo</span> </span>&#123;</span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用多态方式 创建对象</span></span><br><span class="line">        Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加元素到集合</span></span><br><span class="line">        coll.add(<span class="string">&quot;串串星人&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;吐槽星人&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;汪星人&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="comment">//使用迭代器 遍历   每个集合对象都有自己的迭代器</span></span><br><span class="line">        Iterator&lt;String&gt; it = coll.iterator();</span><br><span class="line">        <span class="comment">//  泛型指的是 迭代出 元素的数据类型</span></span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123; <span class="comment">//判断是否有迭代元素</span></span><br><span class="line">            String s = it.next();<span class="comment">//获取迭代出的元素</span></span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips:：在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会发生java.util.NoSuchElementException没有集合元素的错误。</p>
</blockquote>
<h2 id="2-2-迭代器的实现原理"><a href="#2-2-迭代器的实现原理" class="headerlink" title="2.2 迭代器的实现原理"></a>2.2 迭代器的实现原理</h2><p>我们在之前案例已经完成了Iterator遍历集合的整个过程。当遍历集合时，首先通过调用t集合的iterator()方法获得迭代器对象，然后使用hashNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。</p>
<p>Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素，为了让初学者能更好地理解迭代器的工作原理，接下来通过一个图例来演示Iterator对象迭代元素的过程：</p>
<p><img src="/img%5C%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8E%9F%E7%90%86%E5%9B%BE.bmp"></p>
<p>在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。</p>
<h2 id="2-3-增强for"><a href="#2-3-增强for" class="headerlink" title="2.3 增强for"></a>2.3 增强for</h2><p>增强for循环(也称for each循环)是<strong>JDK1.5</strong>以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。</p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素的数据类型  变量 : Collection集合or数组)&#123; </span><br><span class="line">  	<span class="comment">//写操作代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作。</p>
<h4 id="练习1：遍历数组"><a href="#练习1：遍历数组" class="headerlink" title="练习1：遍历数组"></a>练习1：遍历数组</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NBForDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">87</span>&#125;;</span><br><span class="line">       	<span class="comment">//使用增强for遍历数组</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> a : arr)&#123;<span class="comment">//a代表数组中的每个元素</span></span><br><span class="line">			System.out.println(a);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="练习2-遍历集合"><a href="#练习2-遍历集合" class="headerlink" title="练习2:遍历集合"></a>练习2:遍历集合</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NBFor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        </span><br><span class="line">    	Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    	coll.add(<span class="string">&quot;小河神&quot;</span>);</span><br><span class="line">    	coll.add(<span class="string">&quot;老河神&quot;</span>);</span><br><span class="line">    	coll.add(<span class="string">&quot;神婆&quot;</span>);</span><br><span class="line">    	<span class="comment">//使用增强for遍历</span></span><br><span class="line">    	<span class="keyword">for</span>(String s :coll)&#123;<span class="comment">//接收变量s代表 代表被遍历到的集合元素</span></span><br><span class="line">    		System.out.println(s);</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips: 新for循环必须有被遍历的目标。目标只能是Collection或者是数组。新式for仅仅作为遍历操作出现。</p>
</blockquote>
<h1 id="第三章-泛型"><a href="#第三章-泛型" class="headerlink" title="第三章 泛型"></a>第三章 泛型</h1><h2 id="3-1-泛型概述"><a href="#3-1-泛型概述" class="headerlink" title="3.1  泛型概述"></a>3.1  泛型概述</h2><p>在前面学习集合时，我们都知道集合中是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升成Object类型。当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。</p>
<p>大家观察下面代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">		coll.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">		coll.add(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">		coll.add(<span class="number">5</span>);<span class="comment">//由于集合没有做任何限定，任何类型都可以给其中存放</span></span><br><span class="line">		Iterator it = coll.iterator();</span><br><span class="line">		<span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">			<span class="comment">//需要打印每个字符串的长度,就要把迭代出来的对象转成String类型</span></span><br><span class="line">			String str = (String) it.next();</span><br><span class="line">			System.out.println(str.length());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序在运行时发生了问题<strong>java.lang.ClassCastException</strong>。                                                                                             为什么会发生类型转换异常呢？                                                                                                                                       我们来分析下：由于集合中什么类型的元素都可以存储。导致取出时强转引发运行时 ClassCastException。                                                                                                                                                       怎么来解决这个问题呢？                                                                                                                                                           Collection虽然可以存储各种对象，但实际上通常Collection只存储同一类型对象。例如都是存储字符串对象。因此在JDK5之后，新增了<strong>泛型</strong>(<strong>Generic</strong>)语法，让你在设计API时可以指定类或方法支持泛型，这样我们使用API的时候也变得更为简洁，并得到了编译时期的语法检查。</p>
<ul>
<li><strong>泛型</strong>：可以在类或方法中预支地使用未知的类型。</li>
</ul>
<blockquote>
<p>tips:一般在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为Object类型。</p>
</blockquote>
<h2 id="3-2-使用泛型的好处"><a href="#3-2-使用泛型的好处" class="headerlink" title="3.2  使用泛型的好处"></a>3.2  使用泛型的好处</h2><p>上一节只是讲解了泛型的引入，那么泛型带来了哪些好处呢？</p>
<ul>
<li>将运行时期的ClassCastException，转移到了编译时期变成了编译失败。</li>
<li>避免了类型强转的麻烦。</li>
</ul>
<p>通过我们如下代码体验一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">        <span class="comment">// list.add(5);//当集合明确类型后，存放类型不一致就会编译报错</span></span><br><span class="line">        <span class="comment">// 集合已经明确具体存放的元素类型，那么在使用迭代器的时候，迭代器也同样会知道具体遍历元素类型</span></span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            String str = it.next();</span><br><span class="line">            <span class="comment">//当使用Iterator&lt;String&gt;控制元素类型后，就不需要强转了。获取到的元素直接就是String类型</span></span><br><span class="line">            System.out.println(str.length());</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips:泛型是数据类型的一部分，我们将类名与泛型合并一起看做数据类型。</p>
</blockquote>
<h2 id="3-3-泛型的定义与使用"><a href="#3-3-泛型的定义与使用" class="headerlink" title="3.3  泛型的定义与使用"></a>3.3  泛型的定义与使用</h2><p>我们在集合中会大量使用到泛型，这里来完整地学习泛型知识。</p>
<p>泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递。</p>
<h3 id="定义和使用含有泛型的类"><a href="#定义和使用含有泛型的类" class="headerlink" title="定义和使用含有泛型的类"></a>定义和使用含有泛型的类</h3><p>定义格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修饰符 class 类名&lt;代表泛型的变量&gt; &#123;  &#125;</span><br></pre></td></tr></table></figure>

<p>例如，API中的ArrayList集合：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt;</span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123; &#125;</span><br><span class="line">   	....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用泛型： 即什么时候确定泛型。</p>
<p><strong>在创建对象的时候确定泛型</strong></p>
<p> 例如，<code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</code></p>
<p>此时，变量E的值就是String类型,那么我们的类型就可以理解为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">String</span>&gt;</span>&#123; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(String e)</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;  &#125;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再例如，<code>ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</code></p>
<p>此时，变量E的值就是Integer类型,那么我们的类型就可以理解为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">Integer</span>&gt; </span>&#123; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Integer e)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  &#125;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举例自定义泛型类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGenericClass</span>&lt;<span class="title">MVP</span>&gt; </span>&#123;</span><br><span class="line">	<span class="comment">//没有MVP类型，在这里代表 未知的一种数据类型 未来传递什么就是什么类型</span></span><br><span class="line">	<span class="keyword">private</span> MVP mvp;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMVP</span><span class="params">(MVP mvp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mvp = mvp;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> MVP <span class="title">getMVP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mvp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericClassDemo</span> </span>&#123;</span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;		 </span><br><span class="line">         <span class="comment">// 创建一个泛型为String的类</span></span><br><span class="line">         MyGenericClass&lt;String&gt; my = <span class="keyword">new</span> MyGenericClass&lt;String&gt;();    	</span><br><span class="line">         <span class="comment">// 调用setMVP</span></span><br><span class="line">         my.setMVP(<span class="string">&quot;大胡子登登&quot;</span>);</span><br><span class="line">         <span class="comment">// 调用getMVP</span></span><br><span class="line">         String mvp = my.getMVP();</span><br><span class="line">         System.out.println(mvp);</span><br><span class="line">         <span class="comment">//创建一个泛型为Integer的类</span></span><br><span class="line">         MyGenericClass&lt;Integer&gt; my2 = <span class="keyword">new</span> MyGenericClass&lt;Integer&gt;(); </span><br><span class="line">         my2.setMVP(<span class="number">123</span>);   	  </span><br><span class="line">         Integer mvp2 = my2.getMVP();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="含有泛型的方法"><a href="#含有泛型的方法" class="headerlink" title="含有泛型的方法"></a>含有泛型的方法</h3><p>定义格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数)&#123;  &#125;</span><br></pre></td></tr></table></figure>

<p>例如，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGenericMethod</span> </span>&#123;	  </span><br><span class="line">    <span class="keyword">public</span> &lt;MVP&gt; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(MVP mvp)</span> </span>&#123;</span><br><span class="line">    	System.out.println(mvp.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> &lt;MVP&gt; <span class="function">MVP <span class="title">show2</span><span class="params">(MVP mvp)</span> </span>&#123;	</span><br><span class="line">    	<span class="keyword">return</span> mvp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用格式：<strong>调用方法时，确定泛型的类型</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericMethodDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        MyGenericMethod mm = <span class="keyword">new</span> MyGenericMethod();</span><br><span class="line">        <span class="comment">// 演示看方法提示</span></span><br><span class="line">        mm.show(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        mm.show(<span class="number">123</span>);</span><br><span class="line">        mm.show(<span class="number">12.45</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="含有泛型的接口"><a href="#含有泛型的接口" class="headerlink" title="含有泛型的接口"></a>含有泛型的接口</h3><p>定义格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修饰符 interface接口名&lt;代表泛型的变量&gt; &#123;  &#125;</span><br></pre></td></tr></table></figure>

<p>例如，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyGenericInterface</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> E <span class="title">getE</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用格式：</p>
<p><strong>1、定义类时确定泛型的类型</strong></p>
<p>例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImp1</span> <span class="keyword">implements</span> <span class="title">MyGenericInterface</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getE</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，泛型E的值就是String类型。</p>
<p> <strong>2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型</strong></p>
<p> 例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImp2</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">MyGenericInterface</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       	 <span class="comment">// 省略...</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> E <span class="title">getE</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>确定泛型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyImp2&lt;String&gt;  my = <span class="keyword">new</span> MyImp2&lt;String&gt;();  </span><br><span class="line">        my.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-4-泛型通配符"><a href="#3-4-泛型通配符" class="headerlink" title="3.4  泛型通配符"></a>3.4  泛型通配符</h2><p>当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。</p>
<h4 id="通配符基本使用"><a href="#通配符基本使用" class="headerlink" title="通配符基本使用"></a>通配符基本使用</h4><p>泛型的通配符:<strong>不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。</strong></p>
<p>此时只能接受数据,不能往该集合中存储数据。</p>
<p>举个例子大家理解使用即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Collection&lt;Intger&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    getElement(list1);</span><br><span class="line">    Collection&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    getElement(list2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement</span><span class="params">(Collection&lt;?&gt; coll)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//？代表可以接收任意类型</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips:泛型不存在继承关系 Collection<Object> list = new ArrayList<String>();这种是错误的。</p>
</blockquote>
<h4 id="通配符高级使用—-受限泛型"><a href="#通配符高级使用—-受限泛型" class="headerlink" title="通配符高级使用—-受限泛型"></a>通配符高级使用—-受限泛型</h4><p>之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的<strong>上限</strong>和<strong>下限</strong>。</p>
<p><strong>泛型的上限</strong>：</p>
<ul>
<li><strong>格式</strong>： <code>类型名称 &lt;? extends 类 &gt; 对象名称</code></li>
<li><strong>意义</strong>： <code>只能接收该类型及其子类</code></li>
</ul>
<p><strong>泛型的下限</strong>：</p>
<ul>
<li><strong>格式</strong>： <code>类型名称 &lt;? super 类 &gt; 对象名称</code></li>
<li><strong>意义</strong>： <code>只能接收该类型及其父类型</code></li>
</ul>
<p>比如：现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Collection&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    Collection&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    Collection&lt;Number&gt; list3 = <span class="keyword">new</span> ArrayList&lt;Number&gt;();</span><br><span class="line">    Collection&lt;Object&gt; list4 = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">    </span><br><span class="line">    getElement(list1);</span><br><span class="line">    getElement(list2);<span class="comment">//报错</span></span><br><span class="line">    getElement(list3);</span><br><span class="line">    getElement(list4);<span class="comment">//报错</span></span><br><span class="line">  </span><br><span class="line">    getElement2(list1);<span class="comment">//报错</span></span><br><span class="line">    getElement2(list2);<span class="comment">//报错</span></span><br><span class="line">    getElement2(list3);</span><br><span class="line">    getElement2(list4);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement1</span><span class="params">(Collection&lt;? extends Number&gt; coll)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement2</span><span class="params">(Collection&lt;? <span class="keyword">super</span> Number&gt; coll)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第四章-集合综合案例"><a href="#第四章-集合综合案例" class="headerlink" title="第四章 集合综合案例"></a>第四章 集合综合案例</h1><h2 id="4-1-案例介绍"><a href="#4-1-案例介绍" class="headerlink" title="4.1 案例介绍"></a>4.1 案例介绍</h2><p>按照斗地主的规则，完成洗牌发牌的动作。<br>具体规则：</p>
<p>使用54张牌打乱顺序,三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。</p>
<h2 id="4-2-案例分析"><a href="#4-2-案例分析" class="headerlink" title="4.2 案例分析"></a>4.2 案例分析</h2><ul>
<li><p>准备牌：</p>
<p>牌可以设计为一个ArrayList<String>,每个字符串为一张牌。<br>每张牌由花色数字两部分组成，我们可以使用花色集合与数字集合嵌套迭代完成每张牌的组装。<br>牌由Collections类的shuffle方法进行随机排序。</p>
</li>
<li><p>发牌</p>
<p>将每个人以及底牌设计为ArrayList<String>,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。</p>
</li>
</ul>
<ul>
<li><p>看牌</p>
<p>直接打印每个集合。</p>
</li>
</ul>
<h2 id="4-3-代码实现"><a href="#4-3-代码实现" class="headerlink" title="4.3 代码实现"></a>4.3 代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Poker</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 1: 准备牌操作</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//1.1 创建牌盒 将来存储牌面的 </span></span><br><span class="line">        ArrayList&lt;String&gt; pokerBox = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="comment">//1.2 创建花色集合</span></span><br><span class="line">        ArrayList&lt;String&gt; colors = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.3 创建数字集合</span></span><br><span class="line">        ArrayList&lt;String&gt; numbers = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.4 分别给花色 以及 数字集合添加元素</span></span><br><span class="line">        colors.add(<span class="string">&quot;♥&quot;</span>);</span><br><span class="line">        colors.add(<span class="string">&quot;♦&quot;</span>);</span><br><span class="line">        colors.add(<span class="string">&quot;♠&quot;</span>);</span><br><span class="line">        colors.add(<span class="string">&quot;♣&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">            numbers.add(i+<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        numbers.add(<span class="string">&quot;J&quot;</span>);</span><br><span class="line">        numbers.add(<span class="string">&quot;Q&quot;</span>);</span><br><span class="line">        numbers.add(<span class="string">&quot;K&quot;</span>);</span><br><span class="line">        numbers.add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        <span class="comment">//1.5 创造牌  拼接牌操作</span></span><br><span class="line">        <span class="comment">// 拿出每一个花色  然后跟每一个数字 进行结合  存储到牌盒中</span></span><br><span class="line">        <span class="keyword">for</span> (String color : colors) &#123;</span><br><span class="line">            <span class="comment">//color每一个花色 </span></span><br><span class="line">            <span class="comment">//遍历数字集合</span></span><br><span class="line">            <span class="keyword">for</span>(String number : numbers)&#123;</span><br><span class="line">                <span class="comment">//结合</span></span><br><span class="line">                String card = color+number;</span><br><span class="line">                <span class="comment">//存储到牌盒中</span></span><br><span class="line">                pokerBox.add(card);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1.6大王小王</span></span><br><span class="line">        pokerBox.add(<span class="string">&quot;小☺&quot;</span>);</span><br><span class="line">        pokerBox.add(<span class="string">&quot;大☠&quot;</span>);	  </span><br><span class="line">        <span class="comment">// System.out.println(pokerBox);</span></span><br><span class="line">        <span class="comment">//洗牌 是不是就是将  牌盒中 牌的索引打乱 </span></span><br><span class="line">        <span class="comment">// Collections类  工具类  都是 静态方法</span></span><br><span class="line">        <span class="comment">// shuffer方法   </span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * static void shuffle(List&lt;?&gt; list) </span></span><br><span class="line"><span class="comment">         *     使用默认随机源对指定列表进行置换。 </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//2:洗牌</span></span><br><span class="line">        Collections.shuffle(pokerBox);</span><br><span class="line">        <span class="comment">//3 发牌</span></span><br><span class="line">        <span class="comment">//3.1 创建 三个 玩家集合  创建一个底牌集合</span></span><br><span class="line">        ArrayList&lt;String&gt; player1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; player2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; player3 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; dipai = <span class="keyword">new</span> ArrayList&lt;String&gt;();	  </span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历 牌盒  必须知道索引   </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;pokerBox.size();i++)&#123;</span><br><span class="line">            <span class="comment">//获取 牌面</span></span><br><span class="line">            String card = pokerBox.get(i);</span><br><span class="line">            <span class="comment">//留出三张底牌 存到 底牌集合中</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">51</span>)&#123;<span class="comment">//存到底牌集合中</span></span><br><span class="line">                dipai.add(card);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//玩家1   %3  ==0</span></span><br><span class="line">                <span class="keyword">if</span>(i%<span class="number">3</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                  	player1.add(card);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i%<span class="number">3</span>==<span class="number">1</span>)&#123;<span class="comment">//玩家2</span></span><br><span class="line">                  	player2.add(card);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//玩家3</span></span><br><span class="line">                  	player3.add(card);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//看看</span></span><br><span class="line">        System.out.println(<span class="string">&quot;令狐冲：&quot;</span>+player1);</span><br><span class="line">        System.out.println(<span class="string">&quot;田伯光：&quot;</span>+player2);</span><br><span class="line">        System.out.println(<span class="string">&quot;绿竹翁：&quot;</span>+player3);</span><br><span class="line">        System.out.println(<span class="string">&quot;底牌：&quot;</span>+dipai);  </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>List、Set、数据结构、Collections</title>
    <url>/2020/08/06/Java%20%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/List%E3%80%81Set%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81Collections/day03%E3%80%90List%E3%80%81Set%E3%80%91/</url>
    <content><![CDATA[<h1 id="day03-【List、Set、数据结构、Collections】"><a href="#day03-【List、Set、数据结构、Collections】" class="headerlink" title="day03 【List、Set、数据结构、Collections】"></a>day03 【List、Set、数据结构、Collections】</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li>数据结构</li>
<li>List集合</li>
<li>Set集合</li>
<li>Collections</li>
</ul>
<h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><ul>
<li><input disabled="" type="checkbox"> 能够说出List集合特点</li>
<li><input disabled="" type="checkbox"> 能够说出常见的数据结构</li>
<li><input disabled="" type="checkbox"> 能够说出数组结构特点</li>
<li><input disabled="" type="checkbox"> 能够说出栈结构特点</li>
<li><input disabled="" type="checkbox"> 能够说出队列结构特点</li>
<li><input disabled="" type="checkbox"> 能够说出单向链表结构特点</li>
<li><input disabled="" type="checkbox"> 能够说出Set集合的特点</li>
<li><input disabled="" type="checkbox"> 能够说出哈希表的特点</li>
<li><input disabled="" type="checkbox"> 使用HashSet集合存储自定义元素</li>
<li><input disabled="" type="checkbox"> 能够说出可变参数的格式</li>
<li><input disabled="" type="checkbox"> 能够使用集合工具类</li>
<li><input disabled="" type="checkbox"> 能够使用Comparator比较器进行排序</li>
</ul>
<h1 id="第一章-数据结构"><a href="#第一章-数据结构" class="headerlink" title="第一章 数据结构"></a>第一章 数据结构</h1><h2 id="2-1-数据结构有什么用？"><a href="#2-1-数据结构有什么用？" class="headerlink" title="2.1 数据结构有什么用？"></a>2.1 数据结构有什么用？</h2><p>当你用着java里面的容器类很爽的时候，你有没有想过，怎么ArrayList就像一个无限扩充的数组，也好像链表之类的。好用吗？好用，这就是数据结构的用处，只不过你在不知不觉中使用了。</p>
<p>现实世界的存储，我们使用的工具和建模。每种数据结构有自己的优点和缺点，想想如果Google的数据用的是数组的存储，我们还能方便地查询到所需要的数据吗？而算法，在这么多的数据中如何做到最快的插入，查找，删除，也是在追求更快。</p>
<p>我们java是面向对象的语言，就好似自动档轿车，C语言好似手动档吉普。数据结构呢？是变速箱的工作原理。你完全可以不知道变速箱怎样工作，就把自动档的车子从 A点 开到 B点，而且未必就比懂得的人慢。写程序这件事，和开车一样，经验可以起到很大作用，但如果你不知道底层是怎么工作的，就永远只能开车，既不会修车，也不能造车。当然了，数据结构内容比较多，细细的学起来也是相对费功夫的，不可能达到一蹴而就。我们将常见的数据结构：堆栈、队列、数组、链表和红黑树 这几种给大家介绍一下，作为数据结构的入门，了解一下它们的特点即可。</p>
<p><img src="/img%5C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%AF%94%E5%96%BB.png"></p>
<h2 id="2-2-常见的数据结构"><a href="#2-2-常见的数据结构" class="headerlink" title="2.2 常见的数据结构"></a>2.2 常见的数据结构</h2><p>数据存储的常用结构有：栈、队列、数组、链表和红黑树。我们分别来了解一下：</p>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><ul>
<li><strong>栈</strong>：<strong>stack</strong>,又称堆栈，它是运算受限的线性表，其限制是仅允许在标的一端进行插入和删除操作，不允许在其他任何位置进行添加、查找、删除等操作。</li>
</ul>
<p>简单的说：采用该结构的集合，对元素的存取有如下的特点</p>
<ul>
<li><p>先进后出（即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素）。例如，子弹压进弹夹，先压进去的子弹在下面，后压进去的子弹在上面，当开枪时，先弹出上面的子弹，然后才能弹出下面的子弹。</p>
</li>
<li><p>栈的入口、出口的都是栈的顶端位置。</p>
<p><img src="/img%5C%E5%A0%86%E6%A0%88.png"></p>
</li>
</ul>
<p>这里两个名词需要注意：</p>
<ul>
<li><strong>压栈</strong>：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置。</li>
<li><strong>弹栈</strong>：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置。</li>
</ul>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><ul>
<li><strong>队列</strong>：<strong>queue</strong>,简称队，它同堆栈一样，也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入，而在表的另一端进行删除。</li>
</ul>
<p>简单的说，采用该结构的集合，对元素的存取有如下的特点：</p>
<ul>
<li>先进先出（即，存进去的元素，要在后它前面的元素依次取出后，才能取出该元素）。例如，小火车过山洞，车头先进去，车尾后进去；车头先出来，车尾后出来。</li>
<li>队列的入口、出口各占一侧。例如，下图中的左侧为入口，右侧为出口。</li>
</ul>
<p><img src="/img%5C%E9%98%9F%E5%88%97%E5%9B%BE.bmp"></p>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul>
<li><strong>数组</strong>:<strong>Array</strong>,是有序的元素序列，数组是在内存中开辟一段连续的空间，并在此空间存放元素。就像是一排出租屋，有100个房间，从001到100每个房间都有固定编号，通过编号就可以快速找到租房子的人。</li>
</ul>
<p>简单的说,采用该结构的集合，对元素的存取有如下的特点：</p>
<ul>
<li><p>查找元素快：通过索引，可以快速访问指定位置的元素</p>
<p> <img src="/img/%E6%95%B0%E7%BB%84%E6%9F%A5%E8%AF%A2%E5%BF%AB.png"></p>
</li>
<li><p> 增删元素慢</p>
</li>
<li><p><strong>指定索引位置增加元素</strong>：需要创建一个新数组，将指定新元素存储在指定索引位置，再把原数组元素根据索引，复制到新数组对应索引的位置。如下图<img src="/img/%E6%95%B0%E7%BB%84%E6%B7%BB%E5%8A%A0.png"></p>
</li>
<li><p><strong>指定索引位置删除元素：</strong>需要创建一个新数组，把原数组元素根据索引，复制到新数组对应索引的位置，原数组中指定索引位置元素不复制到新数组中。如下图<img src="/img/%E6%95%B0%E7%BB%84%E5%88%A0%E9%99%A4.png"></p>
</li>
</ul>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><ul>
<li><p><strong>链表</strong>:<strong>linked list</strong>,由一系列结点node（链表中每一个元素称为结点）组成，结点可以在运行时i动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。我们常说的链表结构有单向链表与双向链表，那么这里给大家介绍的是<strong>单向链表</strong>。</p>
<p><img src="/img%5C%E5%8D%95%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84%E7%89%B9%E7%82%B9.png"></p>
</li>
</ul>
<p>简单的说，采用该结构的集合，对元素的存取有如下的特点：</p>
<ul>
<li><p>多个结点之间，通过地址进行连接。例如，多个人手拉手，每个人使用自己的右手拉住下个人的左手，依次类推，这样多个人就连在一起了。</p>
<p><img src="/img%5C%E5%8D%95%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84.png"></p>
</li>
<li><p>查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素</p>
</li>
<li><p>增删元素快：</p>
<ul>
<li> 增加元素：只需要修改连接下个元素的地址即可。</li>
</ul>
<p>  <img src="/img%5C%E5%A2%9E%E5%8A%A0%E7%BB%93%E7%82%B9.png"></p>
<ul>
<li> 删除元素：只需要修改连接下个元素的地址即可。</li>
</ul>
<p>  <img src="/img%5C%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9.bmp"></p>
</li>
</ul>
<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><ul>
<li><strong>二叉树</strong>：<strong>binary tree</strong> ,是每个结点不超过2的有序<strong>树（tree）</strong> 。</li>
</ul>
<p>简单的理解，就是一种类似于我们生活中树的结构，只不过每个结点上都最多只能有两个子结点。</p>
<p>二叉树是每个节点最多有两个子树的树结构。顶上的叫根结点，两边被称作“左子树”和“右子树”。</p>
<p>如图：</p>
<p><img src="/img%5C%E4%BA%8C%E5%8F%89%E6%A0%91.bmp"></p>
<p>我们要说的是二叉树的一种比较有意思的叫做<strong>红黑树</strong>，红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。</p>
<p>红黑树的约束:</p>
<ol>
<li>节点可以是红色的或者黑色的</li>
</ol>
<ol start="2">
<li>根节点是黑色的</li>
</ol>
<ol start="3">
<li>叶子节点(特指空节点)是黑色的</li>
<li>每个红色节点的子节点都是黑色的</li>
<li>任何一个节点到其每一个叶子节点的所有路径上黑色节点数相同</li>
</ol>
<p>红黑树的特点:</p>
<p>​    速度特别快,趋近平衡树,查找叶子元素最少和最多次数不多于二倍</p>
<h1 id="第二章-List集合"><a href="#第二章-List集合" class="headerlink" title="第二章 List集合"></a>第二章 List集合</h1><p>我们掌握了Collection接口的使用后，再来看看Collection接口中的子类，他们都具备那些特性呢？</p>
<p>接下来，我们一起学习Collection中的常用几个子类（<code>java.util.List</code>集合、<code>java.util.Set</code>集合）。</p>
<h2 id="1-1-List接口介绍"><a href="#1-1-List接口介绍" class="headerlink" title="1.1 List接口介绍"></a>1.1 List接口介绍</h2><p><code>java.util.List</code>接口继承自<code>Collection</code>接口，是单列集合的一个重要分支，习惯性地会将实现了<code>List</code>接口的对象称为List集合。在List集合中允许出现重复的元素，所有的元素是以一种线性方式进行存储的，在程序中可以通过索引来访问集合中的指定元素。另外，List集合还有一个特点就是元素有序，即元素的存入顺序和取出顺序一致。</p>
<p>看完API，我们总结一下：</p>
<p>List接口特点：</p>
<ol>
<li>它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。</li>
<li>它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。</li>
<li>集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。</li>
</ol>
<blockquote>
<p>tips:我们在基础班的时候已经学习过List接口的子类java.util.ArrayList类，该类中的方法都是来自List中定义。</p>
</blockquote>
<h2 id="1-2-List接口中常用方法"><a href="#1-2-List接口中常用方法" class="headerlink" title="1.2 List接口中常用方法"></a>1.2 List接口中常用方法</h2><p>List作为Collection集合的子接口，不但继承了Collection接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法，如下：</p>
<ul>
<li><code>public void add(int index, E element)</code>: 将指定的元素，添加到该集合中的指定位置上。</li>
<li><code>public E get(int index)</code>:返回集合中指定位置的元素。</li>
<li><code>public E remove(int index)</code>: 移除列表中指定位置的元素, 返回的是被移除的元素。</li>
<li><code>public E set(int index, E element)</code>:用指定元素替换集合中指定位置的元素,返回值的更新前的元素。</li>
</ul>
<p>List集合特有的方法都是跟索引相关，我们在基础班都学习过，那么我们再来复习一遍吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 创建List集合对象</span></span><br><span class="line">    	List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// 往 尾部添加 指定元素</span></span><br><span class="line">    	list.add(<span class="string">&quot;图图&quot;</span>);</span><br><span class="line">    	list.add(<span class="string">&quot;小美&quot;</span>);</span><br><span class="line">    	list.add(<span class="string">&quot;不高兴&quot;</span>);</span><br><span class="line">    	</span><br><span class="line">    	System.out.println(list);</span><br><span class="line">    	<span class="comment">// add(int index,String s) 往指定位置添加</span></span><br><span class="line">    	list.add(<span class="number">1</span>,<span class="string">&quot;没头脑&quot;</span>);</span><br><span class="line">    	</span><br><span class="line">    	System.out.println(list);</span><br><span class="line">    	<span class="comment">// String remove(int index) 删除指定位置元素  返回被删除元素</span></span><br><span class="line">    	<span class="comment">// 删除索引位置为2的元素 </span></span><br><span class="line">    	System.out.println(<span class="string">&quot;删除索引位置为2的元素&quot;</span>);</span><br><span class="line">    	System.out.println(list.remove(<span class="number">2</span>));</span><br><span class="line">    	</span><br><span class="line">    	System.out.println(list);</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// String set(int index,String s)</span></span><br><span class="line">    	<span class="comment">// 在指定位置 进行 元素替代（改） </span></span><br><span class="line">    	<span class="comment">// 修改指定位置元素</span></span><br><span class="line">    	list.set(<span class="number">0</span>, <span class="string">&quot;三毛&quot;</span>);</span><br><span class="line">    	System.out.println(list);</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// String get(int index)  获取指定位置元素</span></span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// 跟size() 方法一起用  来 遍历的 </span></span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">    		System.out.println(list.get(i));</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="comment">//还可以使用增强for</span></span><br><span class="line">    	<span class="keyword">for</span> (String string : list) &#123;</span><br><span class="line">			System.out.println(string);</span><br><span class="line">		&#125;  	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第三章-List的子类"><a href="#第三章-List的子类" class="headerlink" title="第三章 List的子类"></a>第三章 List的子类</h1><h2 id="3-1-ArrayList集合"><a href="#3-1-ArrayList集合" class="headerlink" title="3.1 ArrayList集合"></a>3.1 ArrayList集合</h2><p><code>java.util.ArrayList</code>集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以<code>ArrayList</code>是最常用的集合。</p>
<p>许多程序员开发时非常随意地使用ArrayList完成任何需求，并不严谨，这种用法是不提倡的。</p>
<h2 id="3-2-LinkedList集合"><a href="#3-2-LinkedList集合" class="headerlink" title="3.2 LinkedList集合"></a>3.2 LinkedList集合</h2><p><code>java.util.LinkedList</code>集合数据存储的结构是链表结构。方便元素添加、删除的集合。</p>
<blockquote>
<p>LinkedList是一个双向链表，那么双向链表是什么样子的呢，我们用个图了解下</p>
</blockquote>
<p><img src="/img%5C%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png"></p>
<p>实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。这些方法我们作为了解即可：</p>
<ul>
<li><code>public void addFirst(E e)</code>:将指定元素插入此列表的开头。</li>
<li><code>public void addLast(E e)</code>:将指定元素添加到此列表的结尾。</li>
<li><code>public E getFirst()</code>:返回此列表的第一个元素。</li>
<li><code>public E getLast()</code>:返回此列表的最后一个元素。</li>
<li><code>public E removeFirst()</code>:移除并返回此列表的第一个元素。</li>
<li><code>public E removeLast()</code>:移除并返回此列表的最后一个元素。</li>
<li><code>public E pop()</code>:从此列表所表示的堆栈处弹出一个元素。</li>
<li><code>public void push(E e)</code>:将元素推入此列表所表示的堆栈。</li>
<li><code>public boolean isEmpty()</code>：如果列表不包含元素，则返回true。</li>
</ul>
<p>LinkedList是List的子类，List中的方法LinkedList都是可以使用，这里就不做详细介绍，我们只需要了解LinkedList的特有方法即可。在开发时，LinkedList集合也可以作为堆栈，队列的结构使用。（了解即可）</p>
<p>方法演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;String&gt; link = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        link.addFirst(<span class="string">&quot;abc1&quot;</span>);</span><br><span class="line">        link.addFirst(<span class="string">&quot;abc2&quot;</span>);</span><br><span class="line">        link.addFirst(<span class="string">&quot;abc3&quot;</span>);</span><br><span class="line">        System.out.println(link);</span><br><span class="line">        <span class="comment">// 获取元素</span></span><br><span class="line">        System.out.println(link.getFirst());</span><br><span class="line">        System.out.println(link.getLast());</span><br><span class="line">        <span class="comment">// 删除元素</span></span><br><span class="line">        System.out.println(link.removeFirst());</span><br><span class="line">        System.out.println(link.removeLast());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!link.isEmpty()) &#123; <span class="comment">//判断集合是否为空</span></span><br><span class="line">            System.out.println(link.pop()); <span class="comment">//弹出集合中的栈顶元素</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(link);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第四章-Set接口"><a href="#第四章-Set接口" class="headerlink" title="第四章 Set接口"></a>第四章 Set接口</h1><p><code>java.util.Set</code>接口和<code>java.util.List</code>接口一样，同样继承自<code>Collection</code>接口，它与<code>Collection</code>接口中的方法基本一致，并没有对<code>Collection</code>接口进行功能上的扩充，只是比<code>Collection</code>接口更加严格了。与<code>List</code>接口不同的是，<code>Set</code>接口中元素无序，并且都会以某种规则保证存入的元素不出现重复。</p>
<p><code>Set</code>集合有多个子类，这里我们介绍其中的<code>java.util.HashSet</code>、<code>java.util.LinkedHashSet</code>这两个集合。</p>
<blockquote>
<p>tips:Set集合取出元素的方式可以采用：迭代器、增强for。</p>
</blockquote>
<h2 id="3-1-HashSet集合介绍"><a href="#3-1-HashSet集合介绍" class="headerlink" title="3.1 HashSet集合介绍"></a>3.1 HashSet集合介绍</h2><p><code>java.util.HashSet</code>是<code>Set</code>接口的一个实现类，它所存储的元素是不可重复的，并且元素都是无序的(即存取顺序不一致)。<code>java.util.HashSet</code>底层的实现其实是一个<code>java.util.HashMap</code>支持，由于我们暂时还未学习，先做了解。</p>
<p><code>HashSet</code>是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于：<code>hashCode</code>与<code>equals</code>方法。</p>
<p>我们先来使用一下Set集合存储，看下现象，再进行原理的讲解:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建 Set集合</span></span><br><span class="line">        HashSet&lt;String&gt;  set = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        set.add(<span class="keyword">new</span> String(<span class="string">&quot;cba&quot;</span>));</span><br><span class="line">        set.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;bac&quot;</span>); </span><br><span class="line">        set.add(<span class="string">&quot;cba&quot;</span>);  </span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span> (String name : set) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下，说明集合中不能存储重复元素：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cba</span><br><span class="line">abc</span><br><span class="line">bac</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips:根据结果我们发现字符串”cba”只存储了一个，也就是说重复的元素set集合不存储。</p>
</blockquote>
<h2 id="2-2-HashSet集合存储数据的结构（哈希表）"><a href="#2-2-HashSet集合存储数据的结构（哈希表）" class="headerlink" title="2.2  HashSet集合存储数据的结构（哈希表）"></a>2.2  HashSet集合存储数据的结构（哈希表）</h2><p>什么是哈希表呢？</p>
<p>在<strong>JDK1.8</strong>之前，哈希表底层采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，哈希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。</p>
<p>简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下图所示。<img src="/img%5C%E5%93%88%E5%B8%8C%E8%A1%A8.png"></p>
<p>看到这张图就有人要问了，这个是怎么存储的呢？</p>
<p>为了方便大家的理解我们结合一个存储流程图来说明一下：</p>
<p><img src="/img%5C%E5%93%88%E5%B8%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png"></p>
<p>总而言之，<strong>JDK1.8</strong>引入红黑树大程度优化了HashMap的性能，那么对于我们来讲保证HashSet集合元素的唯一，其实就是根据对象的hashCode和equals方法来决定的。如果我们往集合中存放自定义的对象，那么保证其唯一，就必须复写hashCode和equals方法建立属于当前对象的比较方式。</p>
<h2 id="2-3-HashSet存储自定义类型元素"><a href="#2-3-HashSet存储自定义类型元素" class="headerlink" title="2.3  HashSet存储自定义类型元素"></a>2.3  HashSet存储自定义类型元素</h2><p>给HashSet中存放自定义类型元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一</p>
<p>创建自定义Student类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Student student = (Student) o;</span><br><span class="line">        <span class="keyword">return</span> age == student.age &amp;&amp;</span><br><span class="line">               Objects.equals(name, student.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建集合对象   该集合中存储 Student类型对象</span></span><br><span class="line">        HashSet&lt;Student&gt; stuSet = <span class="keyword">new</span> HashSet&lt;Student&gt;();</span><br><span class="line">        <span class="comment">//存储 </span></span><br><span class="line">        Student stu = <span class="keyword">new</span> Student(<span class="string">&quot;于谦&quot;</span>, <span class="number">43</span>);</span><br><span class="line">        stuSet.add(stu);</span><br><span class="line">        stuSet.add(<span class="keyword">new</span> Student(<span class="string">&quot;郭德纲&quot;</span>, <span class="number">44</span>));</span><br><span class="line">        stuSet.add(<span class="keyword">new</span> Student(<span class="string">&quot;于谦&quot;</span>, <span class="number">43</span>));</span><br><span class="line">        stuSet.add(<span class="keyword">new</span> Student(<span class="string">&quot;郭麒麟&quot;</span>, <span class="number">23</span>));</span><br><span class="line">        stuSet.add(stu);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Student stu2 : stuSet) &#123;</span><br><span class="line">            System.out.println(stu2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">执行结果：</span><br><span class="line">Student [name=郭德纲, age=<span class="number">44</span>]</span><br><span class="line">Student [name=于谦, age=<span class="number">43</span>]</span><br><span class="line">Student [name=郭麒麟, age=<span class="number">23</span>]</span><br></pre></td></tr></table></figure>

<h2 id="2-3-LinkedHashSet"><a href="#2-3-LinkedHashSet" class="headerlink" title="2.3 LinkedHashSet"></a>2.3 LinkedHashSet</h2><p>我们知道HashSet保证元素唯一，可是元素存放进去是没有顺序的，那么我们要保证有序，怎么办呢？</p>
<p>在HashSet下面有一个子类<code>java.util.LinkedHashSet</code>，它是链表和哈希表组合的一个数据存储结构。</p>
<p>演示代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashSetDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Set&lt;String&gt; set = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;();</span><br><span class="line">		set.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">		set.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">		set.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">		set.add(<span class="string">&quot;bbc&quot;</span>);</span><br><span class="line">        Iterator&lt;String&gt; it = set.iterator();</span><br><span class="line">		<span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">			System.out.println(it.next());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">结果：</span><br><span class="line">  bbb</span><br><span class="line">  aaa</span><br><span class="line">  abc</span><br><span class="line">  bbc</span><br></pre></td></tr></table></figure>

<h2 id="1-9-可变参数"><a href="#1-9-可变参数" class="headerlink" title="1.9  可变参数"></a>1.9  可变参数</h2><p>在<strong>JDK1.5</strong>之后，如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化成如下格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型... 形参名)&#123;  &#125;</span><br></pre></td></tr></table></figure>

<p>其实这个书写完全等价与</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型[] 形参名)&#123;  &#125;</span><br></pre></td></tr></table></figure>

<p>只是后面这种定义，在调用时必须传递数组，而前者可以直接传递数据即可。</p>
<p><strong>JDK1.5</strong>以后。出现了简化操作。**…** 用在参数上，称之为可变参数。</p>
<p>同样是代表数组，但是在调用这个带有可变参数的方法时，不用创建数组(这就是简单之处)，直接将数组中的元素作为实际参数进行传递，其实编译成的class文件，将这些元素先封装到一个数组中，在进行传递。这些动作都在编译.class文件时，自动完成了。</p>
<p>代码演示：    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeArgs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">62</span>, <span class="number">431</span>, <span class="number">2</span> &#125;;</span><br><span class="line">        <span class="keyword">int</span> sum = getSum(arr);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">        <span class="comment">//  6  7  2 12 2121</span></span><br><span class="line">        <span class="comment">// 求 这几个元素和 6  7  2 12 2121</span></span><br><span class="line">        <span class="keyword">int</span> sum2 = getSum(<span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">2121</span>);</span><br><span class="line">        System.out.println(sum2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 完成数组  所有元素的求和 原始写法</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">      public static int getSum(int[] arr)&#123;</span></span><br><span class="line"><span class="comment">        int sum = 0;</span></span><br><span class="line"><span class="comment">        for(int a : arr)&#123;</span></span><br><span class="line"><span class="comment">            sum += a;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        return sum;</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//可变参数写法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span>... arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a : arr) &#123;</span><br><span class="line">            sum += a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips: 上述add方法在同一个类中，只能存在一个。因为会发生调用的不确定性</p>
<p>注意：如果在方法书写时，这个方法拥有多参数，参数中包含可变参数，可变参数一定要写在参数列表的末尾位置。</p>
</blockquote>
<h1 id="第五章-Collections"><a href="#第五章-Collections" class="headerlink" title="第五章  Collections"></a>第五章  Collections</h1><h2 id="2-1-常用功能"><a href="#2-1-常用功能" class="headerlink" title="2.1 常用功能"></a>2.1 常用功能</h2><ul>
<li><code>java.utils.Collections</code>是集合工具类，用来对集合进行操作。部分方法如下：</li>
</ul>
<ul>
<li><code>public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements)  </code>:往集合中添加一些元素。</li>
<li><code>public static void shuffle(List&lt;?&gt; list) 打乱顺序</code>:打乱集合顺序。</li>
<li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>:将集合中元素按照默认规则排序。</li>
<li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>:将集合中元素按照指定规则排序。</li>
</ul>
<p>代码演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionsDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//原来写法</span></span><br><span class="line">        <span class="comment">//list.add(12);</span></span><br><span class="line">        <span class="comment">//list.add(14);</span></span><br><span class="line">        <span class="comment">//list.add(15);</span></span><br><span class="line">        <span class="comment">//list.add(1000);</span></span><br><span class="line">        <span class="comment">//采用工具类 完成 往集合中添加元素  </span></span><br><span class="line">        Collections.addAll(list, <span class="number">5</span>, <span class="number">222</span>, <span class="number">1</span>，<span class="number">2</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">//排序方法 </span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果：</span><br><span class="line">[<span class="number">5</span>, <span class="number">222</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">222</span>]</span><br></pre></td></tr></table></figure>

<p>代码演示之后 ，发现我们的集合按照顺序进行了排列，可是这样的顺序是采用默认的顺序，如果想要指定顺序那该怎么办呢？</p>
<p>我们发现还有个方法没有讲，<code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>:将集合中元素按照指定规则排序。接下来讲解一下指定规则的排列。</p>
<h2 id="2-2-Comparator比较器"><a href="#2-2-Comparator比较器" class="headerlink" title="2.2 Comparator比较器"></a>2.2 Comparator比较器</h2><p>我们还是先研究这个方法</p>
<p><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>:将集合中元素按照默认规则排序。</p>
<p>不过这次存储的是字符串类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionsDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt;  list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;cba&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;aba&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;sba&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;nba&quot;</span>);</span><br><span class="line">        <span class="comment">//排序方法</span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[aba, cba, nba, sba]</span><br></pre></td></tr></table></figure>

<p>我们使用的是默认的规则完成字符串的排序，那么默认规则是怎么定义出来的呢？</p>
<p>说到排序了，简单的说就是两个对象之间比较大小，那么在JAVA中提供了两种比较实现的方式，一种是比较死板的采用<code>java.lang.Comparable</code>接口去实现，一种是灵活的当我需要做排序的时候在去选择的<code>java.util.Comparator</code>接口完成。</p>
<p>那么我们采用的<code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>这个方法完成的排序，实际上要求了被排序的类型需要实现Comparable接口完成比较的功能，在String类型上如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<p>String类实现了这个接口，并完成了比较规则的定义，但是这样就把这种规则写死了，那比如我想要字符串按照第一个字符降序排列，那么这样就要修改String的源代码，这是不可能的了，那么这个时候我们可以使用</p>
<p><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>方法灵活的完成，这个里面就涉及到了Comparator这个接口，位于位于java.util包下，排序是comparator能实现的功能之一,该接口代表一个比较器，比较器具有可比性！顾名思义就是做排序的，通俗地讲需要比较两个对象谁排在前谁排在后，那么比较的方法就是：</p>
<ul>
<li><p><code> public int compare(String o1, String o2)</code>：比较其两个参数的顺序。</p>
<blockquote>
<p>两个对象比较的结果有三种：大于，等于，小于。</p>
<p>如果要按照升序排序，<br>则o1 小于o2，返回（负数），相等返回0，01大于02返回（正数）<br>如果要按照降序排序<br>则o1 小于o2，返回（正数），相等返回0，01大于02返回（负数）</p>
</blockquote>
</li>
</ul>
<p>操作如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionsDemo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;cba&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;aba&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;sba&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;nba&quot;</span>);</span><br><span class="line">        <span class="comment">//排序方法  按照第一个单词的降序</span></span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2.charAt(<span class="number">0</span>) - o1.charAt(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[sba, nba, cba, aba]</span><br></pre></td></tr></table></figure>

<h2 id="2-3-简述Comparable和Comparator两个接口的区别。"><a href="#2-3-简述Comparable和Comparator两个接口的区别。" class="headerlink" title="2.3 简述Comparable和Comparator两个接口的区别。"></a>2.3 简述Comparable和Comparator两个接口的区别。</h2><p><strong>Comparable</strong>：强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的compareTo方法被称为它的自然比较方法。只能在类中实现compareTo()一次，不能经常修改类的代码实现自己想要的排序。实现此接口的对象列表（和数组）可以通过Collections.sort（和Arrays.sort）进行自动排序，对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。</p>
<p><strong>Comparator</strong>强行对某个对象进行整体排序。可以将Comparator 传递给sort方法（如Collections.sort或 Arrays.sort），从而允许在排序顺序上实现精确控制。还可以使用Comparator来控制某些数据结构（如有序set或有序映射）的顺序，或者为那些没有自然顺序的对象collection提供排序。</p>
<h2 id="2-4-练习"><a href="#2-4-练习" class="headerlink" title="2.4  练习"></a>2.4  练习</h2><p>创建一个学生类，存储到ArrayList集合中完成指定排序操作。</p>
<p>Student 初始类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">               <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">               <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">               <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建四个学生对象 存储到集合中</span></span><br><span class="line">        ArrayList&lt;Student&gt; list = <span class="keyword">new</span> ArrayList&lt;Student&gt;();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="string">&quot;rose&quot;</span>,<span class="number">18</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="string">&quot;jack&quot;</span>,<span class="number">16</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="string">&quot;abc&quot;</span>,<span class="number">16</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="string">&quot;ace&quot;</span>,<span class="number">17</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="string">&quot;mark&quot;</span>,<span class="number">16</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          让学生 按照年龄排序 升序</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="comment">//        Collections.sort(list);//要求 该list中元素类型  必须实现比较器Comparable接口</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Student student : list) &#123;</span><br><span class="line">            System.out.println(student);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现，当我们调用Collections.sort()方法的时候 程序报错了。</p>
<p>原因：如果想要集合中的元素完成排序，那么必须要实现比较器Comparable接口。</p>
<p>于是我们就完成了Student类的一个实现，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Student</span>&gt;</span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age-o.age;<span class="comment">//升序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次测试，代码就OK 了效果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student&#123;name=<span class="string">&#x27;jack&#x27;</span>, age=<span class="number">16</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;abc&#x27;</span>, age=<span class="number">16</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;mark&#x27;</span>, age=<span class="number">16</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;ace&#x27;</span>, age=<span class="number">17</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;rose&#x27;</span>, age=<span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-5-扩展"><a href="#2-5-扩展" class="headerlink" title="2.5 扩展"></a>2.5 扩展</h2><p>如果在使用的时候，想要独立的定义规则去使用 可以采用Collections.sort(List list,Comparetor<T> c)方式，自己定义规则：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o2.getAge()-o1.getAge();<span class="comment">//以学生的年龄降序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Student&#123;name=&#x27;rose&#x27;, age=18&#125;</span><br><span class="line">Student&#123;name=&#x27;ace&#x27;, age=17&#125;</span><br><span class="line">Student&#123;name=&#x27;jack&#x27;, age=16&#125;</span><br><span class="line">Student&#123;name=&#x27;abc&#x27;, age=16&#125;</span><br><span class="line">Student&#123;name=&#x27;mark&#x27;, age=16&#125;</span><br></pre></td></tr></table></figure>



<p>如果想要规则更多一些，可以参考下面代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Student&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 年龄降序</span></span><br><span class="line">                <span class="keyword">int</span> result = o2.getAge()-o1.getAge();<span class="comment">//年龄降序</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(result==<span class="number">0</span>)&#123;<span class="comment">//第一个规则判断完了 下一个规则 姓名的首字母 升序</span></span><br><span class="line">                    result = o1.getName().charAt(<span class="number">0</span>)-o2.getName().charAt(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Student&#123;name=&#x27;rose&#x27;, age=18&#125;</span><br><span class="line">Student&#123;name=&#x27;ace&#x27;, age=17&#125;</span><br><span class="line">Student&#123;name=&#x27;abc&#x27;, age=16&#125;</span><br><span class="line">Student&#123;name=&#x27;jack&#x27;, age=16&#125;</span><br><span class="line">Student&#123;name=&#x27;mark&#x27;, age=16&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Map集合</title>
    <url>/2020/08/06/Java%20%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/day04_Map%EF%BC%8C%E6%96%97%E5%9C%B0%E4%B8%BB%E6%A1%88%E4%BE%8B/day04%20%E3%80%90Map%E3%80%91/</url>
    <content><![CDATA[<h1 id="day04-【Map】"><a href="#day04-【Map】" class="headerlink" title="day04 【Map】"></a>day04 【Map】</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li> Map集合</li>
</ul>
<h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><ul>
<li><input disabled="" type="checkbox"> 能够说出Map集合特点</li>
<li><input disabled="" type="checkbox"> 使用Map集合添加方法保存数据</li>
<li><input disabled="" type="checkbox"> 使用”键找值”的方式遍历Map集合</li>
<li><input disabled="" type="checkbox"> 使用”键值对”的方式遍历Map集合</li>
<li><input disabled="" type="checkbox"> 能够使用HashMap存储自定义键值对的数据</li>
<li><input disabled="" type="checkbox"> 能够使用HashMap编写斗地主洗牌发牌案例</li>
</ul>
<h1 id="第一章-Map集合"><a href="#第一章-Map集合" class="headerlink" title="第一章 Map集合"></a>第一章 Map集合</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p>现实生活中，我们常会看到这样的一种集合：IP地址与主机名，身份证号与个人，系统用户名与系统用户对象等，这种一一对应的关系，就叫做映射。Java提供了专门的集合类用来存放这种对象关系的对象，即<code>java.util.Map</code>接口。</p>
<p>我们通过查看<code>Map</code>接口描述，发现<code>Map</code>接口下的集合与<code>Collection</code>接口下的集合，它们存储数据的形式不同，如下图。</p>
<p><img src="/img%5CCollection%E4%B8%8EMap.bmp"></p>
<ul>
<li><code>Collection</code>中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储。</li>
<li><code>Map</code>中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。</li>
<li><code>Collection</code>中的集合称为单列集合，<code>Map</code>中的集合称为双列集合。</li>
<li>需要注意的是，<code>Map</code>中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。</li>
</ul>
<h2 id="1-2-Map常用子类"><a href="#1-2-Map常用子类" class="headerlink" title="1.2  Map常用子类"></a>1.2  Map常用子类</h2><p>通过查看Map接口描述，看到Map有多个子类，这里我们主要讲解常用的HashMap集合、LinkedHashMap集合。</p>
<ul>
<li>**HashMap&lt;K,V&gt;**：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</li>
<li>**LinkedHashMap&lt;K,V&gt;**：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</li>
</ul>
<blockquote>
<p>tips：Map接口中的集合都有两个泛型变量&lt;K,V&gt;,在使用时，要为两个泛型变量赋予数据类型。两个泛型变量&lt;K,V&gt;的数据类型可以相同，也可以不同。</p>
</blockquote>
<h2 id="1-3-Map接口中的常用方法"><a href="#1-3-Map接口中的常用方法" class="headerlink" title="1.3  Map接口中的常用方法"></a>1.3  Map接口中的常用方法</h2><p>Map接口中定义了很多方法，常用的如下：</p>
<ul>
<li><code>public V put(K key, V value)</code>:  把指定的键与指定的值添加到Map集合中。</li>
<li><code>public V remove(Object key)</code>: 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。</li>
<li><code>public V get(Object key)</code> 根据指定的键，在Map集合中获取对应的值。</li>
<li><code>boolean containsKey(Object key)  </code> 判断集合中是否包含指定的键。</li>
<li><code>public Set&lt;K&gt; keySet()</code>: 获取Map集合中所有的键，存储到Set集合中。</li>
<li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: 获取到Map集合中所有的键值对对象的集合(Set集合)。</li>
</ul>
<p>Map接口的方法演示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建 map对象</span></span><br><span class="line">        HashMap&lt;String, String&gt;  map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加元素到集合</span></span><br><span class="line">        map.put(<span class="string">&quot;黄晓明&quot;</span>, <span class="string">&quot;杨颖&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;文章&quot;</span>, <span class="string">&quot;马伊琍&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;邓超&quot;</span>, <span class="string">&quot;孙俪&quot;</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//String remove(String key)</span></span><br><span class="line">        System.out.println(map.remove(<span class="string">&quot;邓超&quot;</span>));</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 想要查看 黄晓明的媳妇 是谁</span></span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;黄晓明&quot;</span>));</span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;邓超&quot;</span>));    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips:</p>
<p>使用put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中； </p>
<p>若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。 </p>
</blockquote>
<h2 id="1-4-Map集合遍历键找值方式"><a href="#1-4-Map集合遍历键找值方式" class="headerlink" title="1.4   Map集合遍历键找值方式"></a>1.4   Map集合遍历键找值方式</h2><p>键找值方式：即通过元素中的键，获取键所对应的值</p>
<p>分析步骤：</p>
<ol>
<li>获取Map中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键。方法提示:<code>keyset()</code></li>
<li>遍历键的Set集合，得到每一个键。</li>
<li>根据键，获取键所对应的值。方法提示:<code>get(K key)</code></li>
</ol>
<p>代码演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Map集合对象 </span></span><br><span class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">        <span class="comment">//添加元素到集合 </span></span><br><span class="line">        map.put(<span class="string">&quot;胡歌&quot;</span>, <span class="string">&quot;霍建华&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;郭德纲&quot;</span>, <span class="string">&quot;于谦&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;薛之谦&quot;</span>, <span class="string">&quot;大张伟&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取所有的键  获取键集</span></span><br><span class="line">        Set&lt;String&gt; keys = map.keySet();</span><br><span class="line">        <span class="comment">// 遍历键集 得到 每一个键</span></span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">          	<span class="comment">//key  就是键</span></span><br><span class="line">            <span class="comment">//获取对应值</span></span><br><span class="line">            String value = map.get(key);</span><br><span class="line">            System.out.println(key+<span class="string">&quot;的CP是：&quot;</span>+value);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历图解：</p>
<p><img src="/img%5CMap%E9%9B%86%E5%90%88%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E4%B8%80.bmp"></p>
<h2 id="1-5-Entry键值对对象"><a href="#1-5-Entry键值对对象" class="headerlink" title="1.5  Entry键值对对象"></a>1.5  Entry键值对对象</h2><p>我们已经知道，<code>Map</code>中存放的是两种对象，一种称为<strong>key</strong>(键)，一种称为<strong>value</strong>(值)，它们在在<code>Map</code>中是一一对应关系，这一对对象又称做<code>Map</code>中的一个<code>Entry(项)</code>。<code>Entry</code>将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历<code>Map</code>集合时，就可以从每一个键值对（<code>Entry</code>）对象中获取对应的键与对应的值。</p>
<p> 既然Entry表示了一对键和值，那么也同样提供了获取对应键和对应值得方法：</p>
<ul>
<li><code>public K getKey()</code>：获取Entry对象中的键。</li>
<li><code>public V getValue()</code>：获取Entry对象中的值。</li>
</ul>
<p>在Map集合中也提供了获取所有Entry对象的方法：</p>
<ul>
<li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: 获取到Map集合中所有的键值对对象的集合(Set集合)。</li>
</ul>
<h2 id="1-6-Map集合遍历键值对方式"><a href="#1-6-Map集合遍历键值对方式" class="headerlink" title="1.6 Map集合遍历键值对方式"></a>1.6 Map集合遍历键值对方式</h2><p>键值对方式：即通过集合中每个键值对(Entry)对象，获取键值对(Entry)对象中的键与值。</p>
<p>操作步骤与图解：</p>
<ol>
<li><p> 获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回。方法提示:<code>entrySet()</code>。</p>
</li>
<li><p> 遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象。</p>
</li>
<li><p> 通过键值对(Entry)对象，获取Entry对象中的键与值。  方法提示:<code>getkey() getValue()</code>     </p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapDemo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建Map集合对象 </span></span><br><span class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">        <span class="comment">// 添加元素到集合 </span></span><br><span class="line">        map.put(<span class="string">&quot;胡歌&quot;</span>, <span class="string">&quot;霍建华&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;郭德纲&quot;</span>, <span class="string">&quot;于谦&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;薛之谦&quot;</span>, <span class="string">&quot;大张伟&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 所有的 entry对象  entrySet</span></span><br><span class="line">        Set&lt;Entry&lt;String,String&gt;&gt; entrySet = map.entrySet();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历得到每一个entry对象</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;String, String&gt; entry : entrySet) &#123;</span><br><span class="line">           	<span class="comment">// 解析 </span></span><br><span class="line">            String key = entry.getKey();</span><br><span class="line">            String value = entry.getValue();  </span><br><span class="line">            System.out.println(key+<span class="string">&quot;的CP是:&quot;</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历图解：</p>
<p><img src="/img%5CMap%E9%9B%86%E5%90%88%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E4%BA%8C.bmp"></p>
<blockquote>
<p>tips：Map集合不能直接使用迭代器或者foreach进行遍历。但是转成Set之后就可以使用了。</p>
</blockquote>
<h2 id="1-7-HashMap存储自定义类型键值"><a href="#1-7-HashMap存储自定义类型键值" class="headerlink" title="1.7  HashMap存储自定义类型键值"></a>1.7  HashMap存储自定义类型键值</h2><p>练习：每位学生（姓名，年龄）都有自己的家庭住址。那么，既然有对应关系，则将学生对象和家庭住址存储到map集合中。学生作为键, 家庭住址作为值。</p>
<blockquote>
<p>注意，学生姓名相同并且年龄相同视为同一名学生。</p>
</blockquote>
<p>编写学生类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Student student = (Student) o;</span><br><span class="line">        <span class="keyword">return</span> age == student.age &amp;&amp; Objects.equals(name, student.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1,创建Hashmap集合对象。</span></span><br><span class="line">        Map&lt;Student,String&gt;map = <span class="keyword">new</span> HashMap&lt;Student,String&gt;();</span><br><span class="line">        <span class="comment">//2,添加元素。</span></span><br><span class="line">        map.put(newStudent(<span class="string">&quot;lisi&quot;</span>,<span class="number">28</span>), <span class="string">&quot;上海&quot;</span>);</span><br><span class="line">        map.put(newStudent(<span class="string">&quot;wangwu&quot;</span>,<span class="number">22</span>), <span class="string">&quot;北京&quot;</span>);</span><br><span class="line">        map.put(newStudent(<span class="string">&quot;zhaoliu&quot;</span>,<span class="number">24</span>), <span class="string">&quot;成都&quot;</span>);</span><br><span class="line">        map.put(newStudent(<span class="string">&quot;zhouqi&quot;</span>,<span class="number">25</span>), <span class="string">&quot;广州&quot;</span>);</span><br><span class="line">        map.put(newStudent(<span class="string">&quot;wangwu&quot;</span>,<span class="number">22</span>), <span class="string">&quot;南京&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3,取出元素。键找值方式</span></span><br><span class="line">        Set&lt;Student&gt;keySet = map.keySet();</span><br><span class="line">        <span class="keyword">for</span>(Student key: keySet)&#123;</span><br><span class="line">            Stringvalue = map.get(key);</span><br><span class="line">            System.out.println(key.toString()+<span class="string">&quot;.....&quot;</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当给HashMap中存放自定义对象时，如果自定义对象作为key存在，这时要保证对象唯一，必须复写对象的hashCode和equals方法(如果忘记，请回顾HashSet存放自定义对象)。</li>
<li>如果要保证map中存放的key和取出的顺序一致，可以使用<code>java.util.LinkedHashMap</code>集合来存放。</li>
</ul>
<h2 id="1-8-LinkedHashMap"><a href="#1-8-LinkedHashMap" class="headerlink" title="1.8   LinkedHashMap"></a>1.8   LinkedHashMap</h2><p>我们知道HashMap保证成对元素唯一，并且查询速度很快，可是成对元素存放进去是没有顺序的，那么我们要保证有序，还要速度快怎么办呢？</p>
<p>在HashMap下面有一个子类LinkedHashMap，它是链表和哈希表组合的一个数据存储结构。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMapDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedHashMap&lt;String, String&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;邓超&quot;</span>, <span class="string">&quot;孙俪&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;李晨&quot;</span>, <span class="string">&quot;范冰冰&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;刘德华&quot;</span>, <span class="string">&quot;朱丽倩&quot;</span>);</span><br><span class="line">        Set&lt;Entry&lt;String, String&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;String, String&gt; entry : entrySet) &#123;</span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">&quot;  &quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">邓超  孙俪</span><br><span class="line">李晨  范冰冰</span><br><span class="line">刘德华  朱丽倩</span><br></pre></td></tr></table></figure>

<h2 id="1-9-Map集合练习"><a href="#1-9-Map集合练习" class="headerlink" title="1.9 Map集合练习"></a>1.9 Map集合练习</h2><p><strong>需求：</strong></p>
<p>计算一个字符串中每个字符出现次数。</p>
<p><strong>分析：</strong></p>
<ol>
<li> 获取一个字符串对象</li>
<li> 创建一个Map集合，键代表字符，值代表次数。</li>
<li> 遍历字符串得到每个字符。</li>
<li> 判断Map中是否有该键。</li>
<li> 如果没有，第一次出现，存储次数为1；如果有，则说明已经出现过，获取到对应的值进行++，再次存储。     </li>
<li> 打印最终结果</li>
</ol>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//友情提示</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请录入一个字符串:&quot;</span>);</span><br><span class="line">        String line = <span class="keyword">new</span> Scanner(System.in).nextLine();</span><br><span class="line">        <span class="comment">// 定义 每个字符出现次数的方法</span></span><br><span class="line">        findChar(line);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findChar</span><span class="params">(String line)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1:创建一个集合 存储  字符 以及其出现的次数</span></span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class="line">        <span class="comment">//2:遍历字符串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; line.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = line.charAt(i);</span><br><span class="line">            <span class="comment">//判断 该字符 是否在键集中</span></span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(c)) &#123;<span class="comment">//说明这个字符没有出现过</span></span><br><span class="line">                <span class="comment">//那就是第一次</span></span><br><span class="line">                map.put(c, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//先获取之前的次数</span></span><br><span class="line">                Integer count = map.get(c);</span><br><span class="line">                <span class="comment">//count++;</span></span><br><span class="line">                <span class="comment">//再次存入  更新</span></span><br><span class="line">                map.put(c, ++count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第二章-补充知识点"><a href="#第二章-补充知识点" class="headerlink" title="第二章 补充知识点"></a>第二章 补充知识点</h1><h2 id="2-1-JDK9对集合添加的优化"><a href="#2-1-JDK9对集合添加的优化" class="headerlink" title="2.1  JDK9对集合添加的优化"></a>2.1  JDK9对集合添加的优化</h2><p>通常，我们在代码中创建一个集合（例如，List 或 Set ），并直接用一些元素填充它。 实例化集合，几个 add方法 调用，使得代码重复。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;def&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;ghi&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> Java 9，添加了几种集合工厂方法,更方便创建少量元素的集合、map实例。新的List、Set、Map的静态工厂方法可以更方便地创建集合的不可变实例。</p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloJDK9</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        Set&lt;String&gt; str1=Set.of(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>);  </span><br><span class="line">        <span class="comment">//str1.add(&quot;c&quot;);这里编译的时候不会错，但是执行的时候会报错，因为是不可变的集合  </span></span><br><span class="line">        System.out.println(str1);  </span><br><span class="line">        Map&lt;String,Integer&gt; str2=Map.of(<span class="string">&quot;a&quot;</span>,<span class="number">1</span>,<span class="string">&quot;b&quot;</span>,<span class="number">2</span>);  </span><br><span class="line">        System.out.println(str2);  </span><br><span class="line">        List&lt;String&gt; str3=List.of(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>);  </span><br><span class="line">        System.out.println(str3);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>需要注意以下两点：</p>
<blockquote>
<p>1:of()方法只是Map，List，Set这三个接口的静态方法，其父类接口和子类实现并没有这类方法，比如    HashSet，ArrayList等待；</p>
<p>2:返回的集合是不可变的；</p>
</blockquote>
<h2 id="2-2-Debug追踪"><a href="#2-2-Debug追踪" class="headerlink" title="2.2 Debug追踪"></a>2.2 Debug追踪</h2><p><strong>使用IDEA的断点调试功能，查看程序的运行过程</strong></p>
<ol>
<li><p>在有效代码行，点击行号右边的空白区域，设置断点，程序执行到断点将停止，我们可以手动来运行程序     </p>
<p>   <img src="/img/debug1.png"></p>
</li>
<li><p>点击Debug运行模式       <img src="/img%5Cdebug2.png">                                                                                                                                                                      </p>
</li>
<li><p>程序停止在断点上不再执行，而IDEA最下方打开了Debug调试窗口  </p>
<p>  <img src="/img%5Cdebug3.png"><img src="/img%5Cdebug4.png"></p>
</li>
<li><p>Debug调试窗口介绍</p>
<p> <img src="/img%5Cdebug5.png"></p>
</li>
<li><p>快捷键F8，代码向下执行一行,第九行执行完毕，执行到第10行（第10行还未执行）</p>
<p><img src="/img%5Cdebug6.png"></p>
</li>
<li><p>切换到控制台面板，控制台显示 请录入一个字符串： 并且等待键盘录入</p>
<p><img src="/img%5Cdebug7.png"></p>
</li>
<li><p>快捷键F8，程序继续向后执行，执行键盘录入操作，在控制台录入数据 ababcea</p>
<p><img src="/img%5Cdebug8.png"></p>
<p>回车之后效果：<img src="/img%5Cdebug9.png"></p>
<p>调试界面效果：<img src="/img%5Cdebug0.png"></p>
</li>
<li><p>此时到达findChar方法，快捷键F7，进入方法findChar</p>
<p><img src="/img%5Cdebug11.png"></p>
</li>
<li><p>快捷键F8 接续执行，创建了map对象，变量区域显示</p>
<p><img src="/img%5Cdebug12.png"></p>
</li>
<li><p>快捷键F8 接续执行，进入到循环中，循环变量i为 0,F8再继续执行，就获取到变量c赋值为字符‘a’ 字节值97</p>
<p><img src="/img%5Cdebug13.png"></p>
</li>
<li><p>快捷键F8 接续执行，进入到判断语句中，因为该字符 不在Map集合键集中，再按F8执行，进入该判断中</p>
<p><img src="/img%5Cdebug14.png"></p>
</li>
<li><p>快捷键F8 接续执行，循环结束，进入下次循环，此时map中已经添加一对儿元素</p>
<p><img src="/img%5Cdebug15.png"></p>
</li>
<li><p>快捷键F8 接续执行，进入下次循环，再继续上面的操作，我们就可以看到代码每次是如何执行的了</p>
<p><img src="/img%5Cdebug16.png"></p>
</li>
<li><p>如果不想继续debug,那么可以使用快捷键F9,程序正常执行到结束，程序结果在控制台显示</p>
<p><img src="/img%5Cdebug17.png"></p>
</li>
</ol>
<h1 id="第三章-模拟斗地主洗牌发牌"><a href="#第三章-模拟斗地主洗牌发牌" class="headerlink" title="第三章  模拟斗地主洗牌发牌"></a>第三章  模拟斗地主洗牌发牌</h1><h2 id="3-1-案例介绍"><a href="#3-1-案例介绍" class="headerlink" title="3.1 案例介绍"></a>3.1 案例介绍</h2><p>按照斗地主的规则，完成洗牌发牌的动作。</p>
<p><img src="/img%5C%E6%96%97%E5%9C%B0%E4%B8%BB.png"></p>
<p>具体规则：</p>
<ol>
<li>组装54张扑克牌将</li>
<li>54张牌顺序打乱</li>
<li>三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。</li>
<li>查看三人各自手中的牌（按照牌的大小排序）、底牌</li>
</ol>
<blockquote>
<p>规则：手中扑克牌从大到小的摆放顺序：大王,小王,2,A,K,Q,J,10,9,8,7,6,5,4,3</p>
</blockquote>
<h2 id="3-2-案例需求分析"><a href="#3-2-案例需求分析" class="headerlink" title="3.2 案例需求分析"></a>3.2 案例需求分析</h2><ol>
<li> 准备牌：</li>
</ol>
<p>完成数字与纸牌的映射关系：</p>
<p>使用双列Map(HashMap)集合，完成一个数字与字符串纸牌的对应关系(相当于一个字典)。</p>
<ol start="2">
<li> 洗牌：</li>
</ol>
<p>通过数字完成洗牌发牌</p>
<ol start="3">
<li> 发牌：</li>
</ol>
<p>将每个人以及底牌设计为ArrayList<String>,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。</p>
<p>存放的过程中要求数字大小与斗地主规则的大小对应。</p>
<p>将代表不同纸牌的数字分配给不同的玩家与底牌。</p>
<ol start="4">
<li> 看牌：</li>
</ol>
<p>通过Map集合找到对应字符展示。</p>
<p>通过查询纸牌与数字的对应关系，由数字转成纸牌字符串再进行展示。</p>
<p><img src="/img%5C%E6%96%97%E5%9C%B0%E4%B8%BB%E5%88%86%E6%9E%90.png"></p>
<h2 id="3-3-实现代码步骤"><a href="#3-3-实现代码步骤" class="headerlink" title="3.3  实现代码步骤"></a>3.3  实现代码步骤</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Poker</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 1组装54张扑克牌</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 1.1 创建Map集合存储</span></span><br><span class="line">        HashMap&lt;Integer, String&gt; pokerMap = <span class="keyword">new</span> HashMap&lt;Integer, String&gt;();</span><br><span class="line">        <span class="comment">// 1.2 创建 花色集合 与 数字集合</span></span><br><span class="line">        ArrayList&lt;String&gt; colors = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; numbers = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.3 存储 花色 与数字</span></span><br><span class="line">        Collections.addAll(colors, <span class="string">&quot;♦&quot;</span>, <span class="string">&quot;♣&quot;</span>, <span class="string">&quot;♥&quot;</span>, <span class="string">&quot;♠&quot;</span>);</span><br><span class="line">        Collections.addAll(numbers, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;K&quot;</span>, <span class="string">&quot;Q&quot;</span>, <span class="string">&quot;J&quot;</span>, <span class="string">&quot;10&quot;</span>, <span class="string">&quot;9&quot;</span>, <span class="string">&quot;8&quot;</span>, <span class="string">&quot;7&quot;</span>, <span class="string">&quot;6&quot;</span>, <span class="string">&quot;5&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置 存储编号变量</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        pokerMap.put(count++, <span class="string">&quot;大王&quot;</span>);</span><br><span class="line">        pokerMap.put(count++, <span class="string">&quot;小王&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.4 创建牌 存储到map集合中</span></span><br><span class="line">        <span class="keyword">for</span> (String number : numbers) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String color : colors) &#123;</span><br><span class="line">                String card = color + number;</span><br><span class="line">                pokerMap.put(count++, card);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 2 将54张牌顺序打乱</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 取出编号 集合</span></span><br><span class="line">        Set&lt;Integer&gt; numberSet = pokerMap.keySet();</span><br><span class="line">        <span class="comment">// 因为要将编号打乱顺序 所以 应该先进行转换到 list集合中</span></span><br><span class="line">        ArrayList&lt;Integer&gt; numberList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        numberList.addAll(numberSet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打乱顺序</span></span><br><span class="line">        Collections.shuffle(numberList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 完成三个玩家交替摸牌，每人17张牌，最后三张留作底牌</span></span><br><span class="line">        <span class="comment">// 3.1 发牌的编号</span></span><br><span class="line">        <span class="comment">// 创建三个玩家编号集合 和一个 底牌编号集合</span></span><br><span class="line">        ArrayList&lt;Integer&gt; noP1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; noP2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; noP3 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; dipaiNo = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.2发牌的编号</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numberList.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// 获取该编号</span></span><br><span class="line">            Integer no = numberList.get(i);</span><br><span class="line">            <span class="comment">// 发牌</span></span><br><span class="line">            <span class="comment">// 留出底牌</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">51</span>) &#123;</span><br><span class="line">                dipaiNo.add(no);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    noP1.add(no);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                    noP2.add(no);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    noP3.add(no);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 查看三人各自手中的牌（按照牌的大小排序）、底牌</span></span><br><span class="line">        <span class="comment">// 4.1 对手中编号进行排序</span></span><br><span class="line">        Collections.sort(noP1);</span><br><span class="line">        Collections.sort(noP2);</span><br><span class="line">        Collections.sort(noP3);</span><br><span class="line">        Collections.sort(dipaiNo);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.2 进行牌面的转换</span></span><br><span class="line">        <span class="comment">// 创建三个玩家牌面集合 以及底牌牌面集合</span></span><br><span class="line">        ArrayList&lt;String&gt; player1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; player2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; player3 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; dipai = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.3转换</span></span><br><span class="line">        <span class="keyword">for</span> (Integer i : noP1) &#123;</span><br><span class="line">            <span class="comment">// 4.4 根据编号找到 牌面 pokerMap</span></span><br><span class="line">            String card = pokerMap.get(i);</span><br><span class="line">            <span class="comment">// 添加到对应的 牌面集合中</span></span><br><span class="line">            player1.add(card);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Integer i : noP2) &#123;</span><br><span class="line">            String card = pokerMap.get(i);</span><br><span class="line">            player2.add(card);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Integer i : noP3) &#123;</span><br><span class="line">            String card = pokerMap.get(i);</span><br><span class="line">            player3.add(card);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Integer i : dipaiNo) &#123;</span><br><span class="line">            String card = pokerMap.get(i);</span><br><span class="line">            dipai.add(card);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.5 查看</span></span><br><span class="line">        System.out.println(<span class="string">&quot;令狐冲：&quot;</span>+player1);</span><br><span class="line">        System.out.println(<span class="string">&quot;石破天：&quot;</span>+player2);</span><br><span class="line">        System.out.println(<span class="string">&quot;鸠摩智：&quot;</span>+player3);</span><br><span class="line">        System.out.println(<span class="string">&quot;底牌：&quot;</span>+dipai);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>字节流、字符流</title>
    <url>/2020/08/06/Java%20%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/%E5%AD%97%E8%8A%82%E6%B5%81%E3%80%81%E5%AD%97%E7%AC%A6%E6%B5%81/day09%E3%80%90%E5%AD%97%E8%8A%82%E6%B5%81%E3%80%81%E5%AD%97%E7%AC%A6%E6%B5%81%E3%80%91/</url>
    <content><![CDATA[<h1 id="day09【字节流、字符流】"><a href="#day09【字节流、字符流】" class="headerlink" title="day09【字节流、字符流】"></a>day09【字节流、字符流】</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li>IO流</li>
<li>字节流</li>
<li>字符流</li>
<li>异常处理</li>
<li>Properties</li>
</ul>
<h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><ul>
<li><input disabled="" type="checkbox"> 能够说出IO流的分类和功能</li>
<li><input disabled="" type="checkbox"> 能够使用字节输出流写出数据到文件</li>
<li><input disabled="" type="checkbox"> 能够使用字节输入流读取数据到程序</li>
<li><input disabled="" type="checkbox"> 能够理解读取数据read(byte[])方法的原理</li>
<li><input disabled="" type="checkbox"> 能够使用字节流完成文件的复制</li>
<li><input disabled="" type="checkbox"> 能够使用FileWirter写数据到文件</li>
<li><input disabled="" type="checkbox"> 能够说出FileWriter中关闭和刷新方法的区别</li>
<li><input disabled="" type="checkbox"> 能够使用FileWriter写数据的5个方法</li>
<li><input disabled="" type="checkbox"> 能够使用FileWriter写数据实现换行和追加写</li>
<li><input disabled="" type="checkbox"> 能够使用FileReader读数据</li>
<li><input disabled="" type="checkbox"> 能够使用FileReader读数据一次一个字符数组</li>
<li><input disabled="" type="checkbox"> 能够使用Properties的load方法加载文件中配置信息</li>
</ul>
<h1 id="第一章-IO概述"><a href="#第一章-IO概述" class="headerlink" title="第一章 IO概述"></a>第一章 IO概述</h1><h2 id="1-1-什么是IO"><a href="#1-1-什么是IO" class="headerlink" title="1.1 什么是IO"></a>1.1 什么是IO</h2><p>生活中，你肯定经历过这样的场景。当你编辑一个文本文件，忘记了<code>ctrl+s</code> ，可能文件就白白编辑了。当你电脑上插入一个U盘，可以把一个视频，拷贝到你的电脑硬盘里。那么数据都是在哪些设备上的呢？键盘、内存、硬盘、外接设备等等。</p>
<p>我们把这种数据的传输，可以看做是一种数据的流动，按照流动的方向，以内存为基准，分为<code>输入input</code> 和<code>输出output</code> ，即流向内存是输入流，流出内存的输出流。</p>
<p>Java中I/O操作主要是指使用<code>java.io</code>包下的内容，进行输入、输出操作。<strong>输入</strong>也叫做<strong>读取</strong>数据，<strong>输出</strong>也叫做作<strong>写出</strong>数据。</p>
<h2 id="1-2-IO的分类"><a href="#1-2-IO的分类" class="headerlink" title="1.2 IO的分类"></a>1.2 IO的分类</h2><p>根据数据的流向分为：<strong>输入流</strong>和<strong>输出流</strong>。</p>
<ul>
<li><strong>输入流</strong> ：把数据从<code>其他设备</code>上读取到<code>内存</code>中的流。 </li>
<li><strong>输出流</strong> ：把数据从<code>内存</code> 中写出到<code>其他设备</code>上的流。</li>
</ul>
<p>格局数据的类型分为：<strong>字节流</strong>和<strong>字符流</strong>。</p>
<ul>
<li><strong>字节流</strong> ：以字节为单位，读写数据的流。</li>
<li><strong>字符流</strong> ：以字符为单位，读写数据的流。</li>
</ul>
<h2 id="1-3-IO的流向说明图解"><a href="#1-3-IO的流向说明图解" class="headerlink" title="1.3 IO的流向说明图解"></a>1.3 IO的流向说明图解</h2><p><img src="/img/1_io.jpg"></p>
<h2 id="1-4-顶级父类们"><a href="#1-4-顶级父类们" class="headerlink" title="1.4 顶级父类们"></a>1.4 顶级父类们</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center"><strong>输入流</strong></th>
<th align="center">输出流</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>字节流</strong></td>
<td align="center">字节输入流<br /><strong>InputStream</strong></td>
<td align="center">字节输出流<br /><strong>OutputStream</strong></td>
</tr>
<tr>
<td align="center"><strong>字符流</strong></td>
<td align="center">字符输入流<br /><strong>Reader</strong></td>
<td align="center">字符输出流<br /><strong>Writer</strong></td>
</tr>
</tbody></table>
<h1 id="第二章-字节流"><a href="#第二章-字节流" class="headerlink" title="第二章 字节流"></a>第二章 字节流</h1><h2 id="2-1-一切皆为字节"><a href="#2-1-一切皆为字节" class="headerlink" title="2.1 一切皆为字节"></a>2.1 一切皆为字节</h2><p>一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。</p>
<h2 id="2-2-字节输出流【OutputStream】"><a href="#2-2-字节输出流【OutputStream】" class="headerlink" title="2.2 字节输出流【OutputStream】"></a>2.2 字节输出流【OutputStream】</h2><p><code>java.io.OutputStream </code>抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p>
<ul>
<li><code>public void close()</code> ：关闭此输出流并释放与此流相关联的任何系统资源。  </li>
<li><code>public void flush() </code> ：刷新此输出流并强制任何缓冲的输出字节被写出。  </li>
<li><code>public void write(byte[] b)</code>：将 b.length字节从指定的字节数组写入此输出流。  </li>
<li><code>public void write(byte[] b, int off, int len)</code> ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。  </li>
<li><code>public abstract void write(int b)</code> ：将指定的字节输出流。</li>
</ul>
<blockquote>
<p>小贴士：</p>
<p>close方法，当完成流的操作时，必须调用此方法，释放系统资源。</p>
</blockquote>
<h2 id="2-3-FileOutputStream类"><a href="#2-3-FileOutputStream类" class="headerlink" title="2.3 FileOutputStream类"></a>2.3 FileOutputStream类</h2><p><code>OutputStream</code>有很多子类，我们从最简单的一个子类开始。</p>
<p><code>java.io.FileOutputStream </code>类是文件输出流，用于将数据写出到文件。</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public FileOutputStream(File file)</code>：创建文件输出流以写入由指定的 File对象表示的文件。 </li>
<li><code>public FileOutputStream(String name)</code>： 创建文件输出流以指定的名称写入文件。  </li>
</ul>
<p>当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。</p>
<ul>
<li>构造举例，代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileOutputStreamConstructor</span> <span class="title">throws</span> <span class="title">IOException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   	 	<span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;b.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="写出字节数据"><a href="#写出字节数据" class="headerlink" title="写出字节数据"></a>写出字节数据</h3><ol>
<li><strong>写出字节</strong>：<code>write(int b)</code> 方法，每次可以写出一个字节数据，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FOSWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;fos.txt&quot;</span>);     </span><br><span class="line">      	<span class="comment">// 写出数据</span></span><br><span class="line">      	fos.write(<span class="number">97</span>); <span class="comment">// 写出第1个字节</span></span><br><span class="line">      	fos.write(<span class="number">98</span>); <span class="comment">// 写出第2个字节</span></span><br><span class="line">      	fos.write(<span class="number">99</span>); <span class="comment">// 写出第3个字节</span></span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">abc</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：</p>
<ol>
<li>虽然参数为int类型四个字节，但是只会保留一个字节的信息写出。</li>
<li>流操作完毕后，必须释放系统资源，调用close方法，千万记得。</li>
</ol>
</blockquote>
<ol start="2">
<li><strong>写出字节数组</strong>：<code>write(byte[] b)</code>，每次可以写出数组中的数据，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FOSWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;fos.txt&quot;</span>);     </span><br><span class="line">      	<span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">      	<span class="keyword">byte</span>[] b = <span class="string">&quot;黑马程序员&quot;</span>.getBytes();</span><br><span class="line">      	<span class="comment">// 写出字节数组数据</span></span><br><span class="line">      	fos.write(b);</span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">黑马程序员</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>写出指定长度字节数组</strong>：<code>write(byte[] b, int off, int len)</code> ,每次写出从off索引开始，len个字节，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FOSWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;fos.txt&quot;</span>);     </span><br><span class="line">      	<span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">      	<span class="keyword">byte</span>[] b = <span class="string">&quot;abcde&quot;</span>.getBytes();</span><br><span class="line">		<span class="comment">// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。</span></span><br><span class="line">        fos.write(b,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">cd</span><br></pre></td></tr></table></figure>

<h3 id="数据追加续写"><a href="#数据追加续写" class="headerlink" title="数据追加续写"></a>数据追加续写</h3><p>经过以上的演示，每次程序运行，创建输出流对象，都会清空目标文件中的数据。如何保留目标文件中数据，还能继续添加新数据呢？</p>
<ul>
<li><code>public FileOutputStream(File file, boolean append)</code>： 创建文件输出流以写入由指定的 File对象表示的文件。  </li>
<li><code>public FileOutputStream(String name, boolean append)</code>： 创建文件输出流以指定的名称写入文件。  </li>
</ul>
<p>这两个构造方法，参数中都需要传入一个boolean类型的值，<code>true</code> 表示追加数据，<code>false</code> 表示清空原有数据。这样创建的输出流对象，就可以指定是否追加续写了，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FOSWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;fos.txt&quot;</span>，<span class="keyword">true</span>);     </span><br><span class="line">      	<span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">      	<span class="keyword">byte</span>[] b = <span class="string">&quot;abcde&quot;</span>.getBytes();</span><br><span class="line">		<span class="comment">// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。</span></span><br><span class="line">        fos.write(b);</span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">文件操作前：cd</span><br><span class="line">文件操作后：cdabcde</span><br></pre></td></tr></table></figure>

<h3 id="写出换行"><a href="#写出换行" class="headerlink" title="写出换行"></a>写出换行</h3><p>Windows系统里，换行符号是<code>\r\n</code> 。把</p>
<p>以指定是否追加续写了，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FOSWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;fos.txt&quot;</span>);  </span><br><span class="line">      	<span class="comment">// 定义字节数组</span></span><br><span class="line">      	<span class="keyword">byte</span>[] words = &#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">100</span>,<span class="number">101</span>&#125;;</span><br><span class="line">      	<span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">          	<span class="comment">// 写出一个字节</span></span><br><span class="line">            fos.write(words[i]);</span><br><span class="line">          	<span class="comment">// 写出一个换行, 换行符号转成数组写出</span></span><br><span class="line">            fos.write(<span class="string">&quot;\r\n&quot;</span>.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>回车符<code>\r</code>和换行符<code>\n</code> ：<ul>
<li>回车符：回到一行的开头（return）。</li>
<li>换行符：下一行（newline）。</li>
</ul>
</li>
<li>系统中的换行：<ul>
<li>Windows系统里，每行结尾是 <code>回车+换行</code> ，即<code>\r\n</code>；</li>
<li>Unix系统里，每行结尾只有 <code>换行</code> ，即<code>\n</code>；</li>
<li>Mac系统里，每行结尾是 <code>回车</code> ，即<code>\r</code>。从 Mac OS X开始与Linux统一。</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="2-4-字节输入流【InputStream】"><a href="#2-4-字节输入流【InputStream】" class="headerlink" title="2.4 字节输入流【InputStream】"></a>2.4 字节输入流【InputStream】</h2><p><code>java.io.InputStream </code>抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。</p>
<ul>
<li><code>public void close()</code> ：关闭此输入流并释放与此流相关联的任何系统资源。    </li>
<li><code>public abstract int read()</code>： 从输入流读取数据的下一个字节。 </li>
<li><code>public int read(byte[] b)</code>： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。</li>
</ul>
<blockquote>
<p>小贴士：</p>
<p>close方法，当完成流的操作时，必须调用此方法，释放系统资源。</p>
</blockquote>
<h2 id="2-5-FileInputStream类"><a href="#2-5-FileInputStream类" class="headerlink" title="2.5 FileInputStream类"></a>2.5 FileInputStream类</h2><p><code>java.io.FileInputStream </code>类是文件输入流，从文件中读取字节。</p>
<h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>FileInputStream(File file)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 </li>
<li><code>FileInputStream(String name)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。  </li>
</ul>
<p>当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出<code>FileNotFoundException</code> 。</p>
<ul>
<li>构造举例，代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileInputStreamConstructor</span> <span class="title">throws</span> <span class="title">IOException</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   	 	<span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        FileInputStream fos = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileInputStream fos = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;b.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="读取字节数据"><a href="#读取字节数据" class="headerlink" title="读取字节数据"></a>读取字节数据</h3><ol>
<li><strong>读取字节</strong>：<code>read</code>方法，每次可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回<code>-1</code>，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FISRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">      	<span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">       	FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;read.txt&quot;</span>);</span><br><span class="line">      	<span class="comment">// 读取数据，返回一个字节</span></span><br><span class="line">        <span class="keyword">int</span> read = fis.read();</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">        read = fis.read();</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) read);</span><br><span class="line">      	<span class="comment">// 读取到末尾,返回-1</span></span><br><span class="line">       	read = fis.read();</span><br><span class="line">        System.out.println( read);</span><br><span class="line">		<span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br><span class="line">-<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>循环改进读取方式，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FISRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">      	<span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">       	FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;read.txt&quot;</span>);</span><br><span class="line">      	<span class="comment">// 定义变量，保存数据</span></span><br><span class="line">        <span class="keyword">int</span> b ；</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((b = fis.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>)b);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：</p>
<ol>
<li>虽然读取了一个字节，但是会自动提升为int类型。</li>
<li>流操作完毕后，必须释放系统资源，调用close方法，千万记得。</li>
</ol>
</blockquote>
<ol start="2">
<li><strong>使用字节数组读取</strong>：<code>read(byte[] b)</code>，每次读取b的长度个字节到数组中，返回读取到的有效字节个数，读取到末尾时，返回<code>-1</code> ，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FISRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">      	<span class="comment">// 使用文件名称创建流对象.</span></span><br><span class="line">       	FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;read.txt&quot;</span>); <span class="comment">// 文件中为abcde</span></span><br><span class="line">      	<span class="comment">// 定义变量，作为有效个数</span></span><br><span class="line">        <span class="keyword">int</span> len ；</span><br><span class="line">        <span class="comment">// 定义字节数组，作为装字节数据的容器   </span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> (( len= fis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">           	<span class="comment">// 每次读取后,把数组变成字符串打印</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(b));</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">ab</span><br><span class="line">cd</span><br><span class="line">ed</span><br></pre></td></tr></table></figure>

<p>错误数据<code>d</code>，是由于最后一次读取时，只读取一个字节<code>e</code>，数组中，上次读取的数据没有被完全替换，所以要通过<code>len</code> ，获取有效的字节，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FISRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">      	<span class="comment">// 使用文件名称创建流对象.</span></span><br><span class="line">       	FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;read.txt&quot;</span>); <span class="comment">// 文件中为abcde</span></span><br><span class="line">      	<span class="comment">// 定义变量，作为有效个数</span></span><br><span class="line">        <span class="keyword">int</span> len ；</span><br><span class="line">        <span class="comment">// 定义字节数组，作为装字节数据的容器   </span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> (( len= fis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">           	<span class="comment">// 每次读取后,把数组的有效字节部分，变成字符串打印</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(b，<span class="number">0</span>，len));<span class="comment">//  len 每次读取的有效字节个数</span></span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">ab</span><br><span class="line">cd</span><br><span class="line">e</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：</p>
<p>使用数组读取，每次读取多个字节，减少了系统间的IO操作次数，从而提高了读写的效率，建议开发中使用。</p>
</blockquote>
<h2 id="2-6-字节流练习：图片复制"><a href="#2-6-字节流练习：图片复制" class="headerlink" title="2.6 字节流练习：图片复制"></a>2.6 字节流练习：图片复制</h2><h3 id="复制原理图解"><a href="#复制原理图解" class="headerlink" title="复制原理图解"></a>复制原理图解</h3><p><img src="/img/2_copy.jpg"></p>
<h3 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h3><p>复制图片文件，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Copy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流对象</span></span><br><span class="line">        <span class="comment">// 1.1 指定数据源</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\test.jpg&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.2 指定目的地</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test_copy.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.读写数据</span></span><br><span class="line">        <span class="comment">// 2.1 定义数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">// 2.2 定义长度</span></span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="comment">// 2.3 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 2.4 写出数据</span></span><br><span class="line">            fos.write(b, <span class="number">0</span> , len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：</p>
<p>流的关闭原则：先开后关，后开先关。</p>
</blockquote>
<h1 id="第三章-字符流"><a href="#第三章-字符流" class="headerlink" title="第三章 字符流"></a>第三章 字符流</h1><p>当使用字节流读取文本文件时，可能会有一个小问题。就是遇到中文字符时，可能不会显示完整的字符，那是因为一个中文字符可能占用多个字节存储。所以Java提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。</p>
<h2 id="3-1-字符输入流【Reader】"><a href="#3-1-字符输入流【Reader】" class="headerlink" title="3.1 字符输入流【Reader】"></a>3.1 字符输入流【Reader】</h2><p><code>java.io.Reader</code>抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。</p>
<ul>
<li><code>public void close()</code> ：关闭此流并释放与此流相关联的任何系统资源。    </li>
<li><code>public int read()</code>： 从输入流读取一个字符。 </li>
<li><code>public int read(char[] cbuf)</code>： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。</li>
</ul>
<h2 id="3-2-FileReader类"><a href="#3-2-FileReader类" class="headerlink" title="3.2 FileReader类"></a>3.2 FileReader类</h2><p><code>java.io.FileReader </code>类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</p>
<blockquote>
<p>小贴士：</p>
<ol>
<li><p>字符编码：字节与字符的对应规则。Windows系统的中文编码默认是GBK编码表。</p>
<p>idea中UTF-8</p>
</li>
<li><p>字节缓冲区：一个字节数组，用来临时存储字节数据。</p>
</li>
</ol>
</blockquote>
<h3 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>FileReader(File file)</code>： 创建一个新的 FileReader ，给定要读取的File对象。   </li>
<li><code>FileReader(String fileName)</code>： 创建一个新的 FileReader ，给定要读取的文件的名称。  </li>
</ul>
<p>当你创建一个流对象时，必须传入一个文件路径。类似于FileInputStream 。</p>
<ul>
<li>构造举例，代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileReaderConstructor</span> <span class="title">throws</span> <span class="title">IOException</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   	 	<span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(file);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;b.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="读取字符数据"><a href="#读取字符数据" class="headerlink" title="读取字符数据"></a>读取字符数据</h3><ol>
<li><strong>读取字符</strong>：<code>read</code>方法，每次可以读取一个字符的数据，提升为int类型，读取到文件末尾，返回<code>-1</code>，循环读取，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FRRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      	<span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">       	FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;read.txt&quot;</span>);</span><br><span class="line">      	<span class="comment">// 定义变量，保存数据</span></span><br><span class="line">        <span class="keyword">int</span> b ；</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((b = fr.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>)b);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 关闭资源</span></span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">黑</span><br><span class="line">马</span><br><span class="line">程</span><br><span class="line">序</span><br><span class="line">员</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：虽然读取了一个字符，但是会自动提升为int类型。</p>
</blockquote>
<ol start="2">
<li><strong>使用字符数组读取</strong>：<code>read(char[] cbuf)</code>，每次读取b的长度个字符到数组中，返回读取到的有效字符个数，读取到末尾时，返回<code>-1</code> ，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FRRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      	<span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">       	FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;read.txt&quot;</span>);</span><br><span class="line">      	<span class="comment">// 定义变量，保存有效字符个数</span></span><br><span class="line">        <span class="keyword">int</span> len ；</span><br><span class="line">        <span class="comment">// 定义字符数组，作为装字符数据的容器</span></span><br><span class="line">         <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((len = fr.read(cbuf))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(cbuf));</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 关闭资源</span></span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">黑马</span><br><span class="line">程序</span><br><span class="line">员序</span><br></pre></td></tr></table></figure>

<p>获取有效的字符改进，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FISRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      	<span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">       	FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;read.txt&quot;</span>);</span><br><span class="line">      	<span class="comment">// 定义变量，保存有效字符个数</span></span><br><span class="line">        <span class="keyword">int</span> len ；</span><br><span class="line">        <span class="comment">// 定义字符数组，作为装字符数据的容器</span></span><br><span class="line">        <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((len = fr.read(cbuf))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(cbuf,<span class="number">0</span>,len));</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">// 关闭资源</span></span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">黑马</span><br><span class="line">程序</span><br><span class="line">员</span><br></pre></td></tr></table></figure>

<h2 id="3-3-字符输出流【Writer】"><a href="#3-3-字符输出流【Writer】" class="headerlink" title="3.3 字符输出流【Writer】"></a>3.3 字符输出流【Writer】</h2><p><code>java.io.Writer </code>抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p>
<ul>
<li><code>void write(int c)</code> 写入单个字符。</li>
<li><code>void write(char[] cbuf) </code>写入字符数组。 </li>
<li><code>abstract  void write(char[] cbuf, int off, int len) </code>写入字符数组的某一部分,off数组的开始索引,len写的字符个数。 </li>
<li><code>void write(String str) </code>写入字符串。 </li>
<li><code>void write(String str, int off, int len)</code> 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。</li>
<li><code>void flush() </code>刷新该流的缓冲。  </li>
<li><code>void close()</code> 关闭此流，但要先刷新它。 </li>
</ul>
<h2 id="3-4-FileWriter类"><a href="#3-4-FileWriter类" class="headerlink" title="3.4 FileWriter类"></a>3.4 FileWriter类</h2><p><code>java.io.FileWriter </code>类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</p>
<h3 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>FileWriter(File file)</code>： 创建一个新的 FileWriter，给定要读取的File对象。   </li>
<li><code>FileWriter(String fileName)</code>： 创建一个新的 FileWriter，给定要读取的文件的名称。  </li>
</ul>
<p>当你创建一个流对象时，必须传入一个文件路径，类似于FileOutputStream。</p>
<ul>
<li>构造举例，代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileWriterConstructor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   	 	<span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(file);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;b.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基本写出数据"><a href="#基本写出数据" class="headerlink" title="基本写出数据"></a>基本写出数据</h3><p><strong>写出字符</strong>：<code>write(int b)</code> 方法，每次可以写出一个字符数据，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FWWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;fw.txt&quot;</span>);     </span><br><span class="line">      	<span class="comment">// 写出数据</span></span><br><span class="line">      	fw.write(<span class="number">97</span>); <span class="comment">// 写出第1个字符</span></span><br><span class="line">      	fw.write(<span class="string">&#x27;b&#x27;</span>); <span class="comment">// 写出第2个字符</span></span><br><span class="line">      	fw.write(<span class="string">&#x27;C&#x27;</span>); <span class="comment">// 写出第3个字符</span></span><br><span class="line">      	fw.write(<span class="number">30000</span>); <span class="comment">// 写出第4个字符，中文编码表中30000对应一个汉字。</span></span><br><span class="line">      </span><br><span class="line">      	<span class="comment">/*</span></span><br><span class="line"><span class="comment">        【注意】关闭资源时,与FileOutputStream不同。</span></span><br><span class="line"><span class="comment">      	 如果不关闭,数据只是保存到缓冲区，并未保存到文件。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// fw.close();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">abC田</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：</p>
<ol>
<li>虽然参数为int类型四个字节，但是只会保留一个字符的信息写出。</li>
<li>未调用close方法，数据只是保存到了缓冲区，并未写出到文件中。</li>
</ol>
</blockquote>
<h3 id="关闭和刷新"><a href="#关闭和刷新" class="headerlink" title="关闭和刷新"></a>关闭和刷新</h3><p>因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要<code>flush</code> 方法了。</p>
<ul>
<li><code>flush</code> ：刷新缓冲区，流对象可以继续使用。</li>
<li><code>close </code>:先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。</li>
</ul>
<p>代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FWWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;fw.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 写出数据，通过flush</span></span><br><span class="line">        fw.write(<span class="string">&#x27;刷&#x27;</span>); <span class="comment">// 写出第1个字符</span></span><br><span class="line">        fw.flush();</span><br><span class="line">        fw.write(<span class="string">&#x27;新&#x27;</span>); <span class="comment">// 继续写出第2个字符，写出成功</span></span><br><span class="line">        fw.flush();</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 写出数据，通过close</span></span><br><span class="line">        fw.write(<span class="string">&#x27;关&#x27;</span>); <span class="comment">// 写出第1个字符</span></span><br><span class="line">        fw.close();</span><br><span class="line">        fw.write(<span class="string">&#x27;闭&#x27;</span>); <span class="comment">// 继续写出第2个字符,【报错】java.io.IOException: Stream closed</span></span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：即便是flush方法写出了数据，操作的最后还是要调用close方法，释放系统资源。</p>
</blockquote>
<h3 id="写出其他数据"><a href="#写出其他数据" class="headerlink" title="写出其他数据"></a>写出其他数据</h3><ol>
<li><strong>写出字符数组</strong> ：<code>write(char[] cbuf)</code> 和 <code>write(char[] cbuf, int off, int len)</code> ，每次可以写出字符数组中的数据，用法类似FileOutputStream，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FWWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;fw.txt&quot;</span>);     </span><br><span class="line">      	<span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">      	<span class="keyword">char</span>[] chars = <span class="string">&quot;黑马程序员&quot;</span>.toCharArray();</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 写出字符数组</span></span><br><span class="line">      	fw.write(chars); <span class="comment">// 黑马程序员</span></span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 写出从索引2开始，2个字节。索引2是&#x27;程&#x27;，两个字节，也就是&#x27;程序&#x27;。</span></span><br><span class="line">        fw.write(b,<span class="number">2</span>,<span class="number">2</span>); <span class="comment">// 程序</span></span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>写出字符串</strong>：<code>write(String str)</code> 和 <code>write(String str, int off, int len)</code> ，每次可以写出字符串中的数据，更为方便，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FWWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;fw.txt&quot;</span>);     </span><br><span class="line">      	<span class="comment">// 字符串</span></span><br><span class="line">      	String msg = <span class="string">&quot;黑马程序员&quot;</span>;</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 写出字符数组</span></span><br><span class="line">      	fw.write(msg); <span class="comment">//黑马程序员</span></span><br><span class="line">      </span><br><span class="line">		<span class="comment">// 写出从索引2开始，2个字节。索引2是&#x27;程&#x27;，两个字节，也就是&#x27;程序&#x27;。</span></span><br><span class="line">        fw.write(msg,<span class="number">2</span>,<span class="number">2</span>);	<span class="comment">// 程序</span></span><br><span class="line">      	</span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>续写和换行</strong>：操作类似于FileOutputStream。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FWWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象，可以续写数据</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;fw.txt&quot;</span>，<span class="keyword">true</span>);     </span><br><span class="line">      	<span class="comment">// 写出字符串</span></span><br><span class="line">        fw.write(<span class="string">&quot;黑马&quot;</span>);</span><br><span class="line">      	<span class="comment">// 写出换行</span></span><br><span class="line">      	fw.write(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">      	<span class="comment">// 写出字符串</span></span><br><span class="line">  		fw.write(<span class="string">&quot;程序员&quot;</span>);</span><br><span class="line">      	<span class="comment">// 关闭资源</span></span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果:</span><br><span class="line">黑马</span><br><span class="line">程序员</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：字符流，只能操作文本文件，不能操作图片，视频等非文本文件。</p>
<p>当我们单纯读或者写文本文件时  使用字符流 其他情况使用字节流</p>
</blockquote>
<h1 id="第四章-IO异常的处理"><a href="#第四章-IO异常的处理" class="headerlink" title="第四章 IO异常的处理"></a>第四章 IO异常的处理</h1><h3 id="JDK7前处理"><a href="#JDK7前处理" class="headerlink" title="JDK7前处理"></a>JDK7前处理</h3><p>之前的入门练习，我们一直把异常抛出，而实际开发中并不能这样处理，建议使用<code>try...catch...finally</code> 代码块，处理异常部分，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandleException1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      	<span class="comment">// 声明变量</span></span><br><span class="line">        FileWriter fw = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建流对象</span></span><br><span class="line">            fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;fw.txt&quot;</span>);</span><br><span class="line">            <span class="comment">// 写出数据</span></span><br><span class="line">            fw.write(<span class="string">&quot;黑马程序员&quot;</span>); <span class="comment">//黑马程序员</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fw != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fw.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JDK7的处理-扩展知识点了解内容"><a href="#JDK7的处理-扩展知识点了解内容" class="headerlink" title="JDK7的处理(扩展知识点了解内容)"></a>JDK7的处理(扩展知识点了解内容)</h3><p>还可以使用JDK7优化后的<code>try-with-resource</code> 语句，该语句确保了每个资源在语句结束时关闭。所谓的资源（resource）是指在程序完成后，必须关闭的对象。</p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (创建流对象语句，如果多个,使用<span class="string">&#x27;;&#x27;</span>隔开) &#123;</span><br><span class="line">	<span class="comment">// 读写数据</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandleException2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      	<span class="comment">// 创建流对象</span></span><br><span class="line">        <span class="keyword">try</span> ( FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;fw.txt&quot;</span>); ) &#123;</span><br><span class="line">            <span class="comment">// 写出数据</span></span><br><span class="line">            fw.write(<span class="string">&quot;黑马程序员&quot;</span>); <span class="comment">//黑马程序员</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JDK9的改进-扩展知识点了解内容"><a href="#JDK9的改进-扩展知识点了解内容" class="headerlink" title="JDK9的改进(扩展知识点了解内容)"></a>JDK9的改进(扩展知识点了解内容)</h3><p>JDK9中<code>try-with-resource</code> 的改进，对于<strong>引入对象</strong>的方式，支持的更加简洁。被引入的对象，同样可以自动关闭，无需手动close，我们来了解一下格式。</p>
<p>改进前格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 被final修饰的对象</span></span><br><span class="line"><span class="keyword">final</span> Resource resource1 = <span class="keyword">new</span> Resource(<span class="string">&quot;resource1&quot;</span>);</span><br><span class="line"><span class="comment">// 普通对象</span></span><br><span class="line">Resource resource2 = <span class="keyword">new</span> Resource(<span class="string">&quot;resource2&quot;</span>);</span><br><span class="line"><span class="comment">// 引入方式：创建新的变量保存</span></span><br><span class="line"><span class="keyword">try</span> (Resource r1 = resource1;</span><br><span class="line">     Resource r2 = resource2) &#123;</span><br><span class="line">     <span class="comment">// 使用对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改进后格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 被final修饰的对象</span></span><br><span class="line"><span class="keyword">final</span> Resource resource1 = <span class="keyword">new</span> Resource(<span class="string">&quot;resource1&quot;</span>);</span><br><span class="line"><span class="comment">// 普通对象</span></span><br><span class="line">Resource resource2 = <span class="keyword">new</span> Resource(<span class="string">&quot;resource2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入方式：直接引入</span></span><br><span class="line"><span class="keyword">try</span> (resource1; resource2) &#123;</span><br><span class="line">     <span class="comment">// 使用对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改进后，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TryDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       	<span class="comment">// 创建流对象</span></span><br><span class="line">        <span class="keyword">final</span>  FileReader fr  = <span class="keyword">new</span> FileReader(<span class="string">&quot;in.txt&quot;</span>);</span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;out.txt&quot;</span>);</span><br><span class="line">       	<span class="comment">// 引入到try中</span></span><br><span class="line">        <span class="keyword">try</span> (fr; fw) &#123;</span><br><span class="line">          	<span class="comment">// 定义变量</span></span><br><span class="line">            <span class="keyword">int</span> b;</span><br><span class="line">          	<span class="comment">// 读取数据</span></span><br><span class="line">          	<span class="keyword">while</span> ((b = fr.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">            	<span class="comment">// 写出数据</span></span><br><span class="line">            	fw.write(b);</span><br><span class="line">          	&#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第五章-属性集"><a href="#第五章-属性集" class="headerlink" title="第五章 属性集"></a>第五章 属性集</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p><code>java.util.Properties </code> 继承于<code> Hashtable</code> ，来表示一个持久的属性集。它使用键值结构存储数据，每个键及其对应值都是一个字符串。该类也被许多Java类使用，比如获取系统属性时，<code>System.getProperties</code> 方法就是返回一个<code>Properties</code>对象。</p>
<h2 id="5-2-Properties类"><a href="#5-2-Properties类" class="headerlink" title="5.2 Properties类"></a>5.2 Properties类</h2><h3 id="构造方法-4"><a href="#构造方法-4" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public Properties()</code> :创建一个空的属性列表。</li>
</ul>
<h3 id="基本的存储方法"><a href="#基本的存储方法" class="headerlink" title="基本的存储方法"></a>基本的存储方法</h3><ul>
<li><code>public Object setProperty(String key, String value)</code> ： 保存一对属性。  </li>
<li><code>public String getProperty(String key) </code> ：使用此属性列表中指定的键搜索属性值。</li>
<li><code>public Set&lt;String&gt; stringPropertyNames() </code> ：所有键的名称的集合。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建属性集对象</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">// 添加键值对元素</span></span><br><span class="line">        properties.setProperty(<span class="string">&quot;filename&quot;</span>, <span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;length&quot;</span>, <span class="string">&quot;209385038&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;location&quot;</span>, <span class="string">&quot;D:\\a.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印属性集对象</span></span><br><span class="line">        System.out.println(properties);</span><br><span class="line">        <span class="comment">// 通过键,获取属性值</span></span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">&quot;filename&quot;</span>));</span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">&quot;length&quot;</span>));</span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">&quot;location&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历属性集,获取所有键的集合</span></span><br><span class="line">        Set&lt;String&gt; strings = properties.stringPropertyNames();</span><br><span class="line">        <span class="comment">// 打印键值对</span></span><br><span class="line">        <span class="keyword">for</span> (String key : strings ) &#123;</span><br><span class="line">          	System.out.println(key+<span class="string">&quot; -- &quot;</span>+properties.getProperty(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">&#123;filename=a.txt, length=<span class="number">209385038</span>, location=D:\a.txt&#125;</span><br><span class="line">a.txt</span><br><span class="line"><span class="number">209385038</span></span><br><span class="line">D:\a.txt</span><br><span class="line">filename -- a.txt</span><br><span class="line">length -- <span class="number">209385038</span></span><br><span class="line">location -- D:\a.txt</span><br></pre></td></tr></table></figure>

<h3 id="与流相关的方法"><a href="#与流相关的方法" class="headerlink" title="与流相关的方法"></a>与流相关的方法</h3><ul>
<li><code>public void load(InputStream inStream)</code>： 从字节输入流中读取键值对。 </li>
</ul>
<p>参数中使用了字节输入流，通过流对象，可以关联到某文件上，这样就能够加载文本中的数据了。文本数据格式:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">filename=a.txt</span><br><span class="line">length=209385038</span><br><span class="line">location=D:\a.txt</span><br></pre></td></tr></table></figure>

<p>加载代码演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建属性集对象</span></span><br><span class="line">        Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">// 加载文本中信息到属性集</span></span><br><span class="line">        pro.load(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;read.txt&quot;</span>));</span><br><span class="line">        <span class="comment">// 遍历集合并打印</span></span><br><span class="line">        Set&lt;String&gt; strings = pro.stringPropertyNames();</span><br><span class="line">        <span class="keyword">for</span> (String key : strings ) &#123;</span><br><span class="line">          	System.out.println(key+<span class="string">&quot; -- &quot;</span>+pro.getProperty(key));</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">filename -- a.txt</span><br><span class="line">length -- <span class="number">209385038</span></span><br><span class="line">location -- D:\a.txt</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：文本中的数据，必须是键值对形式，可以使用空格、等号、冒号等符号分隔。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java流</tag>
      </tags>
  </entry>
  <entry>
    <title>异常、线程</title>
    <url>/2020/08/06/Java%20%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B/day05%20%E3%80%90%E5%BC%82%E5%B8%B8%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%91/</url>
    <content><![CDATA[<h1 id="day05-【异常、线程】"><a href="#day05-【异常、线程】" class="headerlink" title="day05 【异常、线程】"></a>day05 【异常、线程】</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li>异常、线程</li>
</ul>
<h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><ul>
<li><input disabled="" type="checkbox"> 能够辨别程序中异常和错误的区别</li>
<li><input disabled="" type="checkbox"> 说出异常的分类</li>
<li><input disabled="" type="checkbox"> 说出虚拟机处理异常的方式</li>
<li><input disabled="" type="checkbox"> 列举出常见的三个运行期异常</li>
<li><input disabled="" type="checkbox"> 能够使用try…catch关键字处理异常</li>
<li><input disabled="" type="checkbox"> 能够使用throws关键字处理异常</li>
<li><input disabled="" type="checkbox"> 能够自定义异常类</li>
<li><input disabled="" type="checkbox"> 能够处理自定义异常类</li>
<li><input disabled="" type="checkbox"> 说出进程的概念</li>
<li><input disabled="" type="checkbox"> 说出线程的概念</li>
<li><input disabled="" type="checkbox"> 能够理解并发与并行的区别</li>
<li><input disabled="" type="checkbox"> 能够开启新线程</li>
</ul>
<h1 id="第一章-异常"><a href="#第一章-异常" class="headerlink" title="第一章    异常"></a>第一章    异常</h1><h2 id="1-1-异常概念"><a href="#1-1-异常概念" class="headerlink" title="1.1 异常概念"></a>1.1 异常概念</h2><p>异常，就是不正常的意思。在生活中:医生说,你的身体某个部位有异常,该部位和正常相比有点不同,该部位的功能将受影响.在程序中的意思就是：</p>
<ul>
<li><strong>异常</strong> ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。</li>
</ul>
<p>在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。</p>
<blockquote>
<p>异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行.</p>
</blockquote>
<h2 id="1-2-异常体系"><a href="#1-2-异常体系" class="headerlink" title="1.2 异常体系"></a>1.2 异常体系</h2><p>异常机制其实是帮助我们<strong>找到</strong>程序中的问题，异常的根类是<code>java.lang.Throwable</code>，其下有两个子类：<code>java.lang.Error</code>与<code>java.lang.Exception</code>，平常所说的异常指<code>java.lang.Exception</code>。</p>
<p><img src="/img%5C%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB.png"></p>
<p><strong>Throwable体系：</strong></p>
<ul>
<li><strong>Error</strong>:严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。</li>
<li><strong>Exception</strong>:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒、阑尾炎。</li>
</ul>
<p><strong>Throwable中的常用方法：</strong></p>
<ul>
<li><p><code>public void printStackTrace()</code>:打印异常的详细信息。</p>
<p><em>包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。</em></p>
</li>
<li><p><code>public String getMessage()</code>:获取发生异常的原因。</p>
<p><em>提示给用户的时候,就提示错误原因。</em></p>
</li>
<li><p><code>public String toString()</code>:获取异常的类型和异常描述信息(不用)。</p>
</li>
</ul>
<p><em><strong>出现异常,不要紧张,把异常的简单类名,拷贝到API中去查。</strong></em></p>
<p><img src="/img%5C%E7%AE%80%E5%8D%95%E7%9A%84%E5%BC%82%E5%B8%B8%E6%9F%A5%E7%9C%8B.bmp"></p>
<h2 id="1-3-异常分类"><a href="#1-3-异常分类" class="headerlink" title="1.3 异常分类"></a>1.3 异常分类</h2><p>我们平常说的异常就是指Exception，因为这类异常一旦出现，我们就要对代码进行更正，修复程序。</p>
<p><strong>异常(Exception)的分类</strong>:根据在编译时期还是运行时期去检查异常?</p>
<ul>
<li><strong>编译时期异常</strong>:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常)</li>
<li><strong>运行时期异常</strong>:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常)</li>
</ul>
<p>​    <img src="/img%5C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%88%86%E7%B1%BB.png"></p>
<h2 id="1-4-异常的产生过程解析"><a href="#1-4-异常的产生过程解析" class="headerlink" title="1.4     异常的产生过程解析"></a>1.4     异常的产生过程解析</h2><p>先运行下面的程序，程序会产生一个数组索引越界异常ArrayIndexOfBoundsException。我们通过图解来解析下异常产生的过程。</p>
<p> 工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayTools</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对给定的数组通过给定的角标获取元素。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getElement</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> element = arr[index];</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123; <span class="number">34</span>, <span class="number">12</span>, <span class="number">67</span> &#125;;</span><br><span class="line">        intnum = ArrayTools.getElement(arr, <span class="number">4</span>)</span><br><span class="line">        System.out.println(<span class="string">&quot;num=&quot;</span> + num);</span><br><span class="line">        System.out.println(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序执行过程图解：</p>
<p> <img src="/img%5C%E5%BC%82%E5%B8%B8%E4%BA%A7%E7%94%9F%E8%BF%87%E7%A8%8B.png"></p>
<h1 id="第二章-异常的处理"><a href="#第二章-异常的处理" class="headerlink" title="第二章 异常的处理"></a>第二章 异常的处理</h1><p>Java异常处理的五个关键字：<strong>try、catch、finally、throw、throws</strong></p>
<h2 id="2-1-抛出异常throw"><a href="#2-1-抛出异常throw" class="headerlink" title="2.1     抛出异常throw"></a>2.1     抛出异常throw</h2><p>在编写程序时，我们必须要考虑程序出现问题的情况。比如，在定义方法时，方法需要接受参数。那么，当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者。</p>
<p>在java中，提供了一个<strong>throw</strong>关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢？</p>
<ol>
<li><p>创建一个异常对象。封装一些提示信息(信息可以自己编写)。</p>
</li>
<li><p>需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字throw就可以完成。throw 异常对象。</p>
<p>throw<strong>用在方法内</strong>，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。</p>
</li>
</ol>
<p><strong>使用格式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">throw new 异常类名(参数);</span><br></pre></td></tr></table></figure>

<p> 例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;要访问的arr数组不存在&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">&quot;该索引在数组中不存在，已超出范围&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>学习完抛出异常的格式后，我们通过下面程序演示下throw的使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个数组 </span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">52</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="comment">//根据索引找对应的元素 </span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span> element = getElement(arr, index);</span><br><span class="line"></span><br><span class="line">        System.out.println(element);</span><br><span class="line">        System.out.println(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 根据 索引找到数组中对应的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getElement</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> index)</span></span>&#123; </span><br><span class="line">       	<span class="comment">//判断  索引是否越界</span></span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">0</span> || index&gt;arr.length-<span class="number">1</span>)&#123;</span><br><span class="line">             <span class="comment">/*</span></span><br><span class="line"><span class="comment">             判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。</span></span><br><span class="line"><span class="comment">             这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。 </span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">&quot;哥们，角标越界了~~~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> element = arr[index];</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：如果产生了问题，我们就会throw将问题描述类即异常进行抛出，也就是将问题返回给该方法的调用者。</p>
<p>那么对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续讲问题声明出去，使用throws声明处理。</p>
</blockquote>
<h2 id="2-2-Objects非空判断"><a href="#2-2-Objects非空判断" class="headerlink" title="2.2 Objects非空判断"></a>2.2 Objects非空判断</h2><p>还记得我们学习过一个类Objects吗，曾经提到过它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），那么在它的源码中，对对象为null的值进行了抛出异常操作。</p>
<ul>
<li><code>public static &lt;T&gt; T requireNonNull(T obj)</code>:查看指定引用对象不是null。</li>
</ul>
<p>查看源码发现这里对为null的进行了抛出异常操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">requireNonNull</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="keyword">null</span>)</span><br><span class="line">      	<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-声明异常throws"><a href="#2-3-声明异常throws" class="headerlink" title="2.3  声明异常throws"></a>2.3  声明异常throws</h2><p><strong>声明异常</strong>：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。</p>
<p>关键字<strong>throws</strong>运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常).</p>
<p><strong>声明异常格式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…&#123;   &#125;	</span><br></pre></td></tr></table></figure>

<p>声明异常的代码演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowsDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        read(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(String path)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!path.equals(<span class="string">&quot;a.txt&quot;</span>)) &#123;<span class="comment">//如果不是 a.txt这个文件 </span></span><br><span class="line">            <span class="comment">// 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">&quot;文件不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>throws用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowsDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        read(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(String path)</span><span class="keyword">throws</span> FileNotFoundException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!path.equals(<span class="string">&quot;a.txt&quot;</span>)) &#123;<span class="comment">//如果不是 a.txt这个文件 </span></span><br><span class="line">            <span class="comment">// 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">&quot;文件不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!path.equals(<span class="string">&quot;b.txt&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-捕获异常try…catch"><a href="#2-4-捕获异常try…catch" class="headerlink" title="2.4  捕获异常try…catch"></a>2.4  捕获异常try…catch</h2><p>如果异常出现的话,会立刻终止程序,所以我们得处理异常:</p>
<ol>
<li>该方法不处理,而是声明抛出,由该方法的调用者来处理(throws)。</li>
<li>在方法中使用try-catch的语句块来处理异常。</li>
</ol>
<p><strong>try-catch</strong>的方式就是捕获异常。</p>
<ul>
<li><strong>捕获异常</strong>：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。</li>
</ul>
<p>捕获异常语法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">     编写可能会出现异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型  e)&#123;</span><br><span class="line">     处理异常的代码</span><br><span class="line">     <span class="comment">//记录日志/打印异常信息/继续抛出异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>try：</strong>该代码块中编写可能产生异常的代码。</p>
<p><strong>catch：</strong>用来进行某种异常的捕获，实现对捕获到的异常进行处理。</p>
<blockquote>
<p>注意:try和catch都不能单独使用,必须连用。</p>
</blockquote>
<p>演示如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TryCatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;<span class="comment">// 当产生异常时，必须有处理方式。要么捕获，要么声明。</span></span><br><span class="line">            read(<span class="string">&quot;b.txt&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;<span class="comment">// 括号中需要定义什么呢？</span></span><br><span class="line">          	<span class="comment">//try中抛出的是什么异常，在括号中就定义什么异常类型</span></span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 我们 当前的这个方法中 有异常  有编译期异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(String path)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!path.equals(<span class="string">&quot;a.txt&quot;</span>)) &#123;<span class="comment">//如果不是 a.txt这个文件 </span></span><br><span class="line">            <span class="comment">// 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">&quot;文件不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何获取异常信息：</p>
<p>Throwable类中定义了一些查看方法:</p>
<ul>
<li><code>public String getMessage()</code>:获取异常的描述信息,原因(提示给用户的时候,就提示错误原因。</li>
</ul>
<ul>
<li><code>public String toString()</code>:获取异常的类型和异常描述信息(不用)。</li>
<li><code>public void printStackTrace()</code>:打印异常的跟踪栈信息并输出到控制台。</li>
</ul>
<p>​            <em>包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。</em></p>
<h2 id="2-4-finally-代码块"><a href="#2-4-finally-代码块" class="headerlink" title="2.4 finally 代码块"></a>2.4 finally 代码块</h2><p><strong>finally</strong>：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。</p>
<p>什么时候的代码必须最终执行？</p>
<p>当我们在try语句块中打开了一些物理资源(磁盘文件/网络连接/数据库连接等),我们都得在使用完之后,最终关闭打开的资源。</p>
<p>finally的语法:</p>
<p> try…catch….finally:自身需要处理异常,最终还得关闭资源。</p>
<blockquote>
<p>注意:finally不能单独使用。</p>
</blockquote>
<p>比如在我们之后学习的IO流中，当打开了一个关联文件的资源，最后程序不管结果如何，都需要把这个资源关闭掉。</p>
<p>finally代码参考如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TryCatchDemo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            read(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">//抓取到的是编译期异常  抛出去的是运行期 </span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;不管程序怎样，这里都将会被执行。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 我们 当前的这个方法中 有异常  有编译期异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(String path)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!path.equals(<span class="string">&quot;a.txt&quot;</span>)) &#123;<span class="comment">//如果不是 a.txt这个文件 </span></span><br><span class="line">            <span class="comment">// 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">&quot;文件不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。</p>
</blockquote>
<p><img src="/img%5C%E6%AD%BB%E4%BA%86%E9%83%BD%E8%A6%81try.bmp"></p>
<h2 id="2-5-异常注意事项"><a href="#2-5-异常注意事项" class="headerlink" title="2.5   异常注意事项"></a>2.5   异常注意事项</h2><ul>
<li><p>多个异常使用捕获又该如何处理呢？</p>
<ol>
<li>多个异常分别处理。</li>
<li>多个异常一次捕获，多次处理。</li>
<li>多个异常一次捕获一次处理。</li>
</ol>
<p>一般我们是使用一次捕获多次处理方式，格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">     编写可能会出现异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型A  e)&#123;  当<span class="keyword">try</span>中出现A类型异常,就用该<span class="keyword">catch</span>来捕获.</span><br><span class="line">     处理异常的代码</span><br><span class="line">     <span class="comment">//记录日志/打印异常信息/继续抛出异常</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型B  e)&#123;  当<span class="keyword">try</span>中出现B类型异常,就用该<span class="keyword">catch</span>来捕获.</span><br><span class="line">     处理异常的代码</span><br><span class="line">     <span class="comment">//记录日志/打印异常信息/继续抛出异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。</p>
</blockquote>
</li>
<li><p>运行时异常被抛出可以不处理。即不捕获也不声明抛出。</p>
</li>
<li><p>如果finally有return语句,永远返回finally中的结果,避免该情况. </p>
</li>
<li><p>如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。</p>
</li>
<li><p>父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出</p>
</li>
</ul>
<h1 id="第三章-自定义异常"><a href="#第三章-自定义异常" class="headerlink" title="第三章 自定义异常"></a>第三章 自定义异常</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><p><strong>为什么需要自定义异常类:</strong></p>
<p>我们说了Java中不同的异常类,分别表示着某一种具体的异常情况,那么在开发中总是有些异常情况是SUN没有定义好的,此时我们根据自己业务的异常情况来定义异常类。例如年龄负数问题,考试成绩负数问题等等。</p>
<p>在上述代码中，发现这些异常都是JDK内部定义好的，但是实际开发中也会出现很多异常,这些异常很可能在JDK中没有定义过,例如年龄负数问题,考试成绩负数问题.那么能不能自己定义异常呢？</p>
<p><strong>什么是自定义异常类:</strong></p>
<p>在开发中根据自己业务的异常情况来定义异常类.</p>
<p>自定义一个业务逻辑异常: <strong>RegisterException</strong>。一个注册异常类。</p>
<p><strong>异常类如何定义:</strong></p>
<ol>
<li>自定义一个编译期异常: 自定义类 并继承于<code>java.lang.Exception</code>。</li>
<li>自定义一个运行时期的异常类:自定义类 并继承于<code>java.lang.RuntimeException</code>。</li>
</ol>
<h2 id="3-2-自定义异常的练习"><a href="#3-2-自定义异常的练习" class="headerlink" title="3.2 自定义异常的练习"></a>3.2 自定义异常的练习</h2><p>要求：我们模拟注册操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册。</p>
<p>首先定义一个登陆异常类RegisterException：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 业务逻辑异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegisterException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空参构造</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RegisterException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 表示异常提示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RegisterException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模拟登陆操作，使用数组模拟数据库中存储的数据，并提供当前注册账号是否存在方法用于判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟数据库中已存在账号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String[] names = &#123;<span class="string">&quot;bill&quot;</span>,<span class="string">&quot;hill&quot;</span>,<span class="string">&quot;jill&quot;</span>&#125;;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;     </span><br><span class="line">        <span class="comment">//调用方法</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">              <span class="comment">// 可能出现异常的代码</span></span><br><span class="line">            checkUsername(<span class="string">&quot;nill&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;注册成功&quot;</span>);<span class="comment">//如果没有异常就是注册成功</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(RegisterException e)&#123;</span><br><span class="line">            <span class="comment">//处理异常</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断当前注册账号是否存在</span></span><br><span class="line">    <span class="comment">//因为是编译期异常，又想调用者去处理 所以声明该异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkUsername</span><span class="params">(String uname)</span> <span class="keyword">throws</span> LoginException</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            <span class="keyword">if</span>(name.equals(uname))&#123;<span class="comment">//如果名字在这里面 就抛出登陆异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RegisterException(<span class="string">&quot;亲&quot;</span>+name+<span class="string">&quot;已经被注册了！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第四章-多线程"><a href="#第四章-多线程" class="headerlink" title="第四章 多线程"></a>第四章 多线程</h1><p>我们在之前，学习的程序在没有跳转语句的前提下，都是由上至下依次执行，那现在想要设计一个程序，边打游戏边听歌，怎么设计？</p>
<p>要解决上述问题,咱们得使用多进程或者多线程来解决.</p>
<h2 id="4-1-并发与并行"><a href="#4-1-并发与并行" class="headerlink" title="4.1 并发与并行"></a>4.1 并发与并行</h2><ul>
<li><strong>并发</strong>：指两个或多个事件在<strong>同一个时间段内</strong>发生。</li>
<li><strong>并行</strong>：指两个或多个事件在<strong>同一时刻</strong>发生（同时发生）。</li>
</ul>
<p><img src="/img%5C%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91.bmp"></p>
<p>在操作系统中，安装了多个程序，并发指的是在一段时间内宏观上有多个程序同时运行，这在单 CPU 系统中，每一时刻只能有一道程序执行，即微观上这些程序是分时的交替运行，只不过是给人的感觉是同时运行，那是因为分时交替运行的时间是非常短的。</p>
<p>而在多个 CPU 系统中，则这些可以并发执行的程序便可以分配到多个处理器上（CPU），实现多任务并行执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序便可以同时执行。目前电脑市场上说的多核 CPU，便是多核处理器，核 越多，并行处理的程序越多，能大大的提高电脑运行的效率。</p>
<blockquote>
<p>注意：单核处理器的计算机肯定是不能并行的处理多个任务的，只能是多个任务在单个CPU上并发运行。同理,线程也是一样的，从宏观角度上理解线程是并行运行的，但是从微观角度上分析却是串行运行的，即一个线程一个线程的去运行，当系统只有一个CPU时，线程会以某种顺序执行多个线程，我们把这种情况称之为线程调度。</p>
</blockquote>
<h2 id="4-2-线程与进程"><a href="#4-2-线程与进程" class="headerlink" title="4.2 线程与进程"></a>4.2 线程与进程</h2><ul>
<li><p><strong>进程</strong>：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。</p>
</li>
<li><p><strong>线程</strong>：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 </p>
<p>简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程 </p>
</li>
</ul>
<p>我们可以再电脑底部任务栏，右键—–&gt;打开任务管理器,可以查看当前任务的进程：</p>
<p><strong>进程</strong></p>
<p><img src="/img%5C%E8%BF%9B%E7%A8%8B%E6%A6%82%E5%BF%B5.png"></p>
<p><strong>线程</strong></p>
<p><img src="/img%5C%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5.png"></p>
<p><strong>线程调度:</strong></p>
<ul>
<li><p>分时调度</p>
<p>所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。</p>
</li>
<li><p>抢占式调度</p>
<p>优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。</p>
<ul>
<li>设置线程的优先级</li>
</ul>
<p><img src="/img/%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7.bmp" alt="设置线程优先级"></p>
<ul>
<li> 抢占式调度详解</li>
</ul>
<p>  大部分操作系统都支持多进程并发运行，现在的操作系统几乎都支持同时运行多个程序。比如：现在我们上课一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos窗口等软件。此时，这些程序是在同时运行，”感觉这些软件好像在同一时刻运行着“。</p>
<p>  实际上，CPU(中央处理器)使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的一个核而言，某个时刻，只能执行一个线程，而 CPU的在多个线程间切换速度相对我们的感觉要快，看上去就是在同一时刻运行。<br>  其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的使用率更高。</p>
<p>  <img src="/img/%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6.bmp" alt="抢占式调度"></p>
</li>
</ul>
<h2 id="4-3-创建线程类"><a href="#4-3-创建线程类" class="headerlink" title="4.3 创建线程类"></a>4.3 创建线程类</h2><p>Java使用<code>java.lang.Thread</code>类代表<strong>线程</strong>，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。Java中通过继承Thread类来<strong>创建</strong>并<strong>启动多线程</strong>的步骤如下：</p>
<ol>
<li>定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。</li>
<li>创建Thread子类的实例，即创建了线程对象</li>
<li>调用线程对象的start()方法来启动该线程</li>
</ol>
<p>代码如下：</p>
<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建自定义线程对象</span></span><br><span class="line">		MyThread mt = <span class="keyword">new</span> MyThread(<span class="string">&quot;新的线程！&quot;</span>);</span><br><span class="line">		<span class="comment">//开启新线程</span></span><br><span class="line">		mt.start();</span><br><span class="line">		<span class="comment">//在主方法中执行for循环</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;main线程！&quot;</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义线程类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="comment">//定义指定线程名称的构造方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//调用父类的String参数的构造方法，指定线程的名称</span></span><br><span class="line">		<span class="keyword">super</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 重写run方法，完成该线程执行的逻辑</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			System.out.println(getName()+<span class="string">&quot;：正在执行！&quot;</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>异常、线程</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池、Lambda表达式</title>
    <url>/2020/08/06/Java%20%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/%E7%AD%89%E5%BE%85%E4%B8%8E%E5%94%A4%E9%86%92%E6%A1%88%E4%BE%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E3%80%81Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/day07%E3%80%90%E7%AD%89%E5%BE%85%E4%B8%8E%E5%94%A4%E9%86%92%E6%A1%88%E4%BE%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E3%80%81Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E3%80%91/</url>
    <content><![CDATA[<h1 id="day07【线程池、Lambda表达式】"><a href="#day07【线程池、Lambda表达式】" class="headerlink" title="day07【线程池、Lambda表达式】"></a>day07【线程池、Lambda表达式】</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li>  等待与唤醒案例</li>
<li>  线程池</li>
<li>  Lambda表达式</li>
</ul>
<h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><p>-[ ] 能够理解线程通信概念<br>-[ ] 能够理解等待唤醒机制<br>-[ ] 能够描述Java中线程池运行原理<br>-[ ] 能够理解函数式编程相对于面向对象的优点<br>-[ ] 能够掌握Lambda表达式的标准格式<br>-[ ] 能够使用Lambda标准格式使用Runnable与Comparator接口<br>-[ ] 能够掌握Lambda表达式的省略格式与规则<br>-[ ] 能够使用Lambda省略格式使用Runnable与Comparator接口<br>-[ ] 能够通过Lambda的标准格式使用自定义的接口（有且仅有一个抽象方法）<br>-[ ] 能够通过Lambda的省略格式使用自定义的接口（有且仅有一个抽象方法）<br>-[ ] 能够明确Lambda的两项使用前提</p>
<h1 id="第一章-等待唤醒机制"><a href="#第一章-等待唤醒机制" class="headerlink" title="第一章 等待唤醒机制"></a>第一章 等待唤醒机制</h1><h2 id="1-1-线程间通信"><a href="#1-1-线程间通信" class="headerlink" title="1.1 线程间通信"></a>1.1 线程间通信</h2><p><strong>概念：</strong>多个线程在处理同一个资源，但是处理的动作（线程的任务）却不相同。</p>
<p>比如：线程A用来生成包子的，线程B用来吃包子的，包子可以理解为同一资源，线程A与线程B处理的动作，一个是生产，一个是消费，那么线程A与线程B之间就存在线程通信问题。</p>
<p><img src="/img%5C%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1.bmp"></p>
<p><strong>为什么要处理线程间通信：</strong></p>
<p>多个线程并发执行时, 在默认情况下CPU是随机切换线程的，当我们需要多个线程来共同完成一件任务，并且我们希望他们有规律的执行, 那么多线程之间需要一些协调通信，以此来帮我们达到多线程共同操作一份数据。</p>
<p><strong>如何保证线程间通信有效利用资源：</strong></p>
<p>多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作。 就是多个线程在操作同一份数据时， 避免对同一共享变量的争夺。也就是我们需要通过一定的手段使各个线程能有效的利用资源。而这种手段即—— <strong>等待唤醒机制。</strong></p>
<h2 id="1-2-等待唤醒机制"><a href="#1-2-等待唤醒机制" class="headerlink" title="1.2 等待唤醒机制"></a>1.2 等待唤醒机制</h2><p><strong>什么是等待唤醒机制</strong></p>
<p>这是多个线程间的一种<strong>协作</strong>机制。谈到线程我们经常想到的是线程间的<strong>竞争（race）</strong>，比如去争夺锁，但这并不是故事的全部，线程间也会有协作机制。就好比在公司里你和你的同事们，你们可能存在在晋升时的竞争，但更多时候你们更多是一起合作以完成某些任务。</p>
<p>就是在一个线程进行了规定操作后，就进入等待状态（**wait()<strong>）， 等待其他线程执行完他们的指定代码过后 再将其唤醒（</strong>notify()**）;在有多个线程进行等待时， 如果需要，可以使用 notifyAll()来唤醒所有的等待线程。</p>
<p>wait/notify 就是线程间的一种协作机制。</p>
<p><strong>等待唤醒中的方法</strong></p>
<p>等待唤醒机制就是用于解决线程间通信的问题的，使用到的3个方法的含义如下：</p>
<ol>
<li>wait：线程不再活动，不再参与调度，进入 wait set 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态即是 WAITING。它还要等着别的线程执行一个<strong>特别的动作</strong>，也即是“<strong>通知（notify）</strong>”在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（ready queue）中</li>
<li>notify：则选取所通知对象的 wait set 中的一个线程释放；例如，餐馆有空位置后，等候就餐最久的顾客最先入座。</li>
<li>notifyAll：则释放所通知对象的 wait set 上的全部线程。</li>
</ol>
<blockquote>
<p>注意：</p>
<p>哪怕只通知了一个等待的线程，被通知线程也不能立即恢复执行，因为它当初中断的地方是在同步块内，而此刻它已经不持有锁，所以她需要再次尝试去获取锁（很可能面临其它线程的竞争），成功后才能在当初调用 wait 方法之后的地方恢复执行。</p>
<p>总结如下：</p>
<ul>
<li>如果能获取锁，线程就从 WAITING 状态变成 RUNNABLE 状态；</li>
<li>否则，从 wait set 出来，又进入 entry set，线程就从 WAITING 状态又变成 BLOCKED 状态</li>
</ul>
</blockquote>
<p><strong>调用wait和notify方法需要注意的细节</strong></p>
<ol>
<li>wait方法与notify方法必须要由同一个锁对象调用。因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。</li>
<li>wait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。</li>
<li>wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这2个方法。</li>
</ol>
<h2 id="1-3-生产者与消费者问题"><a href="#1-3-生产者与消费者问题" class="headerlink" title="1.3 生产者与消费者问题"></a>1.3 生产者与消费者问题</h2><p>等待唤醒机制其实就是经典的“生产者与消费者”的问题。</p>
<p>就拿生产包子消费包子来说等待唤醒机制如何有效利用资源：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">包子铺线程生产包子，吃货线程消费包子。当包子没有时（包子状态为<span class="keyword">false</span>），吃货线程等待，包子铺线程生产包子（即包子状态为<span class="keyword">true</span>），并通知吃货线程（解除吃货的等待状态）,因为已经有包子了，那么包子铺线程进入等待状态。接下来，吃货线程能否进一步执行则取决于锁的获取情况。如果吃货获取到锁，那么就执行吃包子动作，包子吃完（包子状态为<span class="keyword">false</span>），并通知包子铺线程（解除包子铺的等待状态）,吃货线程进入等待。包子铺线程能否进一步执行则取决于锁的获取情况。</span><br></pre></td></tr></table></figure>

<p><strong>代码演示：</strong></p>
<p>包子资源类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaoZi</span> </span>&#123;</span><br><span class="line">     String  pier ;</span><br><span class="line">     String  xianer ;</span><br><span class="line">     <span class="keyword">boolean</span>  flag = <span class="keyword">false</span> ;<span class="comment">//包子资源 是否存在  包子资源状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>吃货线程类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChiHuo</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BaoZi bz;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChiHuo</span><span class="params">(String name,BaoZi bz)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.bz = bz;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (bz)&#123;</span><br><span class="line">                <span class="keyword">if</span>(bz.flag == <span class="keyword">false</span>)&#123;<span class="comment">//没包子</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        bz.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;吃货正在吃&quot;</span>+bz.pier+bz.xianer+<span class="string">&quot;包子&quot;</span>);</span><br><span class="line">                bz.flag = <span class="keyword">false</span>;</span><br><span class="line">                bz.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>包子铺线程类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaoZiPu</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BaoZi bz;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaoZiPu</span><span class="params">(String name,BaoZi bz)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.bz = bz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//造包子</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//同步</span></span><br><span class="line">            <span class="keyword">synchronized</span> (bz)&#123;</span><br><span class="line">                <span class="keyword">if</span>(bz.flag == <span class="keyword">true</span>)&#123;<span class="comment">//包子资源  存在</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                        bz.wait();</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 没有包子  造包子</span></span><br><span class="line">                System.out.println(<span class="string">&quot;包子铺开始做包子&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(count%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">// 冰皮  五仁</span></span><br><span class="line">                    bz.pier = <span class="string">&quot;冰皮&quot;</span>;</span><br><span class="line">                    bz.xianer = <span class="string">&quot;五仁&quot;</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 薄皮  牛肉大葱</span></span><br><span class="line">                    bz.pier = <span class="string">&quot;薄皮&quot;</span>;</span><br><span class="line">                    bz.xianer = <span class="string">&quot;牛肉大葱&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                count++;</span><br><span class="line"></span><br><span class="line">                bz.flag=<span class="keyword">true</span>;</span><br><span class="line">                System.out.println(<span class="string">&quot;包子造好了：&quot;</span>+bz.pier+bz.xianer);</span><br><span class="line">                System.out.println(<span class="string">&quot;吃货来吃吧&quot;</span>);</span><br><span class="line">                <span class="comment">//唤醒等待线程 （吃货）</span></span><br><span class="line">                bz.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//等待唤醒案例</span></span><br><span class="line">        BaoZi bz = <span class="keyword">new</span> BaoZi();</span><br><span class="line"></span><br><span class="line">        ChiHuo ch = <span class="keyword">new</span> ChiHuo(<span class="string">&quot;吃货&quot;</span>,bz);</span><br><span class="line">        BaoZiPu bzp = <span class="keyword">new</span> BaoZiPu(<span class="string">&quot;包子铺&quot;</span>,bz);</span><br><span class="line"></span><br><span class="line">        ch.start();</span><br><span class="line">        bzp.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">包子铺开始做包子</span><br><span class="line">包子造好了：冰皮五仁</span><br><span class="line">吃货来吃吧</span><br><span class="line">吃货正在吃冰皮五仁包子</span><br><span class="line">包子铺开始做包子</span><br><span class="line">包子造好了：薄皮牛肉大葱</span><br><span class="line">吃货来吃吧</span><br><span class="line">吃货正在吃薄皮牛肉大葱包子</span><br><span class="line">包子铺开始做包子</span><br><span class="line">包子造好了：冰皮五仁</span><br><span class="line">吃货来吃吧</span><br><span class="line">吃货正在吃冰皮五仁包子</span><br></pre></td></tr></table></figure>

<h1 id="第二章-线程池"><a href="#第二章-线程池" class="headerlink" title="第二章 线程池"></a>第二章 线程池</h1><h2 id="2-1-线程池思想概述"><a href="#2-1-线程池思想概述" class="headerlink" title="2.1 线程池思想概述"></a>2.1 线程池思想概述</h2><p><img src="/img%5C%E6%B8%B8%E6%B3%B3%E6%B1%A0.jpg"></p>
<p>我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题：</p>
<p>如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。</p>
<p>那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？</p>
<p>在Java中可以通过线程池来达到这样的效果。今天我们就来详细讲解一下Java的线程池。</p>
<h2 id="2-2-线程池概念"><a href="#2-2-线程池概念" class="headerlink" title="2.2 线程池概念"></a>2.2 线程池概念</h2><ul>
<li><strong>线程池：</strong>其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。</li>
</ul>
<p>由于线程池中有很多操作都是与优化资源相关的，我们在这里就不多赘述。我们通过一张图来了解线程池的工作原理：</p>
<p><img src="/img%5C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86.bmp"></p>
<p>合理利用线程池能够带来三个好处：</p>
<ol>
<li>降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。</li>
<li>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li>
<li>提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。</li>
</ol>
<h2 id="2-3-线程池的使用"><a href="#2-3-线程池的使用" class="headerlink" title="2.3 线程池的使用"></a>2.3 线程池的使用</h2><p>Java里面线程池的顶级接口是<code>java.util.concurrent.Executor</code>，但是严格意义上讲<code>Executor</code>并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是<code>java.util.concurrent.ExecutorService</code>。</p>
<p>要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在<code>java.util.concurrent.Executors</code>线程工厂类里面提供了一些静态工厂，生成一些常用的线程池。官方建议使用Executors工程类来创建线程池对象。</p>
<p>Executors类中有个创建线程池的方法如下：</p>
<ul>
<li><code>public static ExecutorService newFixedThreadPool(int nThreads)</code>：返回线程池对象。(创建的是有界线程池,也就是池中的线程个数可以指定最大数量)</li>
</ul>
<p>获取到了一个线程池ExecutorService 对象，那么怎么使用呢，在这里定义了一个使用线程池对象的方法如下：</p>
<ul>
<li><p><code>public Future&lt;?&gt; submit(Runnable task)</code>:获取线程池中的某一个线程对象，并执行</p>
<blockquote>
<p>Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用。</p>
</blockquote>
</li>
</ul>
<p>使用线程池中线程对象的步骤：</p>
<ol>
<li>创建线程池对象。</li>
<li>创建Runnable接口子类对象。(task)</li>
<li>提交Runnable接口子类对象。(take task)</li>
<li>关闭线程池(一般不做)。</li>
</ol>
<p>Runnable实现类代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我要一个教练&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;教练来了： &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;教我游泳,交完后，教练回到了游泳池&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程池测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建线程池对象</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">2</span>);<span class="comment">//包含2个线程对象</span></span><br><span class="line">        <span class="comment">// 创建Runnable实例对象</span></span><br><span class="line">        MyRunnable r = <span class="keyword">new</span> MyRunnable();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//自己创建线程对象的方式</span></span><br><span class="line">        <span class="comment">// Thread t = new Thread(r);</span></span><br><span class="line">        <span class="comment">// t.start(); ---&gt; 调用MyRunnable中的run()</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从线程池中获取线程对象,然后调用MyRunnable中的run()</span></span><br><span class="line">        service.submit(r);</span><br><span class="line">        <span class="comment">// 再获取个线程对象，调用MyRunnable中的run()</span></span><br><span class="line">        service.submit(r);</span><br><span class="line">        service.submit(r);</span><br><span class="line">        <span class="comment">// 注意：submit方法调用结束后，程序并不终止，是因为线程池控制了线程的关闭。</span></span><br><span class="line">        <span class="comment">// 将使用完的线程又归还到了线程池中</span></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        <span class="comment">//service.shutdown();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="第三章-Lambda表达式"><a href="#第三章-Lambda表达式" class="headerlink" title="第三章 Lambda表达式"></a>第三章 Lambda表达式</h1><h2 id="3-1-函数式编程思想概述"><a href="#3-1-函数式编程思想概述" class="headerlink" title="3.1 函数式编程思想概述"></a>3.1 函数式编程思想概述</h2><p><img src="/img/03-Overview.png"></p>
<p>在数学中，<strong>函数</strong>就是有输入量、输出量的一套计算方案，也就是“拿什么东西做什么事情”。相对而言，面向对象过分强调“必须通过对象的形式来做事情”，而函数式思想则尽量忽略面向对象的复杂语法——<strong>强调做什么，而不是以什么形式做</strong>。</p>
<p>面向对象的思想:</p>
<p>​    做一件事情,找一个能解决这个事情的对象,调用对象的方法,完成事情.</p>
<p>函数式编程思想:</p>
<p>​    只要能获取到结果,谁去做的,怎么做的都不重要,重视的是结果,不重视过程</p>
<h2 id="3-2-冗余的Runnable代码"><a href="#3-2-冗余的Runnable代码" class="headerlink" title="3.2 冗余的Runnable代码"></a>3.2 冗余的Runnable代码</h2><h3 id="传统写法"><a href="#传统写法" class="headerlink" title="传统写法"></a>传统写法</h3><p>当需要启动一个线程去完成任务时，通常会通过<code>java.lang.Runnable</code>接口来定义任务内容，并使用<code>java.lang.Thread</code>类来启动该线程。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Runnable</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 匿名内部类</span></span><br><span class="line">		Runnable task = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">// 覆盖重写抽象方法</span></span><br><span class="line">				System.out.println(<span class="string">&quot;多线程任务执行！&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">new</span> Thread(task).start(); <span class="comment">// 启动线程</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本着“一切皆对象”的思想，这种做法是无可厚非的：首先创建一个<code>Runnable</code>接口的匿名内部类对象来指定任务内容，再将其交给一个线程来启动。</p>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>对于<code>Runnable</code>的匿名内部类用法，可以分析出几点内容：</p>
<ul>
<li><code>Thread</code>类需要<code>Runnable</code>接口作为参数，其中的抽象<code>run</code>方法是用来指定线程任务内容的核心；</li>
<li>为了指定<code>run</code>的方法体，<strong>不得不</strong>需要<code>Runnable</code>接口的实现类；</li>
<li>为了省去定义一个<code>RunnableImpl</code>实现类的麻烦，<strong>不得不</strong>使用匿名内部类；</li>
<li>必须覆盖重写抽象<code>run</code>方法，所以方法名称、方法参数、方法返回值<strong>不得不</strong>再写一遍，且不能写错；</li>
<li>而实际上，<strong>似乎只有方法体才是关键所在</strong>。</li>
</ul>
<h2 id="3-3-编程思想转换"><a href="#3-3-编程思想转换" class="headerlink" title="3.3 编程思想转换"></a>3.3 编程思想转换</h2><h3 id="做什么，而不是怎么做"><a href="#做什么，而不是怎么做" class="headerlink" title="做什么，而不是怎么做"></a>做什么，而不是怎么做</h3><p>我们真的希望创建一个匿名内部类对象吗？不。我们只是为了做这件事情而<strong>不得不</strong>创建一个对象。我们真正希望做的事情是：将<code>run</code>方法体内的代码传递给<code>Thread</code>类知晓。</p>
<p><strong>传递一段代码</strong>——这才是我们真正的目的。而创建对象只是受限于面向对象语法而不得不采取的一种手段方式。那，有没有更加简单的办法？如果我们将关注点从“怎么做”回归到“做什么”的本质上，就会发现只要能够更好地达到目的，过程与形式其实并不重要。</p>
<h3 id="生活举例"><a href="#生活举例" class="headerlink" title="生活举例"></a>生活举例</h3><p><img src="/img/01-%E4%BA%A4%E9%80%9A%E6%96%B9%E5%BC%8F.png"></p>
<p>当我们需要从北京到上海时，可以选择高铁、汽车、骑行或是徒步。我们的真正目的是到达上海，而如何才能到达上海的形式并不重要，所以我们一直在探索有没有比高铁更好的方式——搭乘飞机。</p>
<p><img src="/img/02-Lambda.png"></p>
<p>而现在这种飞机（甚至是飞船）已经诞生：2014年3月Oracle所发布的Java 8（JDK 1.8）中，加入了<strong>Lambda表达式</strong>的重量级新特性，为我们打开了新世界的大门。</p>
<h2 id="3-4-体验Lambda的更优写法"><a href="#3-4-体验Lambda的更优写法" class="headerlink" title="3.4 体验Lambda的更优写法"></a>3.4 体验Lambda的更优写法</h2><p>借助Java 8的全新语法，上述<code>Runnable</code>接口的匿名内部类写法可以通过更简单的Lambda表达式达到等效：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02LambdaRunnable</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">&quot;多线程任务执行！&quot;</span>)).start(); <span class="comment">// 启动线程</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码和刚才的执行效果是完全一样的，可以在1.8或更高的编译级别下通过。从代码的语义中可以看出：我们启动了一个线程，而线程任务的内容以一种更加简洁的形式被指定。</p>
<p>不再有“不得不创建接口对象”的束缚，不再有“抽象方法覆盖重写”的负担，就是这么简单！</p>
<h2 id="3-5-回顾匿名内部类"><a href="#3-5-回顾匿名内部类" class="headerlink" title="3.5 回顾匿名内部类"></a>3.5 回顾匿名内部类</h2><p>Lambda是怎样击败面向对象的？在上例中，核心代码其实只是如下所示的内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">() -&gt; System.out.println(<span class="string">&quot;多线程任务执行！&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>为了理解Lambda的语义，我们需要从传统的代码起步。</p>
<h3 id="使用实现类"><a href="#使用实现类" class="headerlink" title="使用实现类"></a>使用实现类</h3><p>要启动一个线程，需要创建一个<code>Thread</code>类的对象并调用<code>start</code>方法。而为了指定线程执行的内容，需要调用<code>Thread</code>类的构造方法：</p>
<ul>
<li><code>public Thread(Runnable target)</code></li>
</ul>
<p>为了获取<code>Runnable</code>接口的实现对象，可以为该接口定义一个实现类<code>RunnableImpl</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;多线程任务执行！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后创建该实现类的对象作为<code>Thread</code>类的构造参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03ThreadInitParam</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Runnable task = <span class="keyword">new</span> RunnableImpl();</span><br><span class="line">		<span class="keyword">new</span> Thread(task).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用匿名内部类"><a href="#使用匿名内部类" class="headerlink" title="使用匿名内部类"></a>使用匿名内部类</h3><p>这个<code>RunnableImpl</code>类只是为了实现<code>Runnable</code>接口而存在的，而且仅被使用了唯一一次，所以使用匿名内部类的语法即可省去该类的单独定义，即匿名内部类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04ThreadNameless</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;多线程任务执行！&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匿名内部类的好处与弊端"><a href="#匿名内部类的好处与弊端" class="headerlink" title="匿名内部类的好处与弊端"></a>匿名内部类的好处与弊端</h3><p>一方面，匿名内部类可以帮我们<strong>省去实现类的定义</strong>；另一方面，匿名内部类的语法——<strong>确实太复杂了！</strong></p>
<h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><p>仔细分析该代码中的语义，<code>Runnable</code>接口只有一个<code>run</code>方法的定义：</p>
<ul>
<li><code>public abstract void run();</code></li>
</ul>
<p>即制定了一种做事情的方案（其实就是一个函数）：</p>
<ul>
<li><strong>无参数</strong>：不需要任何条件即可执行该方案。</li>
<li><strong>无返回值</strong>：该方案不产生任何结果。</li>
<li><strong>代码块</strong>（方法体）：该方案的具体执行步骤。</li>
</ul>
<p>同样的语义体现在<code>Lambda</code>语法中，要更加简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">() -&gt; System.out.println(<span class="string">&quot;多线程任务执行！&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>前面的一对小括号即<code>run</code>方法的参数（无），代表不需要任何条件；</li>
<li>中间的一个箭头代表将前面的参数传递给后面的代码；</li>
<li>后面的输出语句即业务逻辑代码。</li>
</ul>
<h2 id="3-6-Lambda标准格式"><a href="#3-6-Lambda标准格式" class="headerlink" title="3.6 Lambda标准格式"></a>3.6 Lambda标准格式</h2><p>Lambda省去面向对象的条条框框，格式由<strong>3个部分</strong>组成：</p>
<ul>
<li>一些参数</li>
<li>一个箭头</li>
<li>一段代码</li>
</ul>
<p>Lambda表达式的<strong>标准格式</strong>为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(参数类型 参数名称) -&gt; &#123; 代码语句 &#125;</span><br></pre></td></tr></table></figure>

<p>格式说明：</p>
<ul>
<li>小括号内的语法与传统方法参数列表一致：无参数则留空；多个参数则用逗号分隔。</li>
<li><code>-&gt;</code>是新引入的语法格式，代表指向动作。</li>
<li>大括号内的语法与传统方法体要求基本一致。</li>
</ul>
<h2 id="3-7-练习：使用Lambda标准格式（无参无返回）"><a href="#3-7-练习：使用Lambda标准格式（无参无返回）" class="headerlink" title="3.7 练习：使用Lambda标准格式（无参无返回）"></a>3.7 练习：使用Lambda标准格式（无参无返回）</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个厨子<code>Cook</code>接口，内含唯一的抽象方法<code>makeFood</code>，且无参数、无返回值。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cook</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">makeFood</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在下面的代码中，请使用Lambda的<strong>标准格式</strong>调用<code>invokeCook</code>方法，打印输出“吃饭啦！”字样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo05InvokeCook</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO 请在此使用Lambda【标准格式】调用invokeCook方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeCook</span><span class="params">(Cook cook)</span> </span>&#123;</span><br><span class="line">        cook.makeFood();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    invokeCook(() -&gt; &#123;</span><br><span class="line">      	System.out.println(<span class="string">&quot;吃饭啦！&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>备注：小括号代表<code>Cook</code>接口<code>makeFood</code>抽象方法的参数为空，大括号代表<code>makeFood</code>的方法体。</p>
</blockquote>
<h2 id="3-8-Lambda的参数和返回值"><a href="#3-8-Lambda的参数和返回值" class="headerlink" title="3.8 Lambda的参数和返回值"></a>3.8 Lambda的参数和返回值</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">需求:</span><br><span class="line">    使用数组存储多个Person对象</span><br><span class="line">    对数组中的Person对象使用Arrays的sort方法通过年龄进行升序排序</span><br></pre></td></tr></table></figure>

<p>下面举例演示<code>java.util.Comparator&lt;T&gt;</code>接口的使用场景代码，其中的抽象方法定义为：</p>
<ul>
<li><code>public abstract int compare(T o1, T o2);</code></li>
</ul>
<p>当需要对一个对象数组进行排序时，<code>Arrays.sort</code>方法需要一个<code>Comparator</code>接口实例来指定排序的规则。假设有一个<code>Person</code>类，含有<code>String name</code>和<code>int age</code>两个成员变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略构造器、toString方法与Getter Setter </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="传统写法-1"><a href="#传统写法-1" class="headerlink" title="传统写法"></a>传统写法</h3><p>如果使用传统的代码对<code>Person[]</code>数组进行排序，写法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo06Comparator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      	<span class="comment">// 本来年龄乱序的对象数组</span></span><br><span class="line">        Person[] array = &#123;</span><br><span class="line">        	<span class="keyword">new</span> Person(<span class="string">&quot;古力娜扎&quot;</span>, <span class="number">19</span>),</span><br><span class="line">        	<span class="keyword">new</span> Person(<span class="string">&quot;迪丽热巴&quot;</span>, <span class="number">18</span>),</span><br><span class="line">       		<span class="keyword">new</span> Person(<span class="string">&quot;马尔扎哈&quot;</span>, <span class="number">20</span>) &#125;;</span><br><span class="line"></span><br><span class="line">      	<span class="comment">// 匿名内部类</span></span><br><span class="line">        Comparator&lt;Person&gt; comp = <span class="keyword">new</span> Comparator&lt;Person&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person o1, Person o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getAge() - o2.getAge();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Arrays.sort(array, comp); <span class="comment">// 第二个参数为排序规则，即Comparator接口实例</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Person person : array) &#123;</span><br><span class="line">            System.out.println(person);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种做法在面向对象的思想中，似乎也是“理所当然”的。其中<code>Comparator</code>接口的实例（使用了匿名内部类）代表了“按照年龄从小到大”的排序规则。</p>
<h3 id="代码分析-1"><a href="#代码分析-1" class="headerlink" title="代码分析"></a>代码分析</h3><p>下面我们来搞清楚上述代码真正要做什么事情。</p>
<ul>
<li>为了排序，<code>Arrays.sort</code>方法需要排序规则，即<code>Comparator</code>接口的实例，抽象方法<code>compare</code>是关键；</li>
<li>为了指定<code>compare</code>的方法体，<strong>不得不</strong>需要<code>Comparator</code>接口的实现类；</li>
<li>为了省去定义一个<code>ComparatorImpl</code>实现类的麻烦，<strong>不得不</strong>使用匿名内部类；</li>
<li>必须覆盖重写抽象<code>compare</code>方法，所以方法名称、方法参数、方法返回值<strong>不得不</strong>再写一遍，且不能写错；</li>
<li>实际上，<strong>只有参数和方法体才是关键</strong>。</li>
</ul>
<h3 id="Lambda写法"><a href="#Lambda写法" class="headerlink" title="Lambda写法"></a>Lambda写法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo07ComparatorLambda</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person[] array = &#123;</span><br><span class="line">          	<span class="keyword">new</span> Person(<span class="string">&quot;古力娜扎&quot;</span>, <span class="number">19</span>),</span><br><span class="line">          	<span class="keyword">new</span> Person(<span class="string">&quot;迪丽热巴&quot;</span>, <span class="number">18</span>),</span><br><span class="line">          	<span class="keyword">new</span> Person(<span class="string">&quot;马尔扎哈&quot;</span>, <span class="number">20</span>) &#125;;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(array, (Person a, Person b) -&gt; &#123;</span><br><span class="line">          	<span class="keyword">return</span> a.getAge() - b.getAge();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Person person : array) &#123;</span><br><span class="line">            System.out.println(person);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-9-练习：使用Lambda标准格式（有参有返回）"><a href="#3-9-练习：使用Lambda标准格式（有参有返回）" class="headerlink" title="3.9 练习：使用Lambda标准格式（有参有返回）"></a>3.9 练习：使用Lambda标准格式（有参有返回）</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给定一个计算器<code>Calculator</code>接口，内含抽象方法<code>calc</code>可以将两个int数字相加得到和值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在下面的代码中，请使用Lambda的<strong>标准格式</strong>调用<code>invokeCalc</code>方法，完成120和130的相加计算：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo08InvokeCalc</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO 请在此使用Lambda【标准格式】调用invokeCalc方法来计算120+130的结果ß</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeCalc</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, Calculator calculator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = calculator.calc(a, b);</span><br><span class="line">        System.out.println(<span class="string">&quot;结果是：&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    invokeCalc(<span class="number">120</span>, <span class="number">130</span>, (<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; &#123;</span><br><span class="line">      	<span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>备注：小括号代表<code>Calculator</code>接口<code>calc</code>抽象方法的参数，大括号代表<code>calc</code>的方法体。</p>
</blockquote>
<h2 id="3-10-Lambda省略格式"><a href="#3-10-Lambda省略格式" class="headerlink" title="3.10 Lambda省略格式"></a>3.10 Lambda省略格式</h2><h3 id="可推导即可省略"><a href="#可推导即可省略" class="headerlink" title="可推导即可省略"></a>可推导即可省略</h3><p>Lambda强调的是“做什么”而不是“怎么做”，所以凡是可以根据上下文推导得知的信息，都可以省略。例如上例还可以使用Lambda的省略写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  	invokeCalc(<span class="number">120</span>, <span class="number">130</span>, (a, b) -&gt; a + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="省略规则"><a href="#省略规则" class="headerlink" title="省略规则"></a>省略规则</h3><p>在Lambda标准格式的基础上，使用省略写法的规则为：</p>
<ol>
<li>小括号内参数的类型可以省略；</li>
<li>如果小括号内<strong>有且仅有一个参</strong>，则小括号可以省略；</li>
<li>如果大括号内<strong>有且仅有一个语句</strong>，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。</li>
</ol>
<blockquote>
<p>备注：掌握这些省略规则后，请对应地回顾本章开头的多线程案例。</p>
</blockquote>
<h2 id="3-11-练习：使用Lambda省略格式"><a href="#3-11-练习：使用Lambda省略格式" class="headerlink" title="3.11 练习：使用Lambda省略格式"></a>3.11 练习：使用Lambda省略格式</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>仍然使用前文含有唯一<code>makeFood</code>抽象方法的厨子<code>Cook</code>接口，在下面的代码中，请使用Lambda的<strong>省略格式</strong>调用<code>invokeCook</code>方法，打印输出“吃饭啦！”字样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo09InvokeCook</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO 请在此使用Lambda【省略格式】调用invokeCook方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeCook</span><span class="params">(Cook cook)</span> </span>&#123;</span><br><span class="line">        cook.makeFood();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  	invokeCook(() -&gt; System.out.println(<span class="string">&quot;吃饭啦！&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-12-Lambda的使用前提"><a href="#3-12-Lambda的使用前提" class="headerlink" title="3.12 Lambda的使用前提"></a>3.12 Lambda的使用前提</h2><p>Lambda的语法非常简洁，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意：</p>
<ol>
<li>使用Lambda必须具有接口，且要求<strong>接口中有且仅有一个抽象方法</strong>。<br>无论是JDK内置的<code>Runnable</code>、<code>Comparator</code>接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用Lambda。</li>
<li>使用Lambda必须具有<strong>上下文推断</strong>。<br>也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。</li>
</ol>
<blockquote>
<p>备注：有且仅有一个抽象方法的接口，称为“<strong>函数式接口</strong>”。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Lambda表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>缓冲流、转换流、序列化流</title>
    <url>/2020/08/06/Java%20%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/%E7%BC%93%E5%86%B2%E6%B5%81%E3%80%81%E8%BD%AC%E6%8D%A2%E6%B5%81%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E3%80%81%E6%89%93%E5%8D%B0%E6%B5%81/day10%E3%80%90%E7%BC%93%E5%86%B2%E6%B5%81%E3%80%81%E8%BD%AC%E6%8D%A2%E6%B5%81%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E3%80%81%E6%89%93%E5%8D%B0%E6%B5%81%E3%80%91/</url>
    <content><![CDATA[<h1 id="day10【缓冲流、转换流、序列化流】"><a href="#day10【缓冲流、转换流、序列化流】" class="headerlink" title="day10【缓冲流、转换流、序列化流】"></a>day10【缓冲流、转换流、序列化流】</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li> 缓冲流</li>
<li> 转换流</li>
<li> 序列化流</li>
<li> 打印流</li>
</ul>
<h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><ul>
<li><input disabled="" type="checkbox"> 能够使用字节缓冲流读取数据到程序</li>
<li><input disabled="" type="checkbox"> 能够使用字节缓冲流写出数据到文件</li>
<li><input disabled="" type="checkbox"> 能够明确字符缓冲流的作用和基本用法</li>
<li><input disabled="" type="checkbox"> 能够使用缓冲流的特殊功能</li>
<li><input disabled="" type="checkbox"> 能够阐述编码表的意义</li>
<li><input disabled="" type="checkbox"> 能够使用转换流读取指定编码的文本文件</li>
<li><input disabled="" type="checkbox"> 能够使用转换流写入指定编码的文本文件</li>
<li><input disabled="" type="checkbox"> 能够说出打印流的特点</li>
<li><input disabled="" type="checkbox"> 能够使用序列化流写出对象到文件</li>
<li><input disabled="" type="checkbox"> 能够使用反序列化流读取文件到程序中</li>
</ul>
<h1 id="第一章-缓冲流"><a href="#第一章-缓冲流" class="headerlink" title="第一章 缓冲流"></a>第一章 缓冲流</h1><p>昨天学习了基本的一些流，作为IO流的入门，今天我们要见识一些更强大的流。比如能够高效读写的缓冲流，能够转换编码的转换流，能够持久化存储对象的序列化流等等。这些功能更为强大的流，都是在基本的流对象基础之上创建而来的，就像穿上铠甲的武士一样，相当于是对基本流对象的一种增强。</p>
<h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p>缓冲流,也叫高效流，是对4个基本的<code>FileXxx</code> 流的增强，所以也是4个流，按照数据类型分类：</p>
<ul>
<li><strong>字节缓冲流</strong>：<code>BufferedInputStream</code>，<code>BufferedOutputStream</code> </li>
<li><strong>字符缓冲流</strong>：<code>BufferedReader</code>，<code>BufferedWriter</code></li>
</ul>
<p>缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。</p>
<h2 id="1-2-字节缓冲流"><a href="#1-2-字节缓冲流" class="headerlink" title="1.2 字节缓冲流"></a>1.2 字节缓冲流</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public BufferedInputStream(InputStream in)</code> ：创建一个 新的缓冲输入流。 </li>
<li><code>public BufferedOutputStream(OutputStream out)</code>： 创建一个新的缓冲输出流。</li>
</ul>
<p>构造举例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建字节缓冲输入流</span></span><br><span class="line">BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;bis.txt&quot;</span>));</span><br><span class="line"><span class="comment">// 创建字节缓冲输出流</span></span><br><span class="line">BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;bos.txt&quot;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="效率测试"><a href="#效率测试" class="headerlink" title="效率测试"></a>效率测试</h3><p>查询API，缓冲流读写方法与基本的流是一致的，我们通过复制大文件（375MB），测试它的效率。</p>
<ol>
<li>基本流，代码如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 记录开始时间</span></span><br><span class="line">      	<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		<span class="comment">// 创建流对象</span></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">        	FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;jdk9.exe&quot;</span>);</span><br><span class="line">        	FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;copy.exe&quot;</span>)</span><br><span class="line">        )&#123;</span><br><span class="line">        	<span class="comment">// 读写数据</span></span><br><span class="line">            <span class="keyword">int</span> b;</span><br><span class="line">            <span class="keyword">while</span> ((b = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                fos.write(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 记录结束时间</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;普通流复制时间:&quot;</span>+(end - start)+<span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">十几分钟过去了...</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>缓冲流，代码如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 记录开始时间</span></span><br><span class="line">      	<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		<span class="comment">// 创建流对象</span></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">        	BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;jdk9.exe&quot;</span>));</span><br><span class="line">	     BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;copy.exe&quot;</span>));</span><br><span class="line">        )&#123;</span><br><span class="line">        <span class="comment">// 读写数据</span></span><br><span class="line">            <span class="keyword">int</span> b;</span><br><span class="line">            <span class="keyword">while</span> ((b = bis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bos.write(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 记录结束时间</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;缓冲流复制时间:&quot;</span>+(end - start)+<span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">缓冲流复制时间:<span class="number">8016</span> 毫秒</span><br></pre></td></tr></table></figure>
<p>如何更快呢？</p>
<p>使用数组的方式，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">      	<span class="comment">// 记录开始时间</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		<span class="comment">// 创建流对象</span></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">			BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;jdk9.exe&quot;</span>));</span><br><span class="line">		 BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;copy.exe&quot;</span>));</span><br><span class="line">        )&#123;</span><br><span class="line">          	<span class="comment">// 读写数据</span></span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>*<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = bis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bos.write(bytes, <span class="number">0</span> , len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 记录结束时间</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;缓冲流使用数组复制时间:&quot;</span>+(end - start)+<span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">缓冲流使用数组复制时间:<span class="number">666</span> 毫秒</span><br></pre></td></tr></table></figure>

<h2 id="1-3-字符缓冲流"><a href="#1-3-字符缓冲流" class="headerlink" title="1.3 字符缓冲流"></a>1.3 字符缓冲流</h2><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public BufferedReader(Reader in)</code> ：创建一个 新的缓冲输入流。 </li>
<li><code>public BufferedWriter(Writer out)</code>： 创建一个新的缓冲输出流。</li>
</ul>
<p>构造举例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建字符缓冲输入流</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;br.txt&quot;</span>));</span><br><span class="line"><span class="comment">// 创建字符缓冲输出流</span></span><br><span class="line">BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;bw.txt&quot;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="特有方法"><a href="#特有方法" class="headerlink" title="特有方法"></a>特有方法</h3><p>字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。</p>
<ul>
<li>BufferedReader：<code>public String readLine()</code>: 读一行文字。 </li>
<li>BufferedWriter：<code>public void newLine()</code>: 写一行行分隔符,由系统属性定义符号。 </li>
</ul>
<p><code>readLine</code>方法演示，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedReaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      	 <span class="comment">// 创建流对象</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;in.txt&quot;</span>));</span><br><span class="line">		<span class="comment">// 定义字符串,保存读取的一行文字</span></span><br><span class="line">        String line  = <span class="keyword">null</span>;</span><br><span class="line">      	<span class="comment">// 循环读取,读取到最后返回null</span></span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine())!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(line);</span><br><span class="line">            System.out.println(<span class="string">&quot;------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 释放资源</span></span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>newLine</code>方法演示，代码如下：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedWriterDemo</span> <span class="title">throws</span> <span class="title">IOException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException  </span>&#123;</span><br><span class="line">      	<span class="comment">// 创建流对象</span></span><br><span class="line">		BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;out.txt&quot;</span>));</span><br><span class="line">      	<span class="comment">// 写出数据</span></span><br><span class="line">        bw.write(<span class="string">&quot;黑马&quot;</span>);</span><br><span class="line">      	<span class="comment">// 写出换行</span></span><br><span class="line">        bw.newLine();</span><br><span class="line">        bw.write(<span class="string">&quot;程序&quot;</span>);</span><br><span class="line">        bw.newLine();</span><br><span class="line">        bw.write(<span class="string">&quot;员&quot;</span>);</span><br><span class="line">        bw.newLine();</span><br><span class="line">		<span class="comment">// 释放资源</span></span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出效果:</span><br><span class="line">黑马</span><br><span class="line">程序</span><br><span class="line">员</span><br></pre></td></tr></table></figure>

<h2 id="1-4-练习-文本排序"><a href="#1-4-练习-文本排序" class="headerlink" title="1.4 练习:文本排序"></a>1.4 练习:文本排序</h2><p>请将文本信息恢复顺序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3.侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下。愚以为宫中之事，事无大小，悉以咨之，然后施行，必得裨补阙漏，有所广益。</span><br><span class="line">8.愿陛下托臣以讨贼兴复之效，不效，则治臣之罪，以告先帝之灵。若无兴德之言，则责攸之、祎、允等之慢，以彰其咎；陛下亦宜自谋，以咨诹善道，察纳雅言，深追先帝遗诏，臣不胜受恩感激。</span><br><span class="line">4.将军向宠，性行淑均，晓畅军事，试用之于昔日，先帝称之曰能，是以众议举宠为督。愚以为营中之事，悉以咨之，必能使行阵和睦，优劣得所。</span><br><span class="line">2.宫中府中，俱为一体，陟罚臧否，不宜异同。若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之理，不宜偏私，使内外异法也。</span><br><span class="line">1.先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。</span><br><span class="line">9.今当远离，临表涕零，不知所言。</span><br><span class="line">6.臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻达于诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，咨臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间，尔来二十有一年矣。</span><br><span class="line">7.先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧叹，恐付托不效，以伤先帝之明，故五月渡泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都。此臣所以报先帝而忠陛下之职分也。至于斟酌损益，进尽忠言，则攸之、祎、允之任也。</span><br><span class="line">5.亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨于桓、灵也。侍中、尚书、长史、参军，此悉贞良死节之臣，愿陛下亲之信之，则汉室之隆，可计日而待也。</span><br></pre></td></tr></table></figure>

<h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><ol>
<li>逐行读取文本信息。</li>
<li>解析文本信息到集合中。</li>
<li>遍历集合，按顺序，写出文本信息。</li>
</ol>
<h3 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建map集合,保存文本数据,键为序号,值为文字</span></span><br><span class="line">        HashMap&lt;String, String&gt; lineMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建流对象</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;in.txt&quot;</span>));</span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;out.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取数据</span></span><br><span class="line">        String line  = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine())!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 解析文本</span></span><br><span class="line">            String[] split = line.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">            <span class="comment">// 保存到集合</span></span><br><span class="line">            lineMap.put(split[<span class="number">0</span>],split[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        br.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历map集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lineMap.size(); i++) &#123;</span><br><span class="line">            String key = String.valueOf(i);</span><br><span class="line">            <span class="comment">// 获取map中文本</span></span><br><span class="line">            String value = lineMap.get(key);</span><br><span class="line">          	<span class="comment">// 写出拼接文本</span></span><br><span class="line">            bw.write(key+<span class="string">&quot;.&quot;</span>+value);</span><br><span class="line">          	<span class="comment">// 写出换行</span></span><br><span class="line">            bw.newLine();</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 释放资源</span></span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="第二章-转换流"><a href="#第二章-转换流" class="headerlink" title="第二章 转换流"></a>第二章 转换流</h1><h2 id="2-1-字符编码和字符集"><a href="#2-1-字符编码和字符集" class="headerlink" title="2.1 字符编码和字符集"></a>2.1 字符编码和字符集</h2><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为<strong>编码</strong> 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为<strong>解码</strong> 。比如说，按照A规则存储，同样按照A规则解析，那么就能显示正确的文本符号。反之，按照A规则存储，再按照B规则解析，就会导致乱码现象。</p>
<p>编码:字符(能看懂的)–字节(看不懂的)</p>
<p>解码:字节(看不懂的)–&gt;字符(能看懂的)</p>
<ul>
<li><p><strong>字符编码<code>Character Encoding</code></strong> : 就是一套自然语言的字符与二进制数之间的对应规则。</p>
<p>编码表:生活中文字和计算机中二进制的对应规则</p>
</li>
</ul>
<h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><ul>
<li>**字符集 <code>Charset</code>**：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。</li>
</ul>
<p>计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBK字符集、Unicode字符集等。<img src="/img/1_charset.jpg"></p>
<p>可见，当指定了<strong>编码</strong>，它所对应的<strong>字符集</strong>自然就指定了，所以<strong>编码</strong>才是我们最终要关心的。</p>
<ul>
<li><strong>ASCII字符集</strong> ：<ul>
<li>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。</li>
<li>基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。</li>
</ul>
</li>
<li><strong>ISO-8859-1字符集</strong>：<ul>
<li>拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。</li>
<li>ISO-8859-1使用单字节编码，兼容ASCII编码。</li>
</ul>
</li>
<li><strong>GBxxx字符集</strong>：<ul>
<li>GB就是国标的意思，是为了显示中文而设计的一套字符集。</li>
<li><strong>GB2312</strong>：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。</li>
<li><strong>GBK</strong>：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。</li>
<li><strong>GB18030</strong>：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。</li>
</ul>
</li>
<li><strong>Unicode字符集</strong> ：<ul>
<li>Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。</li>
<li>它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。</li>
<li>UTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则：<ol>
<li>128个US-ASCII字符，只需一个字节编码。</li>
<li>拉丁文等字符，需要二个字节编码。 </li>
<li>大部分常用字（含中文），使用三个字节编码。</li>
<li>其他极少使用的Unicode辅助字符，使用四字节编码。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="2-2-编码引出的问题"><a href="#2-2-编码引出的问题" class="headerlink" title="2.2 编码引出的问题"></a>2.2 编码引出的问题</h2><p>在IDEA中，使用<code>FileReader</code> 读取项目中的文本文件。由于IDEA的设置，都是默认的<code>UTF-8</code>编码，所以没有任何问题。但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileReader fileReader = <span class="keyword">new</span> FileReader(<span class="string">&quot;E:\\File_GBK.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> read;</span><br><span class="line">        <span class="keyword">while</span> ((read = fileReader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)read);</span><br><span class="line">        &#125;</span><br><span class="line">        fileReader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">���</span><br></pre></td></tr></table></figure>

<p>那么如何读取GBK编码的文件呢？ </p>
<h2 id="2-3-InputStreamReader类"><a href="#2-3-InputStreamReader类" class="headerlink" title="2.3 InputStreamReader类"></a>2.3 InputStreamReader类</h2><p>转换流<code>java.io.InputStreamReader</code>，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p>
<h3 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>InputStreamReader(InputStream in)</code>: 创建一个使用默认字符集的字符流。 </li>
<li><code>InputStreamReader(InputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</li>
</ul>
<p>构造举例，代码如下： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;in.txt&quot;</span>));</span><br><span class="line">InputStreamReader isr2 = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;in.txt&quot;</span>) , <span class="string">&quot;GBK&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="指定编码读取"><a href="#指定编码读取" class="headerlink" title="指定编码读取"></a>指定编码读取</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      	<span class="comment">// 定义文件路径,文件为gbk编码</span></span><br><span class="line">        String FileName = <span class="string">&quot;E:\\file_gbk.txt&quot;</span>;</span><br><span class="line">      	<span class="comment">// 创建流对象,默认UTF8编码</span></span><br><span class="line">        InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(FileName));</span><br><span class="line">      	<span class="comment">// 创建流对象,指定GBK编码</span></span><br><span class="line">        InputStreamReader isr2 = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(FileName) , <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">		<span class="comment">// 定义变量,保存字符</span></span><br><span class="line">        <span class="keyword">int</span> read;</span><br><span class="line">      	<span class="comment">// 使用默认编码字符流读取,乱码</span></span><br><span class="line">        <span class="keyword">while</span> ((read = isr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)read); <span class="comment">// ��Һ�</span></span><br><span class="line">        &#125;</span><br><span class="line">        isr.close();</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 使用指定编码字符流读取,正常解析</span></span><br><span class="line">        <span class="keyword">while</span> ((read = isr2.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)read);<span class="comment">// 大家好</span></span><br><span class="line">        &#125;</span><br><span class="line">        isr2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-OutputStreamWriter类"><a href="#2-4-OutputStreamWriter类" class="headerlink" title="2.4 OutputStreamWriter类"></a>2.4 OutputStreamWriter类</h2><p>转换流<code>java.io.OutputStreamWriter</code> ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p>
<h3 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>OutputStreamWriter(OutputStream in)</code>: 创建一个使用默认字符集的字符流。 </li>
<li><code>OutputStreamWriter(OutputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</li>
</ul>
<p>构造举例，代码如下： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OutputStreamWriter isr = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;out.txt&quot;</span>));</span><br><span class="line">OutputStreamWriter isr2 = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;out.txt&quot;</span>) , <span class="string">&quot;GBK&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="指定编码写出"><a href="#指定编码写出" class="headerlink" title="指定编码写出"></a>指定编码写出</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutputDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      	<span class="comment">// 定义文件路径</span></span><br><span class="line">        String FileName = <span class="string">&quot;E:\\out.txt&quot;</span>;</span><br><span class="line">      	<span class="comment">// 创建流对象,默认UTF8编码</span></span><br><span class="line">        OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(FileName));</span><br><span class="line">        <span class="comment">// 写出数据</span></span><br><span class="line">      	osw.write(<span class="string">&quot;你好&quot;</span>); <span class="comment">// 保存为6个字节</span></span><br><span class="line">        osw.close();</span><br><span class="line">      	</span><br><span class="line">		<span class="comment">// 定义文件路径</span></span><br><span class="line">		String FileName2 = <span class="string">&quot;E:\\out2.txt&quot;</span>;</span><br><span class="line">     	<span class="comment">// 创建流对象,指定GBK编码</span></span><br><span class="line">        OutputStreamWriter osw2 = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(FileName2),<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        <span class="comment">// 写出数据</span></span><br><span class="line">      	osw2.write(<span class="string">&quot;你好&quot;</span>);<span class="comment">// 保存为4个字节</span></span><br><span class="line">        osw2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="转换流理解图解"><a href="#转换流理解图解" class="headerlink" title="转换流理解图解"></a>转换流理解图解</h3><p><strong>转换流是字节与字符间的桥梁！</strong><img src="/img/2_zhuanhuan.jpg"></p>
<h2 id="2-5-练习：转换文件编码"><a href="#2-5-练习：转换文件编码" class="headerlink" title="2.5 练习：转换文件编码"></a>2.5 练习：转换文件编码</h2><p>将GBK编码的文本文件，转换为UTF-8编码的文本文件。</p>
<h3 id="案例分析-1"><a href="#案例分析-1" class="headerlink" title="案例分析"></a>案例分析</h3><ol>
<li>指定GBK编码的转换流，读取文本文件。</li>
<li>使用UTF-8编码的转换流，写出文本文件。</li>
</ol>
<h3 id="案例实现-1"><a href="#案例实现-1" class="headerlink" title="案例实现"></a>案例实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;      </span><br><span class="line">    	<span class="comment">// 1.定义文件路径</span></span><br><span class="line">     	String srcFile = <span class="string">&quot;file_gbk.txt&quot;</span>;</span><br><span class="line">        String destFile = <span class="string">&quot;file_utf8.txt&quot;</span>;</span><br><span class="line">		<span class="comment">// 2.创建流对象</span></span><br><span class="line">    	<span class="comment">// 2.1 转换输入流,指定GBK编码</span></span><br><span class="line">        InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(srcFile) , <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    	<span class="comment">// 2.2 转换输出流,默认utf8编码</span></span><br><span class="line">        OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(destFile));</span><br><span class="line">		<span class="comment">// 3.读写数据</span></span><br><span class="line">    	<span class="comment">// 3.1 定义数组</span></span><br><span class="line">        <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">    	<span class="comment">// 3.2 定义长度</span></span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">    	<span class="comment">// 3.3 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((len = isr.read(cbuf))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 循环写出</span></span><br><span class="line">          	osw.write(cbuf,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">// 4.释放资源</span></span><br><span class="line">        osw.close();</span><br><span class="line">        isr.close();</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第三章-序列化"><a href="#第三章-序列化" class="headerlink" title="第三章 序列化"></a>第三章 序列化</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><p>Java 提供了一种对象<strong>序列化</strong>的机制。用一个字节序列可以表示一个对象，该字节序列包含该<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的属性</code>等信息。字节序列写出到文件之后，相当于文件中<strong>持久保存</strong>了一个对象的信息。 </p>
<p>反之，该字节序列还可以从文件中读取回来，重构对象，对它进行<strong>反序列化</strong>。<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的数据</code>信息，都可以用来在内存中创建对象。看图理解序列化： <img src="/img/3_xuliehua.jpg"></p>
<h2 id="3-2-ObjectOutputStream类"><a href="#3-2-ObjectOutputStream类" class="headerlink" title="3.2 ObjectOutputStream类"></a>3.2 ObjectOutputStream类</h2><p><code>java.io.ObjectOutputStream </code> 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。</p>
<h3 id="构造方法-4"><a href="#构造方法-4" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public ObjectOutputStream(OutputStream out) </code>： 创建一个指定OutputStream的ObjectOutputStream。</li>
</ul>
<p>构造举例，代码如下：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileOutputStream fileOut = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;employee.txt&quot;</span>);</span><br><span class="line">ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(fileOut);</span><br></pre></td></tr></table></figure>

<h3 id="序列化操作"><a href="#序列化操作" class="headerlink" title="序列化操作"></a>序列化操作</h3><ol>
<li>一个对象要想序列化，必须满足两个条件:</li>
</ol>
<ul>
<li>该类必须实现<code>java.io.Serializable </code> 接口，<code>Serializable</code> 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出<code>NotSerializableException</code> 。</li>
<li>该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用<code>transient</code> 关键字修饰。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String address;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">transient</span> <span class="keyword">int</span> age; <span class="comment">// transient瞬态修饰成员,不会被序列化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addressCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      	System.out.println(<span class="string">&quot;Address  check : &quot;</span> + name + <span class="string">&quot; -- &quot;</span> + address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.写出对象方法</p>
<ul>
<li><code>public final void writeObject (Object obj)</code> : 将指定的对象写出。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializeDemo</span></span>&#123;</span><br><span class="line">   	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span>   </span>&#123;</span><br><span class="line">    	Employee e = <span class="keyword">new</span> Employee();</span><br><span class="line">    	e.name = <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">    	e.address = <span class="string">&quot;beiqinglu&quot;</span>;</span><br><span class="line">    	e.age = <span class="number">20</span>; </span><br><span class="line">    	<span class="keyword">try</span> &#123;</span><br><span class="line">      		<span class="comment">// 创建序列化流对象</span></span><br><span class="line">          ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;employee.txt&quot;</span>));</span><br><span class="line">        	<span class="comment">// 写出对象</span></span><br><span class="line">        	out.writeObject(e);</span><br><span class="line">        	<span class="comment">// 释放资源</span></span><br><span class="line">        	out.close();</span><br><span class="line">        	fileOut.close();</span><br><span class="line">        	System.out.println(<span class="string">&quot;Serialized data is saved&quot;</span>); <span class="comment">// 姓名，地址被序列化，年龄没有被序列化。</span></span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException i)   &#123;</span><br><span class="line">            i.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">   	&#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">Serialized data is saved</span><br></pre></td></tr></table></figure>

<h2 id="3-3-ObjectInputStream类"><a href="#3-3-ObjectInputStream类" class="headerlink" title="3.3 ObjectInputStream类"></a>3.3 ObjectInputStream类</h2><p>ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 </p>
<h3 id="构造方法-5"><a href="#构造方法-5" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public ObjectInputStream(InputStream in) </code>： 创建一个指定InputStream的ObjectInputStream。</li>
</ul>
<h3 id="反序列化操作1"><a href="#反序列化操作1" class="headerlink" title="反序列化操作1"></a>反序列化操作1</h3><p>如果能找到一个对象的class文件，我们可以进行反序列化操作，调用<code>ObjectInputStream</code>读取对象的方法：</p>
<ul>
<li><code>public final Object readObject ()</code> : 读取一个对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeserializeDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span>   </span>&#123;</span><br><span class="line">        Employee e = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;		</span><br><span class="line">             <span class="comment">// 创建反序列化流</span></span><br><span class="line">             FileInputStream fileIn = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;employee.txt&quot;</span>);</span><br><span class="line">             ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(fileIn);</span><br><span class="line">             <span class="comment">// 读取一个对象</span></span><br><span class="line">             e = (Employee) in.readObject();</span><br><span class="line">             <span class="comment">// 释放资源</span></span><br><span class="line">             in.close();</span><br><span class="line">             fileIn.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException i) &#123;</span><br><span class="line">             <span class="comment">// 捕获其他异常</span></span><br><span class="line">             i.printStackTrace();</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(ClassNotFoundException c)  &#123;</span><br><span class="line">        	<span class="comment">// 捕获类找不到异常</span></span><br><span class="line">             System.out.println(<span class="string">&quot;Employee class not found&quot;</span>);</span><br><span class="line">             c.printStackTrace();</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 无异常,直接打印输出</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Name: &quot;</span> + e.name);	<span class="comment">// zhangsan</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Address: &quot;</span> + e.address); <span class="comment">// beiqinglu</span></span><br><span class="line">        System.out.println(<span class="string">&quot;age: &quot;</span> + e.age); <span class="comment">// 0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 <code>ClassNotFoundException</code> 异常。</strong>  </p>
<h3 id="反序列化操作2"><a href="#反序列化操作2" class="headerlink" title="反序列化操作2"></a><strong>反序列化操作2</strong></h3><p><strong>另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个<code>InvalidClassException</code>异常。</strong>发生这个异常的原因如下：</p>
<ul>
<li>该类的序列版本号与从流中读取的类描述符的版本号不匹配 </li>
<li>该类包含未知数据类型 </li>
<li>该类没有可访问的无参数构造方法 </li>
</ul>
<p><code>Serializable</code> 接口给需要序列化的类，提供了一个序列版本号。<code>serialVersionUID</code> 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 加入序列版本号</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">     <span class="keyword">public</span> String name;</span><br><span class="line">     <span class="keyword">public</span> String address;</span><br><span class="line">     <span class="comment">// 添加新的属性 ,重新编译, 可以反序列化,该属性赋为默认值.</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">int</span> eid; </span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addressCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;Address  check : &quot;</span> + name + <span class="string">&quot; -- &quot;</span> + address);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-4-练习：序列化集合"><a href="#3-4-练习：序列化集合" class="headerlink" title="3.4 练习：序列化集合"></a>3.4 练习：序列化集合</h2><ol>
<li>将存有多个自定义对象的集合序列化操作，保存到<code>list.txt</code>文件中。</li>
<li>反序列化<code>list.txt</code> ，并遍历集合，打印对象信息。</li>
</ol>
<h3 id="案例分析-2"><a href="#案例分析-2" class="headerlink" title="案例分析"></a>案例分析</h3><ol>
<li>把若干学生对象 ，保存到集合中。</li>
<li>把集合序列化。</li>
<li>反序列化读取时，只需要读取一次，转换为集合类型。</li>
<li>遍历集合，可以打印所有的学生信息</li>
</ol>
<h3 id="案例实现-2"><a href="#案例实现-2" class="headerlink" title="案例实现"></a>案例实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// 创建 学生对象</span></span><br><span class="line">		Student student = <span class="keyword">new</span> Student(<span class="string">&quot;老王&quot;</span>, <span class="string">&quot;laow&quot;</span>);</span><br><span class="line">		Student student2 = <span class="keyword">new</span> Student(<span class="string">&quot;老张&quot;</span>, <span class="string">&quot;laoz&quot;</span>);</span><br><span class="line">		Student student3 = <span class="keyword">new</span> Student(<span class="string">&quot;老李&quot;</span>, <span class="string">&quot;laol&quot;</span>);</span><br><span class="line"></span><br><span class="line">		ArrayList&lt;Student&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		arrayList.add(student);</span><br><span class="line">		arrayList.add(student2);</span><br><span class="line">		arrayList.add(student3);</span><br><span class="line">		<span class="comment">// 序列化操作</span></span><br><span class="line">		<span class="comment">// serializ(arrayList);</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 反序列化  </span></span><br><span class="line">		ObjectInputStream ois  = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;list.txt&quot;</span>));</span><br><span class="line">		<span class="comment">// 读取对象,强转为ArrayList类型</span></span><br><span class="line">		ArrayList&lt;Student&gt; list  = (ArrayList&lt;Student&gt;)ois.readObject();</span><br><span class="line">		</span><br><span class="line">      	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++ )&#123;</span><br><span class="line">          	Student s = list.get(i);</span><br><span class="line">        	System.out.println(s.getName()+<span class="string">&quot;--&quot;</span>+ s.getPwd());</span><br><span class="line">      	&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serializ</span><span class="params">(ArrayList&lt;Student&gt; arrayList)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// 创建 序列化流 </span></span><br><span class="line">		ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;list.txt&quot;</span>));</span><br><span class="line">		<span class="comment">// 写出对象</span></span><br><span class="line">		oos.writeObject(arrayList);</span><br><span class="line">		<span class="comment">// 释放资源</span></span><br><span class="line">		oos.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="第四章-打印流"><a href="#第四章-打印流" class="headerlink" title="第四章 打印流"></a>第四章 打印流</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><p>平时我们在控制台打印输出，是调用<code>print</code>方法和<code>println</code>方法完成的，这两个方法都来自于<code>java.io.PrintStream</code>类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。</p>
<h2 id="4-2-PrintStream类"><a href="#4-2-PrintStream类" class="headerlink" title="4.2 PrintStream类"></a>4.2 PrintStream类</h2><h3 id="构造方法-6"><a href="#构造方法-6" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public PrintStream(String fileName)  </code>： 使用指定的文件名创建一个新的打印流。</li>
</ul>
<p>构造举例，代码如下：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PrintStream ps = <span class="keyword">new</span> PrintStream(<span class="string">&quot;ps.txt&quot;</span>)；</span><br></pre></td></tr></table></figure>

<h3 id="改变打印流向"><a href="#改变打印流向" class="headerlink" title="改变打印流向"></a>改变打印流向</h3><p><code>System.out</code>就是<code>PrintStream</code>类型的，只不过它的流向是系统规定的，打印在控制台上。不过，既然是流对象，我们就可以玩一个”小把戏”，改变它的流向。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">// 调用系统的打印流,控制台直接输出97</span></span><br><span class="line">        System.out.println(<span class="number">97</span>);</span><br><span class="line">      </span><br><span class="line">		<span class="comment">// 创建打印流,指定文件的名称</span></span><br><span class="line">        PrintStream ps = <span class="keyword">new</span> PrintStream(<span class="string">&quot;ps.txt&quot;</span>);</span><br><span class="line">      	</span><br><span class="line">      	<span class="comment">// 设置系统的打印流流向,输出到ps.txt</span></span><br><span class="line">        System.setOut(ps);</span><br><span class="line">      	<span class="comment">// 调用系统的打印流,ps.txt中输出97</span></span><br><span class="line">        System.out.println(<span class="number">97</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java流</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程</title>
    <url>/2020/08/06/Java%20%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/day11%E3%80%90%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E3%80%91/</url>
    <content><![CDATA[<h1 id="day11【网络编程】"><a href="#day11【网络编程】" class="headerlink" title="day11【网络编程】"></a>day11【网络编程】</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li> 软件架构CS／BS</li>
<li> 网络通信三要素</li>
<li> TCP通信</li>
<li> Socket套接字</li>
<li> ServerSocket</li>
</ul>
<h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><ul>
<li><input disabled="" type="checkbox"> 能够辨别UDP和TCP协议特点</li>
<li><input disabled="" type="checkbox"> 能够说出TCP协议下两个常用类名称</li>
<li><input disabled="" type="checkbox"> 能够编写TCP协议下字符串数据传输程序</li>
<li><input disabled="" type="checkbox"> 能够理解TCP协议下文件上传案例</li>
<li><input disabled="" type="checkbox"> 能够理解TCP协议下案例2</li>
</ul>
<h1 id="第一章-网络编程入门"><a href="#第一章-网络编程入门" class="headerlink" title="第一章 网络编程入门"></a>第一章 网络编程入门</h1><h2 id="1-1软件结构"><a href="#1-1软件结构" class="headerlink" title="1.1软件结构"></a>1.1软件结构</h2><ul>
<li><strong>C/S结构</strong> ：全称为Client/Server结构，是指客户端和服务器结构。常见程序有ＱＱ、迅雷等软件。</li>
</ul>
<p><img src="/img/1_cs.jpg"></p>
<p><strong>B/S结构</strong> ：全称为Browser/Server结构，是指浏览器和服务器结构。常见浏览器有谷歌、火狐等。</p>
<p><img src="/img/2_bs.jpg"></p>
<p>两种架构各有优势，但是无论哪种架构，都离不开网络的支持。<strong>网络编程</strong>，就是在一定的协议下，实现两台计算机的通信的程序。</p>
<h2 id="1-2-网络通信协议"><a href="#1-2-网络通信协议" class="headerlink" title="1.2 网络通信协议"></a>1.2 网络通信协议</h2><ul>
<li><strong>网络通信协议：</strong>通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。</li>
</ul>
<ul>
<li><strong>TCP/IP协议：</strong> 传输控制协议/因特网互联协议( Transmission Control Protocol/Internet Protocol)，是Internet最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用了4层的分层模型，每一层都呼叫它的下一层所提供的协议来完成自己的需求。</li>
</ul>
<p><img src="/img/3_tcp_ip.jpg"></p>
<p>上图中，TCP/IP协议中的四层分别是应用层、传输层、网络层和链路层，每层分别负责不同的通信功能。<br>链路层：链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。<br>网络层：网络层是整个TCP/IP协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。<br>运输层：主要使网络程序进行通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。<br>应用层：主要负责应用程序的协议，例如HTTP协议、FTP协议等。</p>
<h2 id="1-3-协议分类"><a href="#1-3-协议分类" class="headerlink" title="1.3 协议分类"></a>1.3 协议分类</h2><p>通信的协议还是比较复杂的，<code>java.net</code> 包中包含的类和接口，它们提供低层次的通信细节。我们可以直接使用这些类和接口，来专注于网络程序开发，而不用考虑通信的细节。</p>
<p><code>java.net</code> 包中提供了两种常见的网络协议的支持：</p>
<ul>
<li><p><strong>UDP</strong>：用户数据报协议(User Datagram Protocol)。UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。</p>
<p>由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。</p>
<p>但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议。UDP的交换过程如下图所示。</p>
</li>
</ul>
<p><img src="/img%5CUDP%E9%80%9A%E4%BF%A1%E5%9B%BE%E8%A7%A3.bmp" alt="UDP通信图解"></p>
<p>特点:数据被限制在64kb以内，超出这个范围就不能发送了。</p>
<p>数据报(Datagram):网络传输的基本单位 </p>
<ul>
<li><p><strong>TCP</strong>：传输控制协议 (Transmission Control Protocol)。TCP协议是<strong>面向连接</strong>的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。</p>
<p>在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”。</p>
<ul>
<li>三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。<ul>
<li>第一次握手，客户端向服务器端发出连接请求，等待服务器确认。</li>
<li>第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求。</li>
<li>第三次握手，客户端再次向服务器端发送确认信息，确认连接。整个交互过程如下图所示。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/img/4_tcp.jpg"></p>
<p>​    完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛，例如下载文件、浏览网页等。</p>
<h2 id="1-4-网络编程三要素"><a href="#1-4-网络编程三要素" class="headerlink" title="1.4 网络编程三要素"></a>1.4 网络编程三要素</h2><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><ul>
<li><strong>协议：</strong>计算机网络通信必须遵守的规则，已经介绍过了，不再赘述。</li>
</ul>
<h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><ul>
<li><strong>IP地址：指互联网协议地址（Internet Protocol Address）</strong>，俗称IP。IP地址用来给一个网络中的计算机设备做唯一的编号。假如我们把“个人电脑”比作“一台电话”的话，那么“IP地址”就相当于“电话号码”。</li>
</ul>
<p><strong>IP地址分类</strong></p>
<ul>
<li><p>IPv4：是一个32位的二进制数，通常被分为4个字节，表示成<code>a.b.c.d</code> 的形式，例如<code>192.168.65.100</code> 。其中a、b、c、d都是0~255之间的十进制整数，那么最多可以表示42亿个。</p>
</li>
<li><p>IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。</p>
<p>为了扩大地址空间，拟通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，表示成<code>ABCD:EF01:2345:6789:ABCD:EF01:2345:6789</code>，号称可以为全世界的每一粒沙子编上一个网址，这样就解决了网络地址资源数量不够的问题。</p>
</li>
</ul>
<p><strong>常用命令</strong></p>
<ul>
<li>查看本机IP地址，在控制台输入：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ipconfig</span><br></pre></td></tr></table></figure>

<ul>
<li>检查网络是否连通，在控制台输入：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ping 空格 IP地址</span><br><span class="line">ping <span class="number">220.181</span><span class="number">.57</span><span class="number">.216</span></span><br></pre></td></tr></table></figure>

<p><strong>特殊的IP地址</strong></p>
<ul>
<li>本机IP地址：<code>127.0.0.1</code>、<code>localhost</code> 。</li>
</ul>
<h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>网络的通信，本质上是两个进程（应用程序）的通信。每台计算机都有很多的进程，那么在网络通信时，如何区分这些进程呢？</p>
<p>如果说<strong>IP地址</strong>可以唯一标识网络中的设备，那么<strong>端口号</strong>就可以唯一标识设备中的进程（应用程序）了。</p>
<ul>
<li><strong>端口号：用两个字节表示的整数，它的取值范围是0~65535</strong>。其中，0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败。</li>
</ul>
<p>利用<code>协议</code>+<code>IP地址</code>+<code>端口号</code> 三元组合，就可以标识网络中的进程了，那么进程间的通信就可以利用这个标识与其它进程进行交互。</p>
<h1 id="第二章-TCP通信程序"><a href="#第二章-TCP通信程序" class="headerlink" title="第二章 TCP通信程序"></a>第二章 TCP通信程序</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p>TCP通信能实现两台计算机之间的数据交互，通信的两端，要严格区分为客户端（Client）与服务端（Server）。</p>
<p><strong>两端通信时步骤：</strong></p>
<ol>
<li>服务端程序，需要事先启动，等待客户端的连接。</li>
<li>客户端主动连接服务器端，连接成功才能通信。服务端不可以主动连接客户端。</li>
</ol>
<p><strong>在Java中，提供了两个类用于实现TCP通信程序：</strong></p>
<ol>
<li>客户端：<code>java.net.Socket</code> 类表示。创建<code>Socket</code>对象，向服务端发出连接请求，服务端响应请求，两者建立连接开始通信。</li>
<li>服务端：<code>java.net.ServerSocket</code> 类表示。创建<code>ServerSocket</code>对象，相当于开启一个服务，并等待客户端的连接。</li>
</ol>
<h2 id="2-2-Socket类"><a href="#2-2-Socket类" class="headerlink" title="2.2 Socket类"></a>2.2 Socket类</h2><p><code>Socket</code> 类：该类实现客户端套接字，套接字指的是两台设备之间通讯的端点。</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><p><code>public Socket(String host, int port)</code> :创建套接字对象并将其连接到指定主机上的指定端口号。如果指定的host是null ，则相当于指定地址为回送地址。  </p>
<blockquote>
<p>小贴士：回送地址(127.x.x.x) 是本机回送地址（Loopback Address），主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，立即返回，不进行任何网络传输。</p>
</blockquote>
</li>
</ul>
<p>构造举例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Socket client = <span class="keyword">new</span> Socket(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6666</span>);</span><br></pre></td></tr></table></figure>

<h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><ul>
<li><p><code>public InputStream getInputStream()</code> ： 返回此套接字的输入流。</p>
<ul>
<li>如果此Scoket具有相关联的通道，则生成的InputStream 的所有操作也关联该通道。</li>
<li>关闭生成的InputStream也将关闭相关的Socket。</li>
</ul>
</li>
<li><p><code>public OutputStream getOutputStream()</code> ： 返回此套接字的输出流。</p>
<ul>
<li>如果此Scoket具有相关联的通道，则生成的OutputStream 的所有操作也关联该通道。</li>
<li>关闭生成的OutputStream也将关闭相关的Socket。</li>
</ul>
</li>
<li><p><code>public void close()</code> ：关闭此套接字。</p>
<ul>
<li>一旦一个socket被关闭，它不可再使用。</li>
<li>关闭此socket也将关闭相关的InputStream和OutputStream 。 </li>
</ul>
</li>
<li><p><code>public void shutdownOutput()</code> ： 禁用此套接字的输出流。   </p>
<ul>
<li>任何先前写出的数据将被发送，随后终止输出流。 </li>
</ul>
<h2 id="2-3-ServerSocket类"><a href="#2-3-ServerSocket类" class="headerlink" title="2.3 ServerSocket类"></a>2.3 ServerSocket类</h2></li>
</ul>
<p><code>ServerSocket</code>类：这个类实现了服务器套接字，该对象等待通过网络的请求。</p>
<h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public ServerSocket(int port)</code> ：使用该构造方法在创建ServerSocket对象时，就可以将其绑定到一个指定的端口号上，参数port就是端口号。</li>
</ul>
<p>构造举例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br></pre></td></tr></table></figure>

<h3 id="成员方法-1"><a href="#成员方法-1" class="headerlink" title="成员方法"></a>成员方法</h3><ul>
<li><code>public Socket accept()</code> ：侦听并接受连接，返回一个新的Socket对象，用于和客户端实现通信。该方法会一直阻塞直到建立连接。 </li>
</ul>
<h2 id="2-4-简单的TCP网络程序"><a href="#2-4-简单的TCP网络程序" class="headerlink" title="2.4 简单的TCP网络程序"></a>2.4 简单的TCP网络程序</h2><h3 id="TCP通信分析图解"><a href="#TCP通信分析图解" class="headerlink" title="TCP通信分析图解"></a>TCP通信分析图解</h3><ol>
<li>【服务端】启动,创建ServerSocket对象，等待连接。</li>
<li>【客户端】启动,创建Socket对象，请求连接。</li>
<li>【服务端】接收连接,调用accept方法，并返回一个Socket对象。</li>
<li>【客户端】Socket对象，获取OutputStream，向服务端写出数据。</li>
<li>【服务端】Scoket对象，获取InputStream，读取客户端发送的数据。</li>
</ol>
<blockquote>
<p>到此，客户端向服务端发送数据成功。</p>
</blockquote>
<p><img src="/img/5_%E7%AE%80%E5%8D%95%E9%80%9A%E4%BF%A1.jpg"></p>
<blockquote>
<p>自此，服务端向客户端回写数据。</p>
</blockquote>
<ol start="6">
<li>【服务端】Socket对象，获取OutputStream，向客户端回写数据。</li>
<li>【客户端】Scoket对象，获取InputStream，解析回写数据。</li>
<li>【客户端】释放资源，断开连接。</li>
</ol>
<h3 id="客户端向服务器发送数据"><a href="#客户端向服务器发送数据" class="headerlink" title="客户端向服务器发送数据"></a>客户端向服务器发送数据</h3><p><strong>服务端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerTCP</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端启动 , 等待连接 .... &quot;</span>);</span><br><span class="line">        <span class="comment">// 1.创建 ServerSocket对象，绑定端口，开始等待连接</span></span><br><span class="line">        ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">// 2.接收连接 accept 方法, 返回 socket 对象.</span></span><br><span class="line">        Socket server = ss.accept();</span><br><span class="line">        <span class="comment">// 3.通过socket 获取输入流</span></span><br><span class="line">        InputStream is = server.getInputStream();</span><br><span class="line">        <span class="comment">// 4.一次性读取数据</span></span><br><span class="line">      	<span class="comment">// 4.1 创建字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">      	<span class="comment">// 4.2 据读取到字节数组中.</span></span><br><span class="line">        <span class="keyword">int</span> len = is.read(b)；</span><br><span class="line">        <span class="comment">// 4.3 解析数组,打印字符串信息</span></span><br><span class="line">        String msg = <span class="keyword">new</span> String(b, <span class="number">0</span>, len);</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">        <span class="comment">//5.关闭资源.</span></span><br><span class="line">        is.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientTCP</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;客户端 发送数据&quot;</span>);</span><br><span class="line">		<span class="comment">// 1.创建 Socket ( ip , port ) , 确定连接到哪里.</span></span><br><span class="line">		Socket client = <span class="keyword">new</span> Socket(<span class="string">&quot;localhost&quot;</span>, <span class="number">6666</span>);</span><br><span class="line">		<span class="comment">// 2.获取流对象 . 输出流</span></span><br><span class="line">		OutputStream os = client.getOutputStream();</span><br><span class="line">		<span class="comment">// 3.写出数据.</span></span><br><span class="line">		os.write(<span class="string">&quot;你好么? tcp ,我来了&quot;</span>.getBytes());</span><br><span class="line">		<span class="comment">// 4. 关闭资源 .</span></span><br><span class="line">		os.close();</span><br><span class="line">		client.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="服务器向客户端回写数据"><a href="#服务器向客户端回写数据" class="headerlink" title="服务器向客户端回写数据"></a>服务器向客户端回写数据</h3><p><strong>服务端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerTCP</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端启动 , 等待连接 .... &quot;</span>);</span><br><span class="line">        <span class="comment">// 1.创建 ServerSocket对象，绑定端口，开始等待连接</span></span><br><span class="line">        ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">// 2.接收连接 accept 方法, 返回 socket 对象.</span></span><br><span class="line">        Socket server = ss.accept();</span><br><span class="line">        <span class="comment">// 3.通过socket 获取输入流</span></span><br><span class="line">        InputStream is = server.getInputStream();</span><br><span class="line">        <span class="comment">// 4.一次性读取数据</span></span><br><span class="line">      	<span class="comment">// 4.1 创建字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">      	<span class="comment">// 4.2 据读取到字节数组中.</span></span><br><span class="line">        <span class="keyword">int</span> len = is.read(b)；</span><br><span class="line">        <span class="comment">// 4.3 解析数组,打印字符串信息</span></span><br><span class="line">        String msg = <span class="keyword">new</span> String(b, <span class="number">0</span>, len);</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">      	<span class="comment">// =================回写数据=======================</span></span><br><span class="line">      	<span class="comment">// 5. 通过 socket 获取输出流</span></span><br><span class="line">      	 OutputStream out = server.getOutputStream();</span><br><span class="line">      	<span class="comment">// 6. 回写数据</span></span><br><span class="line">      	 out.write(<span class="string">&quot;我很好,谢谢你&quot;</span>.getBytes());</span><br><span class="line">      	<span class="comment">// 7.关闭资源.</span></span><br><span class="line">      	out.close();</span><br><span class="line">        is.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientTCP</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;客户端 发送数据&quot;</span>);</span><br><span class="line">		<span class="comment">// 1.创建 Socket ( ip , port ) , 确定连接到哪里.</span></span><br><span class="line">		Socket client = <span class="keyword">new</span> Socket(<span class="string">&quot;localhost&quot;</span>, <span class="number">6666</span>);</span><br><span class="line">		<span class="comment">// 2.通过Scoket,获取输出流对象 </span></span><br><span class="line">		OutputStream os = client.getOutputStream();</span><br><span class="line">		<span class="comment">// 3.写出数据.</span></span><br><span class="line">		os.write(<span class="string">&quot;你好么? tcp ,我来了&quot;</span>.getBytes());</span><br><span class="line">      	<span class="comment">// ==============解析回写=========================</span></span><br><span class="line">      	<span class="comment">// 4. 通过Scoket,获取 输入流对象</span></span><br><span class="line">      	InputStream in = client.getInputStream();</span><br><span class="line">      	<span class="comment">// 5. 读取数据数据</span></span><br><span class="line">      	<span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">100</span>];</span><br><span class="line">      	<span class="keyword">int</span> len = in.read(b);</span><br><span class="line">      	System.out.println(<span class="keyword">new</span> String(b, <span class="number">0</span>, len));</span><br><span class="line">		<span class="comment">// 6. 关闭资源 .</span></span><br><span class="line">      	in.close();</span><br><span class="line">		os.close();</span><br><span class="line">		client.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第三章-综合案例"><a href="#第三章-综合案例" class="headerlink" title="第三章 综合案例"></a>第三章 综合案例</h1><h2 id="3-1-文件上传案例"><a href="#3-1-文件上传案例" class="headerlink" title="3.1 文件上传案例"></a>3.1 文件上传案例</h2><h3 id="文件上传分析图解"><a href="#文件上传分析图解" class="headerlink" title="文件上传分析图解"></a>文件上传分析图解</h3><ol>
<li>【客户端】输入流，从硬盘读取文件数据到程序中。</li>
<li>【客户端】输出流，写出文件数据到服务端。</li>
<li>【服务端】输入流，读取文件数据到服务端程序。</li>
<li>【服务端】输出流，写出文件数据到服务器硬盘中。</li>
</ol>
<p><img src="/img/6_upload.jpg">    </p>
<h4 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h4><p><strong>服务端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUpload_Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器 启动.....  &quot;</span>);</span><br><span class="line">        <span class="comment">// 1. 创建服务端ServerSocket</span></span><br><span class="line">      	ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">  		<span class="comment">// 2. 建立连接 </span></span><br><span class="line">        Socket accept = serverSocket.accept();</span><br><span class="line">      	<span class="comment">// 3. 创建流对象</span></span><br><span class="line">      	<span class="comment">// 3.1 获取输入流,读取文件数据</span></span><br><span class="line">        BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(accept.getInputStream());</span><br><span class="line">        <span class="comment">// 3.2 创建输出流,保存到本地 .</span></span><br><span class="line">        BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;copy.jpg&quot;</span>));</span><br><span class="line">		<span class="comment">// 4. 读写数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">8</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = bis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5. 关闭 资源</span></span><br><span class="line">        bos.close();</span><br><span class="line">        bis.close();</span><br><span class="line">        accept.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;文件上传已保存&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUPload_Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流对象</span></span><br><span class="line">        <span class="comment">// 1.1 创建输入流,读取本地文件  </span></span><br><span class="line">        BufferedInputStream bis  = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.jpg&quot;</span>));</span><br><span class="line">        <span class="comment">// 1.2 创建输出流,写到服务端 </span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;localhost&quot;</span>, <span class="number">6666</span>);</span><br><span class="line">        BufferedOutputStream   bos   = <span class="keyword">new</span> BufferedOutputStream(socket.getOutputStream());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.写出数据. </span></span><br><span class="line">        <span class="keyword">byte</span>[] b  = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">8</span> ];</span><br><span class="line">        <span class="keyword">int</span> len ; </span><br><span class="line">        <span class="keyword">while</span> (( len  = bis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">            bos.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;文件发送完毕&quot;</span>);</span><br><span class="line">        <span class="comment">// 3.释放资源</span></span><br><span class="line"></span><br><span class="line">        bos.close(); </span><br><span class="line">        socket.close();</span><br><span class="line">        bis.close(); </span><br><span class="line">        System.out.println(<span class="string">&quot;文件上传完毕 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件上传优化分析"><a href="#文件上传优化分析" class="headerlink" title="文件上传优化分析"></a>文件上传优化分析</h3><ol>
<li><p><strong>文件名称写死的问题</strong></p>
<p>服务端，保存文件的名称如果写死，那么最终导致服务器硬盘，只会保留一个文件，建议使用系统时间优化，保证文件名称唯一，代码如下：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileOutputStream fis = <span class="keyword">new</span> FileOutputStream(System.currentTimeMillis()+<span class="string">&quot;.jpg&quot;</span>) <span class="comment">// 文件名称</span></span><br><span class="line">BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fis);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p><strong>循环接收的问题</strong></p>
<p>服务端，指保存一个文件就关闭了，之后的用户无法再上传，这是不符合实际的，使用循环改进，可以不断的接收不同用户的文件，代码如下：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每次接收新的连接,创建一个Socket</span></span><br><span class="line"><span class="keyword">while</span>（<span class="keyword">true</span>）&#123;</span><br><span class="line">    Socket accept = serverSocket.accept();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p><strong>效率问题</strong></p>
<p>服务端，在接收大文件时，可能耗费几秒钟的时间，此时不能接收其他用户上传，所以，使用多线程技术优化，代码如下：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>（<span class="keyword">true</span>）&#123;</span><br><span class="line">    Socket accept = serverSocket.accept();</span><br><span class="line">    <span class="comment">// accept 交给子线程处理.</span></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      	......</span><br><span class="line">        InputStream bis = accept.getInputStream();</span><br><span class="line">      	......</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="优化实现"><a href="#优化实现" class="headerlink" title="优化实现"></a>优化实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUpload_Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器 启动.....  &quot;</span>);</span><br><span class="line">        <span class="comment">// 1. 创建服务端ServerSocket</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">      	<span class="comment">// 2. 循环接收,建立连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Socket accept = serverSocket.accept();</span><br><span class="line">          	<span class="comment">/* </span></span><br><span class="line"><span class="comment">          	3. socket对象交给子线程处理,进行读写操作</span></span><br><span class="line"><span class="comment">               Runnable接口中,只有一个run方法,使用lambda表达式简化格式</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> (</span><br><span class="line">                    <span class="comment">//3.1 获取输入流对象</span></span><br><span class="line">                    BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(accept.getInputStream());</span><br><span class="line">                    <span class="comment">//3.2 创建输出流对象, 保存到本地 .</span></span><br><span class="line">                    FileOutputStream fis = <span class="keyword">new</span> FileOutputStream(System.currentTimeMillis() + <span class="string">&quot;.jpg&quot;</span>);</span><br><span class="line">                    BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fis);) &#123;</span><br><span class="line">                    <span class="comment">// 3.3 读写数据</span></span><br><span class="line">                    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">8</span>];</span><br><span class="line">                    <span class="keyword">int</span> len;</span><br><span class="line">                    <span class="keyword">while</span> ((len = bis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                      bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//4. 关闭 资源</span></span><br><span class="line">                    bos.close();</span><br><span class="line">                    bis.close();</span><br><span class="line">                    accept.close();</span><br><span class="line">                    System.out.println(<span class="string">&quot;文件上传已保存&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                  	e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="信息回写分析图解"><a href="#信息回写分析图解" class="headerlink" title="信息回写分析图解"></a>信息回写分析图解</h3><p>前四步与基本文件上传一致.</p>
<ol start="5">
<li>【服务端】获取输出流，回写数据。</li>
<li>【客户端】获取输入流，解析回写数据。</li>
</ol>
<p><img src="/img/6_upload2.jpg"></p>
<h4 id="回写实现"><a href="#回写实现" class="headerlink" title="回写实现"></a>回写实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUpload_Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器 启动.....  &quot;</span>);</span><br><span class="line">        <span class="comment">// 1. 创建服务端ServerSocket</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">// 2. 循环接收,建立连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Socket accept = serverSocket.accept();</span><br><span class="line">          	<span class="comment">/*</span></span><br><span class="line"><span class="comment">          	3. socket对象交给子线程处理,进行读写操作</span></span><br><span class="line"><span class="comment">               Runnable接口中,只有一个run方法,使用lambda表达式简化格式</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> (</span><br><span class="line">                    <span class="comment">//3.1 获取输入流对象</span></span><br><span class="line">                    BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(accept.getInputStream());</span><br><span class="line">                    <span class="comment">//3.2 创建输出流对象, 保存到本地 .</span></span><br><span class="line">                    FileOutputStream fis = <span class="keyword">new</span> FileOutputStream(System.currentTimeMillis() + <span class="string">&quot;.jpg&quot;</span>);</span><br><span class="line">                    BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fis);</span><br><span class="line">                ) &#123;</span><br><span class="line">                    <span class="comment">// 3.3 读写数据</span></span><br><span class="line">                    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">8</span>];</span><br><span class="line">                    <span class="keyword">int</span> len;</span><br><span class="line">                    <span class="keyword">while</span> ((len = bis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 4.=======信息回写===========================</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;back ........&quot;</span>);</span><br><span class="line">                    OutputStream out = accept.getOutputStream();</span><br><span class="line">                    out.write(<span class="string">&quot;上传成功&quot;</span>.getBytes());</span><br><span class="line">                    out.close();</span><br><span class="line">                    <span class="comment">//================================</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//5. 关闭 资源</span></span><br><span class="line">                    bos.close();</span><br><span class="line">                    bis.close();</span><br><span class="line">                    accept.close();</span><br><span class="line">                    System.out.println(<span class="string">&quot;文件上传已保存&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUpload_Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流对象</span></span><br><span class="line">        <span class="comment">// 1.1 创建输入流,读取本地文件</span></span><br><span class="line">        BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.jpg&quot;</span>));</span><br><span class="line">        <span class="comment">// 1.2 创建输出流,写到服务端</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;localhost&quot;</span>, <span class="number">6666</span>);</span><br><span class="line">        BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(socket.getOutputStream());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.写出数据.</span></span><br><span class="line">        <span class="keyword">byte</span>[] b  = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">8</span> ];</span><br><span class="line">        <span class="keyword">int</span> len ;</span><br><span class="line">        <span class="keyword">while</span> (( len  = bis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// 关闭输出流,通知服务端,写出数据完毕</span></span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line">        System.out.println(<span class="string">&quot;文件发送完毕&quot;</span>);</span><br><span class="line">        <span class="comment">// 3. =====解析回写============</span></span><br><span class="line">        InputStream in = socket.getInputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] back = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span>];</span><br><span class="line">        in.read(back);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(back));</span><br><span class="line">        in.close();</span><br><span class="line">        <span class="comment">// ============================</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.释放资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">        bis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-2-模拟B-S服务器-扩展知识点"><a href="#3-2-模拟B-S服务器-扩展知识点" class="headerlink" title="3.2 模拟B\S服务器(扩展知识点)"></a>3.2 模拟B\S服务器(扩展知识点)</h2><p>模拟网站服务器，使用浏览器访问自己编写的服务端程序，查看网页效果。</p>
<h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><ol>
<li><p>准备页面数据，web文件夹。</p>
<p>复制到我们Module中，比如复制到day08中</p>
<p><img src="/img%5C%E5%A4%8D%E5%88%B6.png"></p>
</li>
<li><p>我们模拟服务器端，ServerSocket类监听端口，使用浏览器访问</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    	ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8000</span>);</span><br><span class="line">    	Socket socket = server.accept();</span><br><span class="line">    	InputStream in = socket.getInputStream();</span><br><span class="line">   	    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    	<span class="keyword">int</span> len = in.read(bytes);</span><br><span class="line">    	System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,len));</span><br><span class="line">    	socket.close();</span><br><span class="line">    	server.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img%5C%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE.jpg"></p>
</li>
<li><p>服务器程序中字节输入流可以读取到浏览器发来的请求信息</p>
<p><img src="/img%5C%E8%AF%BB%E5%8F%96%E8%AE%BF%E9%97%AE%E4%BF%A1%E6%81%AF.jpg"></p>
</li>
</ol>
<p>GET/web/index.html HTTP/1.1是浏览器的请求消息。/web/index.html为浏览器想要请求的服务器端的资源,使用字符串切割方式获取到请求的资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//转换流,读取浏览器请求第一行</span></span><br><span class="line">BufferedReader readWb = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">String requst = readWb.readLine();</span><br><span class="line"><span class="comment">//取出请求资源的路径</span></span><br><span class="line">String[] strArr = requst.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="comment">//去掉web前面的/</span></span><br><span class="line">String path = strArr[<span class="number">1</span>].substring(<span class="number">1</span>);</span><br><span class="line">System.out.println(path);</span><br></pre></td></tr></table></figure>

<h3 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h3><p>服务端实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端  启动 , 等待连接 .... &quot;</span>);</span><br><span class="line">        <span class="comment">// 创建ServerSocket 对象</span></span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        Socket socket = server.accept();</span><br><span class="line">        <span class="comment">// 转换流读取浏览器的请求消息</span></span><br><span class="line">        BufferedReader readWb = <span class="keyword">new</span></span><br><span class="line">        BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">        String requst = readWb.readLine();</span><br><span class="line">        <span class="comment">// 取出请求资源的路径</span></span><br><span class="line">        String[] strArr = requst.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="comment">// 去掉web前面的/</span></span><br><span class="line">        String path = strArr[<span class="number">1</span>].substring(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 读取客户端请求的资源文件</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes= <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span> ;</span><br><span class="line">        <span class="comment">// 字节输出流,将文件写会客户端</span></span><br><span class="line">        OutputStream out = socket.getOutputStream();</span><br><span class="line">        <span class="comment">// 写入HTTP协议响应头,固定写法</span></span><br><span class="line">        out.write(<span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>.getBytes());</span><br><span class="line">        out.write(<span class="string">&quot;Content-Type:text/html\r\n&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">// 必须要写入空行,否则浏览器不解析</span></span><br><span class="line">        out.write(<span class="string">&quot;\r\n&quot;</span>.getBytes());</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            out.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line">        out.close();</span><br><span class="line">        readWb.close();	</span><br><span class="line">        socket.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="访问效果"><a href="#访问效果" class="headerlink" title="访问效果"></a>访问效果</h3><ul>
<li><strong>火狐</strong></li>
</ul>
<p><img src="/img/%E6%95%88%E6%9E%9C%E5%9B%BE1.png"></p>
<blockquote>
<p>小贴士：不同的浏览器，内核不一样，解析效果有可能不一样。</p>
</blockquote>
<p>发现浏览器中出现很多的叉子,说明浏览器没有读取到图片信息导致。</p>
<p>浏览器工作原理是遇到图片会开启一个线程进行单独的访问,因此在服务器端加入线程技术。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            Socket socket = server.accept();</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Web(socket)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Web</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Web</span><span class="params">(Socket socket)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.socket=socket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//转换流,读取浏览器请求第一行</span></span><br><span class="line">                BufferedReader readWb = <span class="keyword">new</span></span><br><span class="line">                        BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">                String requst = readWb.readLine();</span><br><span class="line">                <span class="comment">//取出请求资源的路径</span></span><br><span class="line">                String[] strArr = requst.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                System.out.println(Arrays.toString(strArr));</span><br><span class="line">                String path = strArr[<span class="number">1</span>].substring(<span class="number">1</span>);</span><br><span class="line">                System.out.println(path);</span><br><span class="line"></span><br><span class="line">                FileInputStream fis = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">                System.out.println(fis);</span><br><span class="line">                <span class="keyword">byte</span>[] bytes= <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="keyword">int</span> len = <span class="number">0</span> ;</span><br><span class="line">                <span class="comment">//向浏览器 回写数据</span></span><br><span class="line">                OutputStream out = socket.getOutputStream();</span><br><span class="line">                out.write(<span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>.getBytes());</span><br><span class="line">                out.write(<span class="string">&quot;Content-Type:text/html\r\n&quot;</span>.getBytes());</span><br><span class="line">                out.write(<span class="string">&quot;\r\n&quot;</span>.getBytes());</span><br><span class="line">                <span class="keyword">while</span>((len = fis.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                    out.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">                &#125;</span><br><span class="line">                fis.close();</span><br><span class="line">                out.close();</span><br><span class="line">                readWb.close();</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>访问效果：</strong></p>
<p><img src="/img/%E6%95%88%E6%9E%9C%E5%9B%BE2.png">图解：</p>
<p><img src="/img%5CBS%E9%80%9A%E4%BF%A1.bmp"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Swagger注解</title>
    <url>/2021/06/30/%E6%9C%AA%E5%8A%A0%E6%A0%87%E9%A2%98/Swagger%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Api</span>：用在请求的类上，表示对类的说明</span><br><span class="line">    tags=<span class="string">&quot;说明该类的作用，可以在UI界面上看到的注解&quot;</span></span><br><span class="line">    value=<span class="string">&quot;该参数没什么意义，在UI界面上也看到，所以不需要配置&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ApiOperation</span>：用在请求的方法上，说明方法的用途、作用</span><br><span class="line">    value=<span class="string">&quot;说明方法的用途、作用&quot;</span></span><br><span class="line">    notes=<span class="string">&quot;方法的备注说明&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ApiImplicitParams</span>：用在请求的方法上，表示一组参数说明</span><br><span class="line">    <span class="meta">@ApiImplicitParam</span>：用在<span class="meta">@ApiImplicitParams</span>注解中，指定一个请求参数的各个方面</span><br><span class="line">        name：参数名</span><br><span class="line">        value：参数的汉字说明、解释</span><br><span class="line">        <span class="keyword">required</span>：参数是否必须传</span><br><span class="line">        paramType：参数放在哪个地方</span><br><span class="line">            · header --&gt; 请求参数的获取：<span class="meta">@RequestHeader</span></span><br><span class="line">            · query --&gt; 请求参数的获取：<span class="meta">@RequestParam</span></span><br><span class="line">            · path（用于restful接口）--&gt; 请求参数的获取：<span class="meta">@PathVariable</span></span><br><span class="line">            · body（不常用）</span><br><span class="line">            · form（不常用）    </span><br><span class="line">        dataType：参数类型，默认<span class="built_in">String</span>，其它值dataType=<span class="string">&quot;Integer&quot;</span>       </span><br><span class="line">        defaultValue：参数的默认值</span><br><span class="line"></span><br><span class="line"><span class="meta">@ApiResponses</span>：用在请求的方法上，表示一组响应</span><br><span class="line">    <span class="meta">@ApiResponse</span>：用在<span class="meta">@ApiResponses</span>中，一般用于表达一个错误的响应信息</span><br><span class="line">        code：数字，例如<span class="number">400</span></span><br><span class="line">        message：信息，例如<span class="string">&quot;请求参数没填好&quot;</span></span><br><span class="line">        response：抛出异常的类</span><br><span class="line"></span><br><span class="line"><span class="meta">@ApiModel</span>：用于响应类上，表示一个返回响应数据的信息</span><br><span class="line">            （这种一般用在post创建的时候，使用<span class="meta">@RequestBody</span>这样的场景，</span><br><span class="line">            请求参数无法使用<span class="meta">@ApiImplicitParam</span>注解进行描述的时候）</span><br><span class="line">    <span class="meta">@ApiModelProperty</span>：用在属性上，描述响应类的属性</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>拷贝文件到linux</title>
    <url>/2021/06/30/%E6%9C%AA%E5%8A%A0%E6%A0%87%E9%A2%98/%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6%E5%88%B0linux/</url>
    <content><![CDATA[<h1 id="拷贝文件到linux"><a href="#拷贝文件到linux" class="headerlink" title="拷贝文件到linux"></a>拷贝文件到linux</h1><p>scp 本机路径 <a href="mailto:root@10.211.55.5">root@10.211.55.5</a>:服务器路径</p>
<p>scp <a href="mailto:root@10.211.55.5">root@10.211.55.</a>:服务器路径 本机路径</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-1               ： 强制scp命令使用协议ssh1</span><br><span class="line">-2               ： 强制scp命令使用协议ssh2</span><br><span class="line">-4               ： 强制scp命令只使用IPv4寻址</span><br><span class="line">-6               ： 强制scp命令只使用IPv6寻址</span><br><span class="line">-B               ： 使用批处理模式（传输过程中不询问传输口令或短语）</span><br><span class="line">-C               ： 允许压缩。（将-C标志传递给ssh，从而打开压缩功能）</span><br><span class="line">-p               ： 保留原文件的修改时间，访问时间和访问权限。</span><br><span class="line">-q               ： 不显示传输进度条。</span><br><span class="line">-r               ： 递归复制整个目录。</span><br><span class="line">-v               ： 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信											息用于调试连接，验证和配置问题。</span><br><span class="line">-c cipher        ： 以cipher将数据传输进行加密，这个选项将直接传递给ssh。</span><br><span class="line">-F ssh_config    ： 指定一个替代的ssh配置文件，此参数直接传递给ssh。</span><br><span class="line">-i identity_file ： 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。</span><br><span class="line">-l <span class="built_in">limit</span>         ： 限定用户所能使用的带宽，以Kbit/s为单位。</span><br><span class="line">-o ssh_option    ： 如果习惯于使用ssh_config(5)中的参数传递方式，</span><br><span class="line">-P port          ： 注意是大写的P, port是指定数据传输用到的端口号</span><br><span class="line">-S program       ： 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>springMVC处理逻辑大致流程</title>
    <url>/2021/06/30/%E6%9C%AA%E5%8A%A0%E6%A0%87%E9%A2%98/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/SpringMVc/</url>
    <content><![CDATA[<p>客户端请求提交到DispatcherServlet<br>由DispatcherServlet控制器查询一个或多个HandlerMapping，找到处理请求的Controller<br>DispatcherServlet将请求提交到Controller<br>Controller调用业务逻辑处理后，返回ModelAndView<br>DispatcherServlet查询一个或多个ViewResoler视图解析器，找到ModelAndView指定的视图<br>视图负责将结果显示到客户端</p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>将多级菜单遍历成树</title>
    <url>/2021/06/30/%E6%9C%AA%E5%8A%A0%E6%A0%87%E9%A2%98/%E5%B0%86%E8%8F%9C%E5%8D%95%E9%81%8D%E5%8E%86%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Menu</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 菜单id</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 菜单名称</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 父菜单id</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String parentId;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 菜单url</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 菜单图标</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String icon;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 菜单顺序</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> order;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 子菜单</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> List&lt;Menu&gt; childMenus;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... 省去getter和setter方法以及toString方法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>//复制代码</p>
<p>//递归主题方法：</p>
<p>//复制代码</p>
<p> /**</p>
<p>   * 模块名称</p>
<p>   */</p>
<p>   public Map&lt;String,Object&gt; testQueryMenuList() {</p>
<p>​     // 原始的数据</p>
<p>​    List<Menu> rootMenu = menuDao.queryMenuList(null);</p>
<p>​     // 查看结果</p>
<p>​    for (Menu menu : rootMenu) {</p>
<p>​      System.out.println(menu);</p>
<p>​    }</p>
<p>​     // 最后的结果</p>
<p>​    List<Menu> menuList = new ArrayList<Menu>();</p>
<p>​     // 先找到所有的一级菜单</p>
<p>​    for (int i = 0; i &lt; rootMenu.size(); i++) {</p>
<p>​       // 一级菜单没有parentId</p>
<p>​      if (StringUtils.isBlank(rootMenu.get(i).getParentId())) {</p>
<p>​        menuList.add(rootMenu.get(i));</p>
<p>​      }</p>
<p>​    }</p>
<p>​     // 为一级菜单设置子菜单，getChild是递归调用的</p>
<p>​    for (Menu menu : menuList) {</p>
<p>​      menu.setChildMenus(getChild(menu.getId(), rootMenu));</p>
<p>​    }</p>
<p>​    Map&lt;String, Object&gt; jsonMap = new HashMap&lt;&gt;();</p>
<p>​    jsonMap.put(“menu”, menuList);</p>
<p>​    //System.out.println(gson.toJson(jsonMap));//使用gson需要在pom.xml引入gson依赖见 2.1步骤</p>
<p>​    //return gson.toJson(jsonMap);//返回类型为String</p>
<p>​     return jsonMap;</p>
<p>   }</p>
<p>   /**</p>
<p>   * 子方法</p>
<p>   **/</p>
<p>   private List<Menu> getChild(String id, List<Menu> rootMenu) {</p>
<p>​     // 子菜单</p>
<p>​    List<Menu> childList = new ArrayList&lt;&gt;();</p>
<p>​    for (Menu menu : rootMenu) {</p>
<p>​       // 遍历所有节点，将父菜单id与传过来的id比较</p>
<p>​      if (StringUtils.isNotBlank(menu.getParentId())) {</p>
<p>​        if (menu.getParentId().equals(id)) {</p>
<p>​          childList.add(menu);</p>
<p>​        }</p>
<p>​      }</p>
<p>​    }</p>
<p>​     // 把子菜单的子菜单再循环一遍</p>
<p>​    for (Menu menu : childList) {// 没有url子菜单还有子菜单</p>
<p>   //该节点不含子节点 具体见2.2解释</p>
<p>​       if (StringUtils.isBlank(menu.getUrl())) {</p>
<p>​         // 递归</p>
<p>​        menu.setChildMenus(getChild(menu.getId(), rootMenu));</p>
<p>​      }</p>
<p>​    } // 递归退出条件</p>
<p>​    if (childList.size() == 0) {</p>
<p>​      return null;</p>
<p>​    }</p>
<p>​    return childList;</p>
<p>   }</p>
<p>//复制代码</p>
<p> //2.1.引入依赖pom.xml</p>
<dependency>

<p>  <groupId>com.google.code.gson</groupId></p>
<p>  <artifactId>gson</artifactId></p>
<p>  <version>2.2.8</version></p>
</dependency>



 



<p>2.2 StringUtils.isBlank(menu.getUrl())</p>
<p>这里根据需求可做改动，我这里如果一个菜单有子菜单的话该菜单是没有url的，子菜单才有具体的url跳转，父菜单不用绑定url点击后只展示子菜单并不进行请求接口，</p>
<p>所以没有url的菜单肯定是有子菜单的，有了url的菜单肯定是最终级别分支的菜单，所以对url进行判空决定是否再去查询子菜单</p>
]]></content>
      <categories>
        <category>代码优化</category>
      </categories>
      <tags>
        <tag>骚操作</tag>
      </tags>
  </entry>
  <entry>
    <title>githubAction自动部署giteePages</title>
    <url>/2021/06/30/%E6%9C%AA%E5%8A%A0%E6%A0%87%E9%A2%98/githubAction%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2giteePages/</url>
    <content><![CDATA[<h3 id="生成公钥和私钥并填入仓库"><a href="#生成公钥和私钥并填入仓库" class="headerlink" title="生成公钥和私钥并填入仓库"></a>生成公钥和私钥并填入仓库</h3><p>#输入<code>ssh-keygen -t rsa -C &quot;user@email.com&quot;</code>，然后回车几次，会生成 <code>id_rsa.pub</code> 文件和 <code>id_rsa</code> 文件，分别存放公钥和私钥：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;zjarlin@outlook.com&quot;</span></span><br><span class="line"><span class="comment">#三次回车====================</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ~/.ssh</span><br><span class="line">pbcopy&lt;id_rsa.pub <span class="comment">#将内容复制到剪切板,复制到gitee公钥和仓库公钥</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#进图github要做的事==================</span></span><br><span class="line"></span><br><span class="line">pbcopy&lt;id_rsa   <span class="comment">#填入GITEE_RSA_PRIVATE_KEY</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>假如有以下四个仓库：</p>
<ol>
<li><a href="https://links.jianshu.com/go?to=mailto:git@github.com">git@github.com</a>:somenzz/push_blog：写博客的项目仓库，里面有用于生成博客的 md 文件，和生成静态博客的脚手架，比如 VuePress，hexo 等，该仓库可以私有。</li>
<li><a href="https://links.jianshu.com/go?to=mailto:git@github.com">git@github.com</a>:somenzz/<a href="https://links.jianshu.com/go?to=http://somenzz.github.io">somenzz.github.io</a>：存放博客的静态资源文件，用于 GitHub Pages 展示博客，必须开源。</li>
<li><a href="https://links.jianshu.com/go?to=mailto:git@gitee.com">git@gitee.com</a>/somenzz/somenzz：存放博客的静态资源文件，用于 Gitee Pages 展示博客，必须开源。</li>
<li>ip 地址：xxx.xxx.xxx.xxx，或者域名 somenzz.cn，路径 /xxxx/public/，是自己购买的服务器，用于存放静态博客资源文件。</li>
</ol>
<p>现在的目标就是，写好一篇文章，向仓库 1 推送之后，仓库 2、3、4 自动更新静态资源文件。当然了，你也可以根据自己情况，选择性的更新 2、3、4 中的一个或多个，只需要将对应的步骤从 GitHub Actions 配置中注释或删除即可。</p>
<h2 id="1-先定一个小目标"><a href="#1-先定一个小目标" class="headerlink" title="1. 先定一个小目标"></a>1. 先定一个小目标</h2><p>假如有以下四个仓库：</p>
<ol>
<li><a href="https://links.jianshu.com/go?to=mailto:git@github.com">git@github.com</a>:somenzz/push_blog：写博客的项目仓库，里面有用于生成博客的 md 文件，和生成静态博客的脚手架，比如 VuePress，hexo 等，该仓库可以私有。</li>
<li><a href="https://links.jianshu.com/go?to=mailto:git@github.com">git@github.com</a>:somenzz/<a href="https://links.jianshu.com/go?to=http://somenzz.github.io">somenzz.github.io</a>：存放博客的静态资源文件，用于 GitHub Pages 展示博客，必须开源。</li>
<li><a href="https://links.jianshu.com/go?to=mailto:git@gitee.com">git@gitee.com</a>/somenzz/somenzz：存放博客的静态资源文件，用于 Gitee Pages 展示博客，必须开源。</li>
<li>ip 地址：xxx.xxx.xxx.xxx，或者域名 somenzz.cn，路径 /xxxx/public/，是自己购买的服务器，用于存放静态博客资源文件。</li>
</ol>
<p>现在的目标就是，写好一篇文章，向仓库 1 推送之后，仓库 2、3、4 自动更新静态资源文件。当然了，你也可以根据自己情况，选择性的更新 2、3、4 中的一个或多个，只需要将对应的步骤从 GitHub Actions 配置中注释或删除即可。</p>
<h2 id="2-理解-GitHub-Actions"><a href="#2-理解-GitHub-Actions" class="headerlink" title="2. 理解 GitHub Actions"></a>2. 理解 GitHub Actions</h2><p>这里说下我对 GitHub Actions 的理解，你提交到仓库 1 后，GitHub 会监控到，然后分配一台虚拟机先将你的项目 checkout 过去，然后按照你指定的 step 顺序执行定义好的 action，这些 action 就包括 <code>npm run build</code> 生成静态文件，push 到你指定的仓库等动作。</p>
<p>这就不可避免的涉及一些访问权限的控制，你要向 GitHub 证明你对这些仓库有控制权限，有些操作，还需要你提供 RSA 的私钥，登录的口令，当然了，这些口令都是加密存放的，不会泄漏，可放心使用。</p>
<p>为了实现上面的小目标，我们要让 GitHub 替我们做的事情如下：</p>
<ol>
<li>编译项目，生成静态文件。也就是对仓库 1: <a href="https://links.jianshu.com/go?to=mailto:git@github.com">git@github.com</a>:somenzz/push_blog，执行 npm run build 生成博客的静态资源。</li>
<li>将静态资源 push 到 GitHub，也就是 push 到仓库 2: <a href="https://links.jianshu.com/go?to=mailto:git@github.com">git@github.com</a>:somenzz/<a href="https://links.jianshu.com/go?to=http://somenzz.github.io">somenzz.github.io</a>，这一步完成后 GitHub Pages 就部署完成了。</li>
<li>将仓库 2 同步给仓库 3，也就是 <a href="https://links.jianshu.com/go?to=mailto:git@github.com">git@github.com</a>:somenzz/<a href="https://links.jianshu.com/go?to=http://somenzz.github.io">somenzz.github.io</a> 同步给 <a href="https://links.jianshu.com/go?to=mailto:git@gitee.com">git@gitee.com</a>/somenzz/somenzz，这样两个项目的静态资源就一致了。</li>
<li>部署 Gitee Pages，因为 Gitee 的限制，需要手动点一下更新，现在把这一步变成一个 GitHub action。</li>
<li>使用 rsync 增量同步工具，将静态资源同步的自购服务器的对应目录上。</li>
</ol>
<h2 id="3-一步一步跟我操作"><a href="#3-一步一步跟我操作" class="headerlink" title="3.  一步一步跟我操作"></a>3.  一步一步跟我操作</h2><p>现在，我们一步一步来。</p>
<p>首先在仓库 1 的根目录下，创建 <code>.github/workflows/main.yml</code> 文件，这就是 GitHub Actions 功能的配置文件，用于告诉 GitHub 要做哪些事情，写入以下内容</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">GitHub</span> <span class="string">Pages</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 触发条件：在 push 到 master 分支后</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 任务</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build-and-deploy:</span></span><br><span class="line">    <span class="comment"># 服务器环境：最新版 Ubuntu</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="comment"># 拉取代码</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">persist-credentials:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 1、生成静态文件</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">&amp;&amp;</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 2、部署到 GitHub Pages</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">JamesIves/github-pages-deploy-action@releases/v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">ACCESS_TOKEN:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.ACCESS_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">REPOSITORY_NAME:</span> <span class="string">somenzz/somenzz.github.io</span></span><br><span class="line">          <span class="attr">BRANCH:</span> <span class="string">master</span></span><br><span class="line">          <span class="attr">FOLDER:</span> <span class="string">public</span></span><br><span class="line">          <span class="comment">#注意这里的 public 是仓库根目录下的 public，也就是 npm run build 生成静态资源的路径，比如有的人是 `docs/.vuepress/dist`</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 3、同步到 gitee 的仓库</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Sync</span> <span class="string">to</span> <span class="string">Gitee</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">wearerequired/git-mirror-action@master</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="comment"># 注意在 Settings-&gt;Secrets 配置 GITEE_RSA_PRIVATE_KEY</span></span><br><span class="line">          <span class="attr">SSH_PRIVATE_KEY:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITEE_RSA_PRIVATE_KEY</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="comment"># 注意替换为你的 GitHub 源仓库地址</span></span><br><span class="line">          <span class="attr">source-repo:</span> <span class="string">git@github.com:somenzz/somenzz.github.io.git</span></span><br><span class="line">          <span class="comment"># 注意替换为你的 Gitee 目标仓库地址</span></span><br><span class="line">          <span class="attr">destination-repo:</span> <span class="string">git@gitee.com:somenzz/somenzz.git</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 4、部署到 Gitee Pages</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span> <span class="string">Gitee</span> <span class="string">Pages</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">yanglbme/gitee-pages-action@main</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="comment"># 注意替换为你的 Gitee 用户名</span></span><br><span class="line">          <span class="attr">gitee-username:</span> <span class="string">somenzz</span></span><br><span class="line">          <span class="comment"># 注意在 Settings-&gt;Secrets 配置 GITEE_PASSWORD</span></span><br><span class="line">          <span class="attr">gitee-password:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITEE_PASSWORD</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="comment"># 注意替换为你的 Gitee 仓库，仓库名严格区分大小写，请准确填写，否则会出错</span></span><br><span class="line">          <span class="attr">gitee-repo:</span> <span class="string">somenzz/somenzz</span></span><br><span class="line">          <span class="comment"># 要部署的分支，默认是 master，若是其他分支，则需要指定（指定的分支必须存在）</span></span><br><span class="line">          <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 5、部署到 somenzz.cn 服务器</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">rsync</span> <span class="string">deployments</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">burnett01/rsync-deployments@4.1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="comment"># 这里是 rsync 的参数 switches: -avzh --delete --exclude=&quot;&quot; --include=&quot;&quot; --filter=&quot;&quot;</span></span><br><span class="line">          <span class="attr">switches:</span> <span class="string">-avzh</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">public/</span></span><br><span class="line">          <span class="attr">remote_path:</span> <span class="string">/home/ubuntu/public/</span></span><br><span class="line">          <span class="attr">remote_host:</span> <span class="string">somenzz.cn</span></span><br><span class="line">          <span class="attr">remote_port:</span> <span class="number">22</span></span><br><span class="line">          <span class="attr">remote_user:</span> <span class="string">ubuntu</span></span><br><span class="line">          <span class="attr">remote_key:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.MY_UBUNTU_RSA_PRIVATE_KEY</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>稍微有点长，为了便于你理解，每一步我都有注释，这就是实现这个小目标，GitHub Actions 工作流需要的全部内容，遵循 YAML 格式，这里我做一个大致的说明：</p>
<ul>
<li>on 表示触发条件</li>
<li>jobs 表示要做的工作</li>
<li>jobs 下的 step 表示要做的步骤，前一步失败，后面不会继续执行。</li>
<li>jobs 下的 step 下有 name、uses、with 等，表示一个 action。</li>
<li>name 表示 action 的名称，uses 表示使用哪个插件，with 表示传给插件的参数。</li>
<li><code>secrets.XXX</code> 这个 XXX 表示本仓库的环境变量，配置在仓库设置里面的 secrets 菜单栏，都是加密的。</li>
</ul>
<p>uses  中用的就是别人写好的插件，持续集成由很多操作组成，比如抓取代码、运行测试、登录远程服务器，发布到第三方服务等等，这些操作都用共性，GitHub  就允许其他人把写好的插件共享到插件市场供其他人使用，因此如果你需要某个 action，不必自己写复杂的脚本，直接引用他人写好的 action  即可，你说方便不方便，插件市场见本文的学习资源小节。。</p>
<p>上述文件 <code>.github/workflows/main.yml</code> 写好之后，先别着急 push，一旦 push，这些 actions 就会执行，在参数正确的配置之前，报错那是肯定的。</p>
<p>接下来我说一下一些参数的意义以及如何确定这些参数的值。</p>
<h3 id="1、secrets-ACCESS-TOKEN"><a href="#1、secrets-ACCESS-TOKEN" class="headerlink" title="1、secrets.ACCESS_TOKEN"></a>1、secrets.ACCESS_TOKEN</h3><p>对应的配置代码：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 部署到 GitHub Pages</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line">  <span class="attr">uses:</span> <span class="string">JamesIves/github-pages-deploy-action@releases/v3</span></span><br><span class="line">  <span class="attr">with:</span></span><br><span class="line">    <span class="attr">ACCESS_TOKEN:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.ACCESS_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">REPOSITORY_NAME:</span> <span class="string">somenzz/somenzz.github.io</span></span><br><span class="line">    <span class="attr">BRANCH:</span> <span class="string">master</span></span><br><span class="line">    <span class="attr">FOLDER:</span> <span class="string">public</span></span><br></pre></td></tr></table></figure>

<p>这个 ACCESS_TOKEN 是访问 GitHub API 的令牌，可以在 GitHub 主页，点击个人头像，Settings  -&gt; Developer settings -&gt; Personal access tokens  进行生成或更新，第一次生成后你可以看到这个令牌，然后再也不会显示，因此你需要记下来，假如这个字符串是 aaa，然后打开仓库 1 的设置页面，设置 secrets，加入环境变量， name 是 ACCESS_TOKEN，value 是 aaa。如下图所示：</p>
<p><img src="/" alt="img"></p>
<p>image</p>
<p><img src="/" alt="img"></p>
<p>image</p>
<p><img src="/" alt="img"></p>
<p>image</p>
<p>这一段配置文件的作用就是，将 public 目录内的文件 push 到 somenzz/somenzz.github.io 的 master 分支，其中 public 就是 <code>npm run build</code> 生成的静态资源所在的位置。</p>
<h3 id="2、secrets-GITEE-RSA-PRIVATE-KEY"><a href="#2、secrets-GITEE-RSA-PRIVATE-KEY" class="headerlink" title="2、secrets.GITEE_RSA_PRIVATE_KEY"></a>2、secrets.GITEE_RSA_PRIVATE_KEY</h3><p>没错，这里就是 RSA 的私钥，这里如果你不熟悉 RSA，可能会产生困惑，不是说公钥在网上传输，私钥不公开吗？  没错，确实是这样，Gitee 上保存你账户对应的公钥，GitHub 仓库的 secrets.GITEE_RSA_PRIVATE_KEY  保存着私钥，因为 GitHub 的服务器不会让你亲自登录设置密钥对，因此需要配置 secrets.GITEE_RSA_PRIVATE_KEY  来告知 GitHub，解密操作需要的私钥并不是在网上传输，只有自己知道。</p>
<p>GitHub Actions 的服务器会使用你的账户登录 Gitee，Gitee 使用你的公钥加密后传输给这台服务器，这台服务器使用你设置的私钥才能解密成功，通讯完成。如果想搞懂 RSA 算法可以看我之前写的文章<a href="https://links.jianshu.com/go?to=https://mp.weixin.qq.com/s/k0FhH0RC2qxh-uljBNwbHw">一文搞懂 RSA 算法</a>，是全网讲的最明白的文章。</p>
<p>这里说下如何生成 RSA 的公钥和私钥。</p>
<p>打开终端，输入以下命令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t ed25519 -C <span class="string">&quot;your_email@example.com&quot;</span></span><br></pre></td></tr></table></figure>

<p>这里的邮箱是你 Gitee 的注册邮箱。如果服务器不支持 ed25519 算法，可以这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b <span class="number">4096</span> -C <span class="string">&quot;your_email@example.com&quot;</span></span><br></pre></td></tr></table></figure>

<p>我这里使用的就是第二种，然后一路回车即可。执行完成后，在 <code>~/.ssh</code> 目录下可以看到 id_rsa、id_rsa.pub 等文件，其中私钥就是 id_rsa，公钥就是 id_rsa.pub，这就是密钥对，一个可用于加密，另一个可用于解密。</p>
<p>打开 gitee.com 并登录，点击自己头像右下角，选择设置-&gt; ssh 公钥，将 id_rsa.pub 的内容复制到公钥的输入框里，公钥的标题可以自己填写，如下图所示：</p>
<p><img src="/" alt="img"></p>
<p>image</p>
<p>接下来设置 secrets.GITEE_RSA_PRIVATE_KEY ，在 GitHub 上打开仓库 1 的设置页面，点击  secrets，增加环境变量，name 就填写 secrets.GITEE_RSA_PRIVATE_KEY，value 就填写 id_rsa  文件的内容，如下图所示：</p>
<p><img src="/" alt="img"></p>
<p>image</p>
<p>注意 id_rsa 文件的内容通常如下所示：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ cat id_rsa</span><br><span class="line">-----BEGIN OPENSSH PRIVATE KEY-----</span><br><span class="line">b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAACFwAAAAdzc2gtcn</span><br><span class="line">NhAAAAAwEAAQAAAgEA4v2D0sH/puF4GWZdCfeontuoInVna7jxmtrnHxiOHkoIt5Mp/lMO</span><br><span class="line">6kHWxpSxumQ+CAuqdVYGcsE+8FL0wCBBolpAK7jmX+S7l9wTkPJxYduOPxRBbKFKZp07R/</span><br><span class="line">......</span><br><span class="line">C2FVan1VGNpJ/wAAAA9zb21lbnp6QDE2My5jb20BAg==</span><br><span class="line">-----END OPENSSH PRIVATE KEY-----</span><br></pre></td></tr></table></figure>

<p>注意第一行和最后一行也是要添加进去的，不然 GitHub actions 会提示 id_rsa 格式不正确。</p>
<h3 id="3、secrets-GITEE-PASSWORD"><a href="#3、secrets-GITEE-PASSWORD" class="headerlink" title="3、secrets.GITEE_PASSWORD"></a>3、secrets.GITEE_PASSWORD</h3><p>对应的配置文件代码段：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 4、部署到 Gitee Pages</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span> <span class="string">Gitee</span> <span class="string">Pages</span></span><br><span class="line">  <span class="attr">uses:</span> <span class="string">yanglbme/gitee-pages-action@main</span></span><br><span class="line">  <span class="attr">with:</span></span><br><span class="line">    <span class="comment"># 注意替换为你的 Gitee 用户名</span></span><br><span class="line">    <span class="attr">gitee-username:</span> <span class="string">somenzz</span></span><br><span class="line">    <span class="comment"># 注意在 Settings-&gt;Secrets 配置 GITEE_PASSWORD</span></span><br><span class="line">    <span class="attr">gitee-password:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITEE_PASSWORD</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="comment"># 注意替换为你的 Gitee 仓库，仓库名严格区分大小写，请准确填写，否则会出错</span></span><br><span class="line">    <span class="attr">gitee-repo:</span> <span class="string">somenzz/somenzz</span></span><br><span class="line">    <span class="comment"># 要部署的分支，默认是 master，若是其他分支，则需要指定（指定的分支必须存在）</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<p>这里就很简单了，用户名可以明文，密码一定要放在 secrets 环境变量中，即使仓库开源，也不至于泄漏自己的登录密码信息，这一步依然是在仓库 1 的设置页面添加 secrets 环境变量，和前述的操作一样，不在赘述。</p>
<h3 id="4、secrets-MY-UBUNTU-RSA-PRIVATE-KEY"><a href="#4、secrets-MY-UBUNTU-RSA-PRIVATE-KEY" class="headerlink" title="4、secrets.MY_UBUNTU_RSA_PRIVATE_KEY"></a>4、secrets.MY_UBUNTU_RSA_PRIVATE_KEY</h3><p>对应的配置文件代码段</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 5、部署到 somenzz.cn 服务器</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">rsync</span> <span class="string">deployments</span></span><br><span class="line">  <span class="attr">uses:</span> <span class="string">burnett01/rsync-deployments@4.1</span></span><br><span class="line">  <span class="attr">with:</span></span><br><span class="line">    <span class="comment"># 这里是 rsync 的参数 switches: -avzh --delete --exclude=&quot;&quot; --include=&quot;&quot; --filter=&quot;&quot;</span></span><br><span class="line">    <span class="attr">switches:</span> <span class="string">-avzh</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">public/</span></span><br><span class="line">    <span class="attr">remote_path:</span> <span class="string">/home/ubuntu/public/</span></span><br><span class="line">    <span class="attr">remote_host:</span> <span class="string">somenzz.cn</span></span><br><span class="line">    <span class="attr">remote_port:</span> <span class="number">22</span></span><br><span class="line">    <span class="attr">remote_user:</span> <span class="string">ubuntu</span></span><br><span class="line">    <span class="attr">remote_key:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.MY_UBUNTU_RSA_PRIVATE_KEY</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>这个是自购服务器的私钥，一般情况下云服务器都会提供一个私钥文件，推荐你使用私钥登录服务器，和第二个参数的原理是一致的，如果服务器没有给你这个私钥，请自行生成一个可用于登录的私钥。</p>
<p>这里用到了 rsync，是一个增量同步工具，可以只传输有变化的文件，大大减轻网络带宽，具体的使用方法可参考阮一峰老师的教程：<a href="https://links.jianshu.com/go?to=https://www.ruanyifeng.com/blog/2020/08/rsync.html">https://www.ruanyifeng.com/blog/2020/08/rsync.html</a></p>
<h2 id="执行、验证、结果通知"><a href="#执行、验证、结果通知" class="headerlink" title="执行、验证、结果通知"></a>执行、验证、结果通知</h2><p>以上 4 个参数配置完成之后，就可以对仓库 1 push，然后点开 GitHub 上的 actions 看下执行过程。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> xxx/push_blog/</span><br><span class="line">$ git add -u</span><br><span class="line">$ git commit -m <span class="string">&quot;add article&quot;</span></span><br><span class="line">$ git push</span><br></pre></td></tr></table></figure>

<p>打开 GitHub 上的 push_blog 仓库，点击 Actions，可以看到部署的结果，结果的标题就是 commit 信息，如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12989993-5910e158ea53697d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200" alt="img"></p>
<p>image</p>
<p>点击标题，可以看到详细情况：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12989993-f51256264af7a282.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200" alt="img"></p>
<p>image</p>
<p>再点击，可以看到每一个 action 的详情：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12989993-63c88ccb179763e4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200" alt="img"></p>
<p>image</p>
<p>接下来就是访问下网站是否正常：</p>
<ul>
<li><a href="https://links.jianshu.com/go?to=https://somenzz.github.io">https://somenzz.github.io</a></li>
<li><a href="https://links.jianshu.com/go?to=https://somenzz.gitee.io">https://somenzz.gitee.io</a></li>
<li><a href="https://links.jianshu.com/go?to=https://somenzz.cn">https://somenzz.cn</a></li>
</ul>
<p>强制刷新下，看看新增的文章是否已经到位。</p>
<p>你会问了，如果报错了怎么收到通知？ 点击 Notifications 添加接受通知的邮件即可，如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/12989993-1eda5c4a17d4b910.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200" alt="img"></p>
<p>链接：<a href="https://www.jianshu.com/p/5911a37118cd">https://www.jianshu.com/p/5911a37118cd</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
